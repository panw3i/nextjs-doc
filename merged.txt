

# Introduction

Welcome to the Next.js documentation!

Next.js is a framework for building web applications.

With Next.js, you can build user interfaces using React components. Then,
Next.js provides additional structure, features, and optimizations for your
application.

Under the hood, Next.js also abstracts and automatically configures tooling
for you, like bundling, compiling, and more. This allows you to focus on
building your application instead of spending time setting up tooling.

Whether you're an individual developer or part of a larger team, Next.js can
help you build interactive, dynamic, and fast web applications.

Some of the main Next.js features include:

Feature| Description  
---|---  
Routing| A file-system based router built on top of Server Components that
supports layouts, nested routing, loading states, error handling, and more.  
Rendering| Client-side and Server-side Rendering with Client and Server
Components. Further optimized with Static and Dynamic Rendering on the server
with Next.js. Streaming on Edge and Node.js runtimes.  
Data Fetching| Simplified data fetching with async/await support in React
Components and the `fetch()`s API that aligns with React and the Web Platform.  
Styling| Support for your preferred styling methods, including CSS Modules,
Tailwind CSS, and CSS-in-JS  
Optimizations| Image, Fonts, and Script Optimizations to improve your
application's Core Web Vitals and User Experience.  
Typescript| Improved support for TypeScript, with better type checking and
more efficient compilation, as well as custom TypeScript Plugin and type
checker.  
API Reference| Updates to the API design throughout Next.js. Please refer to
the API Reference Section for new APIs.  
  
The sections and pages of the docs are organized sequentially, from basic to
advanced, so you can follow them step-by-step when building your Next.js
application. However, you can read them in any order or skip to the pages that
apply to your use case.

At the top of the sidebar, you'll notice a dropdown menu that allows you to
switch between the **App Router** the **Pages Router** features. Since there
are features that are unique to each directory, it's important to keep track
of which tab is selected.

On the right side of the page, you'll see a table of contents that makes it
easier to navigate between sections of a page. The breadcrumbs at the top of
the page will also indicate whether you're viewing App Router docs or Pages
Router docs.

To get started, checkout the Installation. If you're new to React or Server
Components, we recommend reading the React Essentials page.

Although our docs are designed to be beginner-friendly, we need to establish a
baseline so that the docs can stay focused on Next.js functionality. We'll
make sure to provide links to relevant documentation whenever we introduce a
new concept.

To get the most out of our docs, it's recommended that you have a basic
understanding of HTML, CSS, and React. If you need to brush up on your React
skills, check out these resources:

For optimal accessibility when using a screen reader while reading the docs,
we recommend using Firefox and NVDA, or Safari and VoiceOver.

If you have questions about anything related to Next.js, you're always welcome
to ask our community on GitHub Discussions, Discord, Twitter, and Reddit.





# Installation

System Requirements:

  * Node.js 16.8 or later.
  * macOS, Windows (including WSL), and Linux are supported.

We recommend creating a new Next.js app using `create-next-app`, which sets up
everything automatically for you. To create a project, run:

    
    
    npx create-next-app@latest

On installation, you'll see the following prompts:

    
    
    What is your project named? my-app
    Would you like to use TypeScript with this project? No / Yes
    Would you like to use ESLint with this project? No / Yes
    Would you like to use Tailwind CSS with this project? No / Yes
    Would you like to use `src/` directory with this project? No / Yes
    Use App Router (recommended)? No / Yes
    Would you like to customize the default import alias? No / Yes

Next.js now ships with TypeScript, ESLint, and Tailwind CSS configuration by
default. You can also choose to use the `src` directory for your application
code.

After the prompts, `create-next-app` will create a folder with your project
name and install the required dependencies.

> **Note:** While you can use the Pages Router in your new project. We
> recommend starting new applications with the App Router to leverage React's
> latest features.

To manually create a new Next.js app, install the required packages:

    
    
    npm install next@latest react@latest react-dom@latest

Open `package.json` and add the following `scripts`:

    
    
    {
      "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "next lint"
      }
    }

These scripts refer to the different stages of developing an application:

  * `dev`: runs `next dev` to start Next.js in development mode.
  * `build`: runs `next build` to build the application for production usage.
  * `start`: runs `next start` to start a Next.js production server.
  * `lint`: runs `next lint` to set up Next.js' built-in ESLint configuration.

Next, create an `app` folder and add a `layout.tsx` and `page.tsx` file. These
will be rendered when the user visits the root of your application.

![App Folder Structure](/_next/image?url=%2Fdocs%2Flight%2Fapp-getting-
started.png&w=3840&q=75)![App Folder
Structure](/_next/image?url=%2Fdocs%2Fdark%2Fapp-getting-
started.png&w=3840&q=75)

Create a root layout inside `app/layout.tsx` with the required `<html>` and
`<body>` tags:

    
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Finally, create a home page `app/page.tsx` with some initial content:

    
    
    export default function Page() {
      return <h1>Hello, Next.js!</h1>;
    }

> **Good to know** : If you forget to create `layout.tsx`, Next.js will
> automatically create this file for you when running the development server
> with `next dev`.

You can optionally create a `public` folder to store static assets such as
images, fonts, etc. Files inside `public` directory can then be referenced by
your code starting from the base URL (`/`).

  1. Run `npm run dev` to start the development server.
  2. Visit `http://localhost:3000` to view your application.
  3. Edit `app/layout.tsx` or `app/page.tsx` and save to see the updated result in your browser.





Using App Router

Features available in /app





# React Essentials

To build applications with Next.js, it helps to be familiar with React's newer
features such as Server Components. This page will go through the differences
between Server and Client Components, when to use them, and recommended
patterns.

If you're new to React, we also recommend referring to the React Docs. Here
are some great resources for learning:

Server and Client Components allow developers to build applications that span
the server and client, combining the rich interactivity of client-side apps
with the improved performance of traditional server rendering.

Similar to how React changed the way we think about building UIs, React Server
Components introduce a new mental model for building hybrid applications that
leverage the server and the client.

Instead of React rendering your whole application client-side (such as in the
case of Single-Page Applications), React now gives you the flexibility to
choose where to render your components based on their purpose.

For example, consider a page in your application:

![Thinking in Server Components](/_next/image?url=%2Fdocs%2Flight%2Fthinking-
in-server-components.png&w=3840&q=75)![Thinking in Server
Components](/_next/image?url=%2Fdocs%2Fdark%2Fthinking-in-server-
components.png&w=3840&q=75)

If we were to split the page into smaller components, you'll notice that the
majority of components are non-interactive and can be rendered on the server
as Server Components. For smaller pieces of interactive UI, we can _sprinkle
in_ Client Components. This aligns with Next.js server-first approach.

So, you may be thinking, why Server Components? What are the advantages of
using them over Client Components?

Server Components allow developers to better leverage server infrastructure.
For example, you can move data fetching to the server, closer to your
database, and keep large dependencies that previously would impact the client
JavaScript bundle size on the server, leading to improved performance. Server
Components make writing a React application feel similar to PHP or Ruby on
Rails, but with the power and flexibility of React and the components model
for templating UI.

With Server Components, the initial page load is faster, and the client-side
JavaScript bundle size is reduced. The base client-side runtime is
**cacheable** and **predictable** in size, and does _not_ increase as your
application grows. Additional JavaScript is _only added_ as client-side
interactivity is used in your application through Client Components.

When a route is loaded with Next.js, the initial HTML is rendered on the
server. This HTML is then **progressively enhanced** in the browser, allowing
the client to take over the application and add interactivity, by
asynchronously loading the Next.js and React client-side runtime.

To make the transition to Server Components easier, all components inside the
App Router are Server Components by default, including special files and
colocated components. This allows you to automatically adopt them with no
extra work, and achieve great performance out of the box. You can also
optionally opt-in to Client Components using the 'use client' directive.

Client Components enable you to add client-side interactivity to your
application. In Next.js, they are pre-rendered on the server and hydrated on
the client. You can think of Client Components as how components in the Pages
Router have always worked.

The `"use client"` directive is a convention to declare a boundary between a
Server and Client Component module graph.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function Counter() {
      const [count, setCount] = useState(0);
     
      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>Click me</button>
        </div>
      );
    }

![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Flight%2Fuse-client-
directive.png&w=3840&q=75)![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Fdark%2Fuse-client-
directive.png&w=3840&q=75)

`"use client"` _sits_ between server-only and client code. It's placed at the
top of a file, above imports, to define the _cut-off_ point where it crosses
the boundary from the server-only to the client part. Once `"use client"` is
defined in a file, all other modules imported into it, including child
components, are considered part of the client bundle.

Since Server Components are the default, all components are part of the Server
Component module graph unless defined or imported in a module that starts with
the `"use client"` directive.

> **Good to know:**
>
>   * Components in the Server Component module graph are guaranteed to be
> only rendered on the server.
>   * Components in the Client Component module graph are primarily rendered
> on the client, but with Next.js, they can also be pre-rendered on the server
> and hydrated on the client.
>   * The `"use client"` directive must be defined at the **top of a file**
> before any imports.
>   * `"use client"` does **not** need to be defined in every file. The Client
> module boundary only needs to be defined once, at the "entry point", for all
> modules imported into it to be considered a Client Component.
>

To simplify the decision between Server and Client Components, we recommend
using Server Components (default in the `app` directory) until you have a use
case for a Client Component.

This table summarizes the different use cases for Server and Client
Components:

What do you need to do?| Server Component| Client Component  
---|---|---  
Fetch data.| |  
Access backend resources (directly)| |  
Keep sensitive information on the server (access tokens, API keys, etc)| |  
Keep large dependencies on the server / Reduce client-side JavaScript| |  
Add interactivity and event listeners (`onClick()`, `onChange()`, etc)| |  
Use State and Lifecycle Effects (`useState()`, `useReducer()`, `useEffect()`,
etc)| |  
Use browser-only APIs| |  
Use custom hooks that depend on state, effects, or browser-only APIs| |  
Use React Class components| |  
  
To improve the performance of your application, we recommend moving Client
Components to the leaves of your component tree where possible.

For example, you may have a Layout that has static elements (e.g. logo, links,
etc) and an interactive search bar that uses state.

Instead of making the whole layout a Client Component, move the interactive
logic to a Client Component (e.g. `<SearchBar />`) and keep your layout as a
Server Component. This means you don't have to send all the component
Javascript of the layout to the client.

    
    
    // SearchBar is a Client Component
    import SearchBar from './searchbar';
    // Logo is a Server Component
    import Logo from './logo';
     
    // Layout is a Server Component by default
    export default function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <>
          <nav>
            <Logo />
            <SearchBar />
          </nav>
          <main>{children}</main>
        </>
      );
    }

Server and Client Components can be combined in the same component tree.

Behind the scenes, React handles rendering as follows:

  * On the server, React renders **all** Server Components **before** sending the result to the client. 
    * This includes Server Components nested inside Client Components.
    * Client Components encountered during this stage are skipped.
  * On the client, React renders Client Components and _slots in_ the rendered result of Server Components, merging the work done on the server and client. 
    * If any Server Components are nested inside a Client Component, their rendered content will be placed correctly within the Client Component.

> **Good to know:** In Next.js, during the initial page load, both the
> rendered result of Server Components from the above step and Client
> Components are pre-rendered on the server as HTML to produce a faster
> initial page load.

Given the rendering flow outlined above, there is a restriction around
importing a Server Component into a Client Component, as this approach would
require an additional server round trip.

The following pattern is not supported. You cannot import a Server Component
into a Client Component:

    
    
    'use client';
     
    // This pattern will **not** work!
    // You cannot import a Server Component into a Client Component.
    import ExampleServerComponent from './example-server-component';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          <ExampleServerComponent />
        </>
      );
    }

Instead, when designing Client Components you can use React props to mark
_"holes"_ for Server Components.

The Server Component will be rendered on the server, and when the Client
Component is rendered on the client, the _"hole"_ will be filled in with the
rendered result of the Server Component.

A common pattern is to use the React `children` prop to create the _"hole"_.
We can refactor `<ExampleClientComponent>` to accept a generic `children` prop
and move the import and explicit nesting of `<ExampleClientComponent>` up to a
parent component.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          {children}
        </>
      );
    }

Now, `<ExampleClientComponent>` has no knowledge of what `children` is.
Infact, from its perspective it doesn't even know that `children` will
eventually be filled in by the result of a Server Component.

The only responsibility `ExampleClientComponent` has is to decide where
whatever `children` will eventually be should be placed.

In a parent Server Component, you can import both the
`<ExampleClientComponent>` and `<ExampleServerComponent>` and pass
`<ExampleServerComponent>` as a child of `<ExampleClientComponent>`:

    
    
    // This pattern works:
    // You can pass a Server Component as a child or prop of a
    // Client Component.
    import ExampleClientComponent from './example-client-component';
    import ExampleServerComponent from './example-server-component';
     
    // Pages in Next.js are Server Components by default
    export default function Page() {
      return (
        <ExampleClientComponent>
          <ExampleServerComponent />
        </ExampleClientComponent>
      );
    }

With this approach, the rendering of `<ExampleClientComponent>` and
`<ExampleServerComponent>` are decoupled and can be rendered independently -
aligning with Server Components, which are rendered on the server before
Client Components.

> **Good to know**
>
>   * This pattern is **already applied** in layouts and pages with the
> `children` prop so you don't have to create an additional wrapper component.
>   * Passing React components (JSX) to other components is not a new concept
> and has always been part of the React composition model.
>   * This composition strategy works across Server and Client Components
> because the component that receives the prop has no knowledge of **what**
> the prop is. It is only responsible for where the thing that it is passed
> should be placed.
>     * This allows the passed prop to be rendered independently, in this
> case, on the server, well before the Client Component is rendered on the
> client.
>     * The very same strategy of "lifting content up" has been used to avoid
> state changes in a parent component re-rendering an imported nested child
> component.
>   * You're not limited to the `children` prop. You can use any prop to pass
> JSX.
>

Props passed from the Server to Client Components need to be serializable.
This means that values such as functions, Dates, etc, cannot be passed
directly to Client Components.

> **Where is the Network Boundary?**
>
> In the App Router, the network boundary is between Server Components and
> Client Components. This is different from the Pages where the boundary is
> between `getStaticProps`/`getServerSideProps` and Page Components. Data
> fetched inside Server Components do not need to be serialized as it doesn't
> cross the network boundary unless it is passed to a Client Component. Learn
> more about data fetching with Server Components.

Since JavaScript modules can be shared between both Server and Client
Components, it's possible for code that was only ever intended to be run on
the server to sneak its way into the client.

For example, take the following data-fetching function:

    
    
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

At first glance, it appears that `getData` works on both the server and the
client. But because the environment variable `API_KEY` is not prefixed with
`NEXT_PUBLIC`, it's a private variable that can only be accessed on the
server. Next.js replaces private environment variables with the empty string
in client code to prevent leaking secure information.

As a result, even though `getData()` can be imported and executed on the
client, it won't work as expected. And while making the variable public would
make the function work on the client, it would leak sensitive information.

So, this function was written with the intention that it would only ever be
executed on the server.

To prevent this sort of unintended client usage of server code, we can use the
`server-only` package to give other developers a build-time error if they ever
accidentally import one of these modules into a Client Component.

To use `server-only`, first install the package:

Then import the package into any module that contains server-only code:

    
    
    import 'server-only';
     
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

Now, any Client Component that imports `getData()` will receive a build-time
error explaining that this module can only be used on the server.

The corresponding package `client-only` can be used to mark modules that
contain client-only code – for example, code that accesses the `window`
object.

Although it's possible to fetch data in Client Components, we recommend
fetching data in Server Components unless you have a specific reason for
fetching data on the client. Moving data fetching to the server leads to
better performance and user experience.

Learn more about data fetching.

Since Server Components are new, third-party packages in the ecosystem are
just beginning to add the `"use client"` directive to components that use
client-only features like `useState`, `useEffect`, and `createContext`.

Today, many components from `npm` packages that use client-only features do
not yet have the directive. These third-party components will work as expected
within your own Client Components since they have the `"use client"`
directive, but they won't work within Server Components.

For example, let's say you've installed the hypothetical `acme-carousel`
package which has an `<Carousel />` component. This component uses `useState`,
but it doesn't yet have the `"use client"` directive.

If you use `<Carousel />` within a Client Component, it will work as expected:

    
    
    'use client';
     
    import { useState } from 'react';
    import { Carousel } from 'acme-carousel';
     
    export default function Gallery() {
      let [isOpen, setIsOpen] = useState(false);
     
      return (
        <div>
          <button onClick={() => setIsOpen(true)}>View pictures</button>
     
          {/* Works, since Carousel is used within a Client Component */}
          {isOpen && <Carousel />}
        </div>
      );
    }

However, if you try to use it directly within a Server Component, you'll see
an error:

    
    
    import { Carousel } from 'acme-carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/* Error: `useState` can not be used within Server Components */}
          <Carousel />
        </div>
      );
    }

This is because Next.js doesn't know `<Carousel />` is using client-only
features.

To fix this, you can wrap third-party components that rely on client-only
features in your own Client Components:

    
    
    'use client';
     
    import { Carousel } from 'acme-carousel';
     
    export default Carousel;

Now, you can use `<Carousel />` directly within a Server Component:

    
    
    import Carousel from './carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/*  Works, since Carousel is a Client Component */}
          <Carousel />
        </div>
      );
    }

We don't expect you to need to wrap most third-party components since it's
likely you'll be using them within Client Components. However, one exception
is provider components, since they rely on React state and context, and are
typically needed at the root of an application. Learn more about third-party
context providers below.

  * In a similar fashion, library authors creating packages to be consumed by other developers can use the `"use client"` directive to mark client entry points of their package. This allows users of the package to import package components directly into their Server Components without having to create a wrapping boundary.
  * You can optimize your package by using 'use client' deeper in the tree, allowing the imported modules to be part of the Server Component module graph.
  * It's worth noting some bundlers might strip out `"use client"` directives. You can find an example of how to configure esbuild to include the `"use client"` directive in the React Wrap Balancer and Vercel Analytics repositories.

Most React applications rely on context to share data between components,
either directly via `createContext`, or indirectly via provider components
imported from third-party libraries.

In Next.js 13, context is fully supported within Client Components, but it
**cannot** be created or consumed directly within Server Components. This is
because Server Components have no React state (since they're not interactive),
and context is primarily used for rerendering interactive components deep in
the tree after some React state has been updated.

We'll discuss alternatives for sharing data between Server Components, but
first, let's take a look at how to use context within Client Components.

All of the context APIs are fully supported within Client Components:

    
    
    'use client';
     
    import { createContext, useContext, useState } from 'react';
     
    const SidebarContext = createContext();
     
    export function Sidebar() {
      const [isOpen, setIsOpen] = useState();
     
      return (
        <SidebarContext.Provider value={{ isOpen }}>
          <SidebarNav />
        </SidebarContext.Provider>
      );
    }
     
    function SidebarNav() {
      let { isOpen } = useContext(SidebarContext);
     
      return (
        <div>
          <p>Home</p>
     
          {isOpen && <Subnav />}
        </div>
      );
    }

However, context providers are typically rendered near the root of an
application to share global concerns, like the current theme. Because context
is not supported in Server Components, trying to create a context at the root
of your application will cause an error:

    
    
    import { createContext } from 'react';
     
    //  createContext is not supported in Server Components
    export const ThemeContext = createContext({});
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
          </body>
        </html>
      );
    }

To fix this, create your context and render its provider inside of a Client
Component:

    
    
    'use client';
     
    import { createContext } from 'react';
     
    export const ThemeContext = createContext({});
     
    export default function ThemeProvider({ children }) {
      return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>;
    }

Your Server Component will now be able to directly render your provider since
it's been marked as a Client Component:

    
    
    import ThemeProvider from './theme-provider';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html>
          <body>
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

With the provider rendered at the root, all other Client Components throughout
your app will be able to consume this context.

> Note: You should render providers as deep as possible in the tree – notice
> how `ThemeProvider` only wraps `{children}` instead of the entire `<html>`
> document. This makes it easier for Next.js to optimize the static parts of
> your Server Components.

Third-party npm packages often include Providers that need to be rendered near
the root of your application. If these providers include the `"use client"`
directive, they can be rendered directly inside of your Server Components.
However, since Server Components are so new, many third-party providers won't
have added the directive yet.

If you try to render a third-party provider that doesn't have `"use client"`,
it will cause an error:

    
    
    import { ThemeProvider } from 'acme-theme';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            {/*  Error: `createContext` can't be used in Server Components */}
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

To fix this, wrap third-party providers in your own Client Component:

    
    
    'use client';
     
    import { ThemeProvider } from 'acme-theme';
    import { AuthProvider } from 'acme-auth';
     
    export function Providers({ children }) {
      return (
        <ThemeProvider>
          <AuthProvider>{children}</AuthProvider>
        </ThemeProvider>
      );
    }

Now, you can import and render `<Providers />` directly within your root
layout.

    
    
    import { Providers } from './providers';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }

With the providers rendered at the root, all the components and hooks from
these libraries will work as expected within your own Client Components.

Once a third-party library has added `"use client"` to its client code, you'll
be able to remove the wrapper Client Component.

Since Server Components are not interactive and therefore do not read from
React state, you don't need React context to share data. Instead, you can use
native JavaScript patterns for common data that multiple Server Components
need to access. For example, a module can be used to share a database
connection across multiple components:

    
    
    export const db = new DatabaseConnection();
    
    
    import { db } from '@utils/database';
     
    export async function UsersLayout() {
      let users = await db.query();
      // ...
    }
    
    
    import { db } from '@utils/database';
     
    export async function DashboardPage() {
      let user = await db.query();
      // ...
    }

In the above example, both the layout and page need to make database queries.
Each of these components shares access to the database by importing the
`@utils/database` module. This JavaScript pattern is called global singletons.

When fetching data, you may want to share the result of a `fetch` between a
`page` or `layout` and some of its children components. This is an unnecessary
coupling between the components and can lead to passing `props` back and forth
between components.

Instead, we recommend colocating data fetching alongside the component that
consumes the data. `fetch` requests are automatically deduped in Server
Components, so each route segment can request exactly the data it needs
without worrying about duplicate requests. Next.js will read the same value
from the `fetch` cache.





# Routing Fundamentals

The skeleton of every application is routing. This page will introduce you to
the **fundamental concepts** of routing for the web and how to handle routing
in Next.js.

First, you will see these terms being used throughout the documentation.
Here's a quick reference:

![Terminology for Component
Tree](/_next/image?url=%2Fdocs%2Flight%2Fterminology-component-
tree.png&w=3840&q=75)![Terminology for Component
Tree](/_next/image?url=%2Fdocs%2Fdark%2Fterminology-component-
tree.png&w=3840&q=75)

  * **Tree:** A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.
  * **Subtree:** Part of a tree, starting at a new root (first) and ending at the leaves (last).
  * **Root** : The first node in a tree or subtree, such as a root layout.
  * **Leaf:** Nodes in a subtree that have no children, such as the last segment in a URL path.

![Terminology for URL Anatomy](/_next/image?url=%2Fdocs%2Flight%2Fterminology-
url-anatomy.png&w=3840&q=75)![Terminology for URL
Anatomy](/_next/image?url=%2Fdocs%2Fdark%2Fterminology-url-
anatomy.png&w=3840&q=75)

  * **URL Segment:** Part of the URL path delimited by slashes.
  * **URL Path:** Part of the URL that comes after the domain (composed of segments).

In version 13, Next.js introduced a new **App Router** built on React Server
Components, which supports shared layouts, nested routing, loading states,
error handling, and more.

The App Router works in a new directory named `app`. The `app` directory works
alongside the `pages` directory to allow for incremental adoption. This allows
you to opt some routes of your application into the new behavior while keeping
other routes in the `pages` directory for previous behavior. If your
application uses the `pages` directory, please also see the Pages Router
documentation.

> **Good to know:** The App Router takes priority over the Pages Router.
> Routes across directories should not resolve to the same URL path and will
> cause a build-time error to prevent a conflict.

![Next.js App Directory](/_next/image?url=%2Fdocs%2Flight%2Fnext-router-
directories.png&w=3840&q=75)![Next.js App
Directory](/_next/image?url=%2Fdocs%2Fdark%2Fnext-router-
directories.png&w=3840&q=75)

By default, components inside `app` are React Server Components. This is a
performance optimization and allows you to easily adopt them, and you can also
use Client Components.

> **Recommendation:** Check out the Server and Client Components page if
> you're new to Server Components.

Next.js uses a file-system based router where:

  * **Folders** are used to define routes. A route is a single path of nested folders, following the file-system hierarchy from the **root folder** down to a final **leaf folder** that includes a `page.js` file. See Defining Routes.
  * **Files** are used to create UI that is shown for a route segment. See special files.

Each folder in a route represents a **route segment**. Each route segment is
mapped to a corresponding **segment** in a **URL path**.

![How Route Segments Map to URL
Segments](/_next/image?url=%2Fdocs%2Flight%2Froute-segments-to-path-
segments.png&w=3840&q=75)![How Route Segments Map to URL
Segments](/_next/image?url=%2Fdocs%2Fdark%2Froute-segments-to-path-
segments.png&w=3840&q=75)

To create a nested route, you can nest folders inside each other. For example,
you can add a new `/dashboard/settings` route by nesting two new folders in
the `app` directory.

The `/dashboard/settings` route is composed of three segments:

  * `/` (Root segment)
  * `dashboard` (Segment)
  * `settings` (Leaf segment)

Next.js provides a set of special files to create UI with specific behavior in
nested routes:

> **Good to know:** `.js`, `.jsx`, or `.tsx` file extensions can be used for
> special files.

The React components defined in special files of a route segment are rendered
in a specific hierarchy:

  * `layout.js`
  * `template.js`
  * `error.js` (React error boundary)
  * `loading.js` (React suspense boundary)
  * `not-found.js` (React error boundary)
  * `page.js` or nested `layout.js`

![Component Hierarchy for File
Conventions](/_next/image?url=%2Fdocs%2Flight%2Ffile-conventions-component-
hierarchy.png&w=3840&q=75)![Component Hierarchy for File
Conventions](/_next/image?url=%2Fdocs%2Fdark%2Ffile-conventions-component-
hierarchy.png&w=3840&q=75)

In a nested route, the components of a segment will be nested **inside** the
components of its parent segment.

![Nested File Conventions Component
Hierarchy](/_next/image?url=%2Fdocs%2Flight%2Fnested-file-conventions-
component-hierarchy.png&w=3840&q=75)![Nested File Conventions Component
Hierarchy](/_next/image?url=%2Fdocs%2Fdark%2Fnested-file-conventions-
component-hierarchy.png&w=3840&q=75)

In addition to special files, you have the option to colocate your own files
(e.g. components, styles, tests etc) inside folders in the `app` directory.

This is because while folders define routes, only the contents returned by
`page.js` or `route.js` are publically addressable.

![An example folder structure with colocated
files](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-
colocation.png&w=3840&q=75)![An example folder structure with colocated
files](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-
colocation.png&w=3840&q=75)

Learn more about Project Organization and Colocation.

Unlike the `pages` directory which uses client-side routing, the App Router
uses **server-centric routing** to align with Server Components and data
fetching on the server. With server-centric routing, the client does not have
to download a route map and the same request for Server Components can be used
to look up routes. This optimization is useful for all applications, but has a
larger impact on applications with many routes.

Although routing is server-centric, the router uses **client-side navigation**
with the Link Component \- resembling the behavior of a Single-Page
Application. This means when a user navigates to a new route, the browser will
not reload the page. Instead, the URL will be updated and Next.js will only
render the segments that change.

Additionally, as users navigate around the app, the router will store the
result of the React Server Component payload in an **in-memory client-side
cache**. The cache is split by route segments which allows invalidation at any
level and ensures consistency across React's concurrent renders. This means
that for certain cases, the cache of a previously fetched segment can be re-
used, further improving performance.

Learn more about Linking and Navigating.

When navigating between sibling routes (e.g. `/dashboard/settings` and
`/dashboard/analytics` below), Next.js will only fetch and render the layouts
and pages in routes that change. It will **not** re-fetch or re-render
anything above the segments in the subtree. This means that in routes that
share a layout, the layout will be preserved when a user navigates between
sibling pages.

![How partial rendering works](/_next/image?url=%2Fdocs%2Flight%2Fpartial-
rendering.png&w=3840&q=75)![How partial rendering
works](/_next/image?url=%2Fdocs%2Fdark%2Fpartial-rendering.png&w=3840&q=75)

Without partial rendering, each navigation would cause the full page to re-
render on the server. Rendering only the segment that’s updating reduces the
amount of data transferred and execution time, leading to improved
performance.

The App Router also provides a set conventions to help you implement more
advanced routing patterns. These include:

  * Parallel Routes: Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You can use them for split views that have their own sub-navigation. E.g. Dashboards.
  * Intercepting Routes: Allow you to intercept a route and show it in the context of another route. You can use these when keeping the context for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed.

These patterns allow you to build richer and more complex UIs, democratizing
features that were historically complex for small teams and individual
developers to implement.

Now that you understand the fundamentals of routing in Next.js, follow the
links below to create your first routes:





# Defining Routes

> We recommend reading the Routing Fundamentals page before continuing.

This page will guide you through how to define and organize routes in your
Next.js application.

Next.js uses a file-system based router where **folders** are used to define
routes.

Each folder represents a **route** segment that maps to a **URL** segment. To
create a nested route, you can nest folders inside each other.

![Route segments to path segments](/_next/image?url=%2Fdocs%2Flight%2Froute-
segments-to-path-segments.png&w=3840&q=75)![Route segments to path
segments](/_next/image?url=%2Fdocs%2Fdark%2Froute-segments-to-path-
segments.png&w=3840&q=75)

A special `page.js` file is used to make route segments publicly accessible.

![Defining Routes](/_next/image?url=%2Fdocs%2Flight%2Fdefining-
routes.png&w=3840&q=75)![Defining
Routes](/_next/image?url=%2Fdocs%2Fdark%2Fdefining-routes.png&w=3840&q=75)

In this example, the `/dashboard/analytics` URL path is _not_ publicly
accessible because it does not have a corresponding `page.js` file. This
folder could be used to store components, stylesheets, images, or other
colocated files.

> **Good to know:** `.js`, `.jsx`, or `.tsx` file extensions can be used for
> special files.

Special file conventions are used to create UI for each route segment. The
most common are pages to show UI unique to a route, and layouts to show UI
that is shared across multiple routes.

For example, to create your first page, add a `page.js` file inside the `app`
directory and export a React component:

    
    
    export default function Page() {
      return <h1>Hello, Next.js!</h1>;
    }





# Pages and Layouts

> We recommend reading the Routing Fundamentals and Defining Routes pages
> before continuing.

The App Router inside Next.js 13 introduced new file conventions to easily
create pages, shared layouts, and templates. This page will guide you through
how to use these special files in your Next.js application.

A page is UI that is **unique** to a route. You can define pages by exporting
a component from a `page.js` file. Use nested folders to define a route and a
`page.js` file to make the route publicly accessible.

Create your first page by adding a `page.js` file inside the `app` directory:

![page.js special file](/_next/image?url=%2Fdocs%2Flight%2Fpage-special-
file.png&w=3840&q=75)![page.js special
file](/_next/image?url=%2Fdocs%2Fdark%2Fpage-special-file.png&w=3840&q=75)

    
    
    // `app/page.tsx` is the UI for the `/` URL
    export default function Page() {
      return <h1>Hello, Home page!</h1>;
    }
    
    
    // `app/dashboard/page.tsx` is the UI for the `/dashboard` URL
    export default function Page() {
      return <h1>Hello, Dashboard Page!</h1>;
    }

> **Good to know:**
>
>   * A page is always the leaf of the route subtree.
>   * `.js`, `.jsx`, or `.tsx` file extensions can be used for Pages.
>   * A `page.js` file is required to make a route segment publicly
> accessible.
>   * Pages are Server Components by default but can be set to a Client
> Component.
>   * Pages can fetch data. View the Data Fetching section for more
> information.
>

A layout is UI that is **shared** between multiple pages. On navigation,
layouts preserve state, remain interactive, and do not re-render. Layouts can
also be nested.

You can define a layout by `default` exporting a React component from a
`layout.js` file. The component should accept a `children` prop that will be
populated with a child layout (if it exists) or a child page during rendering.

![layout.js special file](/_next/image?url=%2Fdocs%2Flight%2Flayout-special-
file.png&w=3840&q=75)![layout.js special
file](/_next/image?url=%2Fdocs%2Fdark%2Flayout-special-file.png&w=3840&q=75)

    
    
    export default function DashboardLayout({
      children, // will be a page or nested layout
    }: {
      children: React.ReactNode;
    }) {
      return (
        <section>
          {/* Include shared UI here e.g. a header or sidebar */}
          <nav></nav>
     
          {children}
        </section>
      );
    }

> **Good to know:**
>
>   * The top-most layout is called the Root Layout. This **required** layout
> is shared across all pages in an application. Root layouts must contain
> `html` and `body` tags.
>   * Any route segment can optionally define its own Layout. These layouts
> will be shared across all pages in that segment.
>   * Layouts in a route are **nested** by default. Each parent layout wraps
> child layouts below it using the React `children` prop.
>   * You can use Route Groups to opt specific route segments in and out of
> shared layouts.
>   * Layouts are Server Components by default but can be set to a Client
> Component.
>   * Layouts can fetch data. View the Data Fetching section for more
> information.
>   * Passing data between a parent layout and its children is not possible.
> However, you can fetch the same data in a route more than once, and React
> will automatically dedupe the requests without affecting performance.
>   * Layouts do not have access to the current route segment(s). To access
> route segments, you can use `useSelectedLayoutSegment` or
> `useSelectedLayoutSegments` in a Client Component.
>   * `.js`, `.jsx`, or `.tsx` file extensions can be used for Layouts.
>   * A `layout.js` and `page.js` file can be defined in the same folder. The
> layout will wrap the page.
>

The root layout is defined at the top level of the `app` directory and applies
to all routes. This layout enables you to modify the initial HTML returned
from the server.

    
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

> **Good to know:**
>
>   * The `app` directory **must** include a root layout.
>   * The root layout must define `<html>` and `<body>` tags since Next.js
> does not automatically create them.
>   * You can use the built-in SEO support to manage `<head>` HTML elements,
> for example, the `<title>` element.
>   * You can use route groups to create multiple root layouts. See an example
> here.
>   * The root layout is a Server Component by default and **can not** be set
> to a Client Component.
>

> **Migrating from the`pages` directory:** The root layout replaces the
> `_app.js` and `_document.js` files. View the migration guide.

Layouts defined inside a folder (e.g. `app/dashboard/layout.js`) apply to
specific route segments (e.g. `acme.com/dashboard`) and render when those
segments are active. By default, layouts in the file hierarchy are **nested**
, which means they wrap child layouts via their `children` prop.

![Nested Layout](/_next/image?url=%2Fdocs%2Flight%2Fnested-
layout.png&w=3840&q=75)![Nested
Layout](/_next/image?url=%2Fdocs%2Fdark%2Fnested-layout.png&w=3840&q=75)

    
    
    export default function DashboardLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return <section>{children}</section>;
    }

If you were to combine the two layouts above, the root layout
(`app/layout.js`) would wrap the dashboard layout (`app/dashboard/layout.js`),
which would wrap route segments inside `app/dashboard/*`.

The two layouts would be nested as such:

![Nested Layouts](/_next/image?url=%2Fdocs%2Flight%2Fnested-layouts-
ui.png&w=3840&q=75)![Nested Layouts](/_next/image?url=%2Fdocs%2Fdark%2Fnested-
layouts-ui.png&w=3840&q=75)

You can use Route Groups to opt specific route segments in and out of shared
layouts.

Templates are similar to layouts in that they wrap each child layout or page.
Unlike layouts that persist across routes and maintain state, templates create
a new instance for each of their children on navigation. This means that when
a user navigates between routes that share a template, a new instance of the
component is mounted, DOM elements are recreated, state is **not** preserved,
and effects are re-synchronized.

There may be cases where you need those specific behaviors, and templates
would be a more suitable option than layouts. For example:

  * Enter/exit animations using CSS or animation libraries.
  * Features that rely on `useEffect` (e.g logging page views) and `useState` (e.g a per-page feedback form).
  * To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time the Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation.

> **Recommendation:** We recommend using Layouts unless you have a specific
> reason to use Template.

A template can be defined by exporting a default React component from a
`template.js` file. The component should accept a `children` prop which will
be nested segments.

![template.js special file](/_next/image?url=%2Fdocs%2Flight%2Ftemplate-
special-file.png&w=3840&q=75)![template.js special
file](/_next/image?url=%2Fdocs%2Fdark%2Ftemplate-special-file.png&w=3840&q=75)

    
    
    export default function Template({ children }: { children: React.ReactNode }) {
      return <div>{children}</div>;
    }

The rendered output of a route segment with a layout and a template will be as
such:

    
    
    <Layout>
      {/* Note that the template is given a unique key. */}
      <Template key={routeParam}>{children}</Template>
    </Layout>

In the `app` directory, you can modify the `<head>` HTML elements such as
`title` and `meta` using the built-in SEO support.

Metadata can be defined by exporting a `metadata` object or `generateMetadata`
function in a `layout.js` or `page.js` file.

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'Next.js',
    };
     
    export default function Page() {
      return '...';
    }

> **Good to know:** You should **not** manually add `<head>` tags such as
> `<title>` and `<meta>` to root layouts. Instead, you should use the Metadata
> API which automatically handles advanced requirements such as streaming and
> de-duplicating `<head>` elements.

Learn more about available metadata options in the API reference.



# Linking and Navigating

The Next.js router uses server-centric routing with client-side navigation. It
supports instant loading states and concurrent rendering. This means
navigation maintains client-side state, avoids expensive re-renders, is
interruptible, and doesn't cause race conditions.

There are two ways to navigate between routes:

This page will go through how to use `<Link>`, `useRouter()`, and dive deeper
into how navigation works.

`<Link>` is a React component that extends the HTML `<a>` element to provide
prefetching and client-side navigation between routes. It is the primary way
to navigate between routes in Next.js.

To use `<Link>`, import it from `next/link`, and pass a `href` prop to the
component:

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return <Link href="/dashboard">Dashboard</Link>;
    }

There are optional props you can pass to `<Link>`. See the API reference for
more information.

When linking to dynamic segments, you can use template literals and
interpolation to generate a list of links. For example, to generate a list of
blog posts:

    
    
    import Link from 'next/link';
     
    export default function PostList({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/blog/${post.slug}`}>{post.title}</Link>
            </li>
          ))}
        </ul>
      );
    }

You can use `usePathname()` to determine if a link is active. For example, to
add a class to the active link, you can check if the current `pathname`
matches the `href` of the link:

    
    
    'use client';
     
    import { usePathname } from 'next/navigation';
    import { Link } from 'next/link';
     
    export function Navigation({ navLinks }) {
      const pathname = usePathname();
     
      return (
        <>
          {navLinks.map((link) => {
            const isActive = pathname.startsWith(link.href);
     
            return (
              <Link
                className={isActive ? 'text-blue' : 'text-black'}
                href={link.href}
                key={link.name}
              >
                {link.name}
              </Link>
            );
          })}
        </>
      );
    }

The default behavior of `<Link>` is to scroll to the top of the route segment
that has changed. When there is an `id` defined in `href`, it will scroll to
the specific `id`, similarly to a normal `<a>` tag.

To prevent scrolling to the top of the route segment, set `scroll={false}` and
pass the add a hashed `id` to `href`:

    
    
    <Link href="/#hashid" scroll={false}>
      Scroll to specific id.
    </Link>

The `useRouter` hook allows you to programmatically change routes inside
Client Components.

To use `useRouter`, import it from `next/navigation`, and call the hook inside
your Client Component:

    
    
    'use client';
     
    import { useRouter } from 'next/navigation';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.push('/dashboard')}>
          Dashboard
        </button>
      );
    }

The `useRouter` provides methods such as `push()`, `refresh()`, and more. See
the API reference for more information.

> **Recommendation:** Use the `<Link>` component to navigate between routes
> unless you have a specific requirement for using `useRouter`.

  * A route transition is initiated using `<Link>` or calling `router.push()`.
  * The router updates the URL in the browser's address bar.
  * The router avoids unnecessary work by re-using segments that haven't changed (e.g. shared layouts) from the client-side cache. This is also referred to as partial rendering.
  * If the conditions of soft navigation are met, the router fetches the new segment from the cache rather than the server. If not, the router performs a hard navigation and fetches the Server Component payload from the server.
  * If created, loading UI is shown from the server while the payload is being fetched.
  * The router uses the cached or fresh payload to render the new segments on the client.

> **Good to know:** This client-side cache is different from the server-side
> Next.js HTTP cache.

The new router has an **in-memory client-side cache** that stores the
**rendered result** of Server Components (payload). The cache is split by
route segments which allows invalidation at any level and ensures consistency
across concurrent renders.

As users navigate around the app, the router will store the payload of
previously fetched segments **and** prefetched segments in the cache.

This means, for certain cases, the router can re-use the cache instead of
making a new request to the server. This improves performance by avoiding re-
fetching data and re-rendering components unnecessarily.

Server Actions can be used to revalidate data on-demand by path
(`revalidatePath`) or by cache tag (`revalidateTag`).

Prefetching is a way to preload a route in the background before it's visited.
The rendered result of prefetched routes is added to the router's client-side
cache. This makes navigating to a prefetched route near-instant.

By default, routes are prefetched as they become visible in the viewport when
using the `<Link>` component. This can happen when the page first loads or
through scrolling. Routes can also be programmatically prefetched using the
`prefetch` method of the `useRouter()` hook.

**Static and Dynamic Routes** :

  * If the route is static, all the Server Component payloads for the route segments will be prefetched.
  * If the route is dynamic, the payload from the first shared layout down until the first `loading.js` file is prefetched. This reduces the cost of prefetching the whole route dynamically and allows instant loading states for dynamic routes.

> **Good to know:**
>
>   * Prefetching is only enabled in production.
>   * Prefetching can be disabled by passing `prefetch={false}` to `<Link>`.
>

On navigation, the cache for changed segments is reused (if it exists), and no
new requests are made to the server for data.

On navigation, Next.js will use soft navigation if the route you are
navigating to has been **prefetched**, and either doesn't include dynamic
segments **or** has the same dynamic parameters as the current route.

For example, consider the following route that includes a dynamic `[team]`
segment: `/dashboard/[team]/*`. The cached segments below
`/dashboard/[team]/*` will only be invalidated when the `[team]` parameter
changes.

  * Navigating from `/dashboard/team-red/*` to `/dashboard/team-red/*` will be a soft navigation.
  * Navigating from `/dashboard/team-red/*` to `/dashboard/team-blue/*` will be a hard navigation.

On navigation, the cache is invalidated and the server refetches data and re-
renders the changed segments.

Back and forward navigation (popstate event) has a soft navigation behavior.
This means, the client-side cache is re-used and navigation is near-instant.

By default, Next.js will set focus and scroll into view the segment that's
changed on navigation.





# Route Groups

In the `app` directory, nested folders are normally mapped to URL paths.
However, you can mark a folder as a **Route Group** to prevent the folder from
being included in the route's URL path.

This allows you to organize your route segments and project files into logical
groups without affecting the URL path structure.

Route groups are useful for:

A route group can be created by wrapping a folder's name in parenthesis:
`(folderName)`

To organize routes without affecting the URL, create a group to keep related
routes together. The folders in parenthesis will be omitted from the URL (e.g.
`(marketing)` or `(shop)`).

![Organizing Routes with Route
Groups](/_next/image?url=%2Fdocs%2Flight%2Froute-group-
organisation.png&w=3840&q=75)![Organizing Routes with Route
Groups](/_next/image?url=%2Fdocs%2Fdark%2Froute-group-
organisation.png&w=3840&q=75)

Even though routes inside `(marketing)` and `(shop)` share the same URL
hierarchy, you can create a different layout for each group by adding a
`layout.js` file inside their folders.

![Route Groups with Multiple
Layouts](/_next/image?url=%2Fdocs%2Flight%2Froute-group-multiple-
layouts.png&w=3840&q=75)![Route Groups with Multiple
Layouts](/_next/image?url=%2Fdocs%2Fdark%2Froute-group-multiple-
layouts.png&w=3840&q=75)

To opt specific routes into a layout, create a new route group (e.g. `(shop)`)
and move the routes that share the same layout into the group (e.g. `account`
and `cart`). The routes outside of the group will not share the layout (e.g.
`checkout`).

![Route Groups with Opt-in Layouts](/_next/image?url=%2Fdocs%2Flight%2Froute-
group-opt-in-layouts.png&w=3840&q=75)![Route Groups with Opt-in
Layouts](/_next/image?url=%2Fdocs%2Fdark%2Froute-group-opt-in-
layouts.png&w=3840&q=75)

To create multiple root layouts, remove the top-level `layout.js` file, and
add a `layout.js` file inside each route groups. This is useful for
partitioning an application into sections that have a completely different UI
or experience. The `<html>` and `<body>` tags need to be added to each root
layout.

![Route Groups with Multiple Root
Layouts](/_next/image?url=%2Fdocs%2Flight%2Froute-group-multiple-root-
layouts.png&w=3840&q=75)![Route Groups with Multiple Root
Layouts](/_next/image?url=%2Fdocs%2Fdark%2Froute-group-multiple-root-
layouts.png&w=3840&q=75)

In the example above, both `(marketing)` and `(shop)` have their own root
layout.

* * *

> **Good to know:**
>
>   * The naming of route groups has no special significance other than for
> organization. They do not affect the URL path.
>   * Routes that include a route group **should not** resolve to the same URL
> path as other routes. For example, since route groups don't affect URL
> structure, `(marketing)/about/page.js` and `(shop)/about/page.js` would both
> resolve to `/about` and cause an error.
>   * If you use multiple root layouts without a top-level `layout.js` file,
> your home `page.js` file should be defined in one of the route groups, For
> example: `app/(marketing)/page.js`.
>   * Navigating **across multiple root layouts** will cause a **full page
> load** (as opposed to a client-side navigation). For example, navigating
> from `/cart` that uses `app/(shop)/layout.js` to `/blog` that uses
> `app/(marketing)/layout.js` will cause a full page load. This **only**
> applies to multiple root layouts.
>





# Dynamic Routes

When you don't know the exact segment names ahead of time and want to create
routes from dynamic data, you can use Dynamic Segments that are filled in at
request time or prerendered at build time.

A Dynamic Segment can be created by wrapping a folder's name in square
brackets: `[folderName]`. For example, `[id]` or `[slug]`.

Dynamic Segments are passed as the `params` prop to `layout`, `page`, `route`,
and `generateMetadata` functions.

For example, a blog could include the following route
`app/blog/[slug]/page.js` where `[slug]` is the Dynamic Segment for blog
posts.

    
    
    export default function Page({ params }) {
      return <div>My Post</div>;
    }

Route| Example URL| `params`  
---|---|---  
`app/blog/[slug]/page.js`| `/blog/a`| `{ slug: 'a' }`  
`app/blog/[slug]/page.js`| `/blog/b`| `{ slug: 'b' }`  
`app/blog/[slug]/page.js`| `/blog/c`| `{ slug: 'c' }`  
  
See the generateStaticParams() page to learn how to generate the params for
the segment.

> **Note:** Dynamic Segments are equivalent to Dynamic Routes in the `pages`
> directory.

The `generateStaticParams` function can be used in combination with dynamic
route segments to **statically generate** routes at build time instead of on-
demand at request time.

    
    
    export async function generateStaticParams() {
      const posts = await fetch('https://.../posts').then((res) => res.json());
     
      return posts.map((post) => ({
        slug: post.slug,
      }));
    }

The primary benefit of the `generateStaticParams` function is its smart
retrieval of data. If content is fetched within the `generateStaticParams`
function using a `fetch` request, the requests are automatically deduplicated.
This means a `fetch` request with the same arguments across multiple
`generateStaticParams`, Layouts, and Pages will only be made once, which
decreases build times.

Use the migration guide if you are migrating from the `pages` directory.

See `generateStaticParams` server function documentation for more information
and advanced use cases.

Dynamic Segments can be extended to **catch-all** subsequent segments by
adding an ellipsis inside the brackets `[...folderName]`.

For example, `app/shop/[...slug]/page.js` will match `/shop/clothes`, but also
`/shop/clothes/tops`, `/shop/clothes/tops/t-shirts`, and so on.

Route| Example URL| `params`  
---|---|---  
`app/shop/[...slug]/page.js`| `/shop/a`| `{ slug: ['a'] }`  
`app/shop/[...slug]/page.js`| `/shop/a/b`| `{ slug: ['a', 'b'] }`  
`app/shop/[...slug]/page.js`| `/shop/a/b/c`| `{ slug: ['a', 'b', 'c'] }`  
  
Catch-all Segments can be made **optional** by including the parameter in
double square brackets: `[[...folderName]]`.

For example, `app/shop/[[...slug]]/page.js` will **also** match `/shop`, in
addition to `/shop/clothes`, `/shop/clothes/tops`,
`/shop/clothes/tops/t-shirts`.

The difference between **catch-all** and **optional catch-all** segments is
that with optional, the route without the parameter is also matched (`/shop`
in the example above).

Route| Example URL| `params`  
---|---|---  
`app/shop/[[...slug]]/page.js`| `/shop`| `{}`  
`app/shop/[[...slug]]/page.js`| `/shop/a`| `{ slug: ['a'] }`  
`app/shop/[[...slug]]/page.js`| `/shop/a/b`| `{ slug: ['a', 'b'] }`  
`app/shop/[[...slug]]/page.js`| `/shop/a/b/c`| `{ slug: ['a', 'b', 'c'] }`  
  
When using TypeScript, you can add types for `params` depending on your
configured route segment.

    
    
    export default function Page({ params }: { params: { slug: string } }) {
      return <h1>My Page</h1>;
    }

Route| `params` Type Definition  
---|---  
`app/blog/[slug]/page.js`| `{ slug: string }`  
`app/shop/[...slug]/page.js`| `{ slug: string[] }`  
`app/[categoryId]/[itemId]/page.js`| `{ categoryId: string, itemId: string }`  
  
> **Note** : This may be done automatically by the TypeScript plugin in the
> future.





# Loading UI and Streaming

The special file `loading.js` helps you create meaningful Loading UI with
React Suspense. With this convention, you can show an instant loading state
from the server while the content of a route segment loads, the new content is
automatically swapped in once rendering is complete.

![Loading UI](/_next/image?url=%2Fdocs%2Flight%2Floading-
ui.png&w=3840&q=75)![Loading UI](/_next/image?url=%2Fdocs%2Fdark%2Floading-
ui.png&w=3840&q=75)

An instant loading state is fallback UI that is shown immediately upon
navigation. You can pre-render loading indicators such as skeletons and
spinners, or a small but meaningful part of future screens such as a cover
photo, title, etc. This helps users understand the app is responding and
provides a better user experience.

Create a loading state by adding a `loading.js` file inside a folder.

![loading.js special file](/_next/image?url=%2Fdocs%2Flight%2Floading-special-
file.png&w=3840&q=75)![loading.js special
file](/_next/image?url=%2Fdocs%2Fdark%2Floading-special-file.png&w=3840&q=75)

    
    
    export default function Loading() {
      // You can add any UI inside Loading, including a Skeleton.
      return <LoadingSkeleton />;
    }

In the same folder, `loading.js` will be nested inside `layout.js`. It will
automatically wrap the `page.js` file and any children below in a `<Suspense>`
boundary.

![loading.js overview](/_next/image?url=%2Fdocs%2Flight%2Floading-
overview.png&w=3840&q=75)![loading.js
overview](/_next/image?url=%2Fdocs%2Fdark%2Floading-overview.png&w=3840&q=75)

> **Good to know:**
>
>   * Navigation is immediate, even with server-centric routing.
>   * Navigation is interruptible, meaning changing routes does not need to
> wait for the content of the route to fully load before navigating to another
> route.
>   * Shared layouts remain interactive while new route segments load.
>

> **Recommendation:** Use the `loading.js` convention for route segments
> (layouts and pages) as Next.js optimizes this functionality.

In addition to `loading.js`, you can also manually create Suspense Boundaries
for your own UI components. The App Router supports streaming with Suspense
for both Node.js and Edge runtimes.

To learn how Streaming works in React and Next.js, it's helpful to understand
**Server-Side Rendering (SSR)** and its limitations.

With SSR, there's a series of steps that need to be completed before a user
can see and interact with a page:

  1. First, all data for a given page is fetched on the server.
  2. The server then renders the HTML for the page.
  3. The HTML, CSS, and JavaScript for the page are sent to the client.
  4. A non-interactive user interface is shown using the generated HTML, and CSS.
  5. Finally, React hydrates the user interface to make it interactive.

![Chart showing Server Rendering without
Streaming](/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-
streaming-chart.png&w=3840&q=75)![Chart showing Server Rendering without
Streaming](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-
streaming-chart.png&w=3840&q=75)

These steps are sequential and blocking, meaning the server can only render
the HTML for a page once all the data has been fetched. And, on the client,
React can only hydrate the UI once the code for all components in the page has
been downloaded.

SSR with React and Next.js helps improve the perceived loading performance by
showing a non-interactive page to the user as soon as possible.

![Server Rendering without
Streaming](/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-
streaming.png&w=3840&q=75)![Server Rendering without
Streaming](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-
streaming.png&w=3840&q=75)

However, it can still be slow as all data fetching on server needs to be
completed before the page can be shown to the user.

**Streaming** allows you to break down the page's HTML into smaller chunks and
progressively send those chunks from the server to the client.

![How Server Rendering with Streaming
Works](/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-
streaming.png&w=3840&q=75)![How Server Rendering with Streaming
Works](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-
streaming.png&w=3840&q=75)

This enables parts of the page to be displayed sooner, without waiting for all
the data to load before any UI can be rendered.

Streaming works well with React's component model because each component can
be considered a chunk. Components that have higher priority (e.g. product
information) or that don't rely on data can be sent first (e.g. layout), and
React can start hydration earlier. Components that have lower priority (e.g.
reviews, related products) can be sent in the same server request after their
data has been fetched.

![Chart showing Server Rendering with
Streaming](/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming-
chart.png&w=3840&q=75)![Chart showing Server Rendering with
Streaming](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming-
chart.png&w=3840&q=75)

Streaming is particularly beneficial when you want to prevent long data
requests from blocking the page from rendering as it can reduce the Time To
First Byte (TTFB) and First Contentful Paint (FCP). It also helps improve Time
to Interactive (TTI), especially on slower devices.

`<Suspense>` works by wrapping a component that performs an asynchronous
action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while
it's happening, and then swapping in your component once the action completes.

    
    
    import { Suspense } from 'react';
    import { PostFeed, Weather } from './Components';
     
    export default function Posts() {
      return (
        <section>
          <Suspense fallback={<p>Loading feed...</p>}>
            <PostFeed />
          </Suspense>
          <Suspense fallback={<p>Loading weather...</p>}>
            <Weather />
          </Suspense>
        </section>
      );
    }

By using Suspense, you get the benefits of:

  1. **Streaming Server Rendering** \- Progressively rendering HTML from the server to the client.
  2. **Selective Hydration** \- React prioritizes what components to make interactive first based on user interaction.

For more Suspense examples and use cases, please see the React Documentation.

  * Next.js will wait for data fetching inside `generateMetadata` to complete before streaming UI to the client. This guarantees the first part of a streamed response includes `<head>` tags.
  * Since streaming is server-rendered, it does not impact SEO. You can use the Mobile Friendly Test tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source).





# Error Handling

The `error.js` file convention allows you to gracefully handle runtime errors
in nested routes.

  * Automatically wrap a route segment and its nested children in a React Error Boundary.
  * Create error UI tailored to specific segments using the file-system hierarchy to adjust granularity.
  * Isolate errors to affected segments while keeping the rest of the app functional.
  * Add functionality to attempt to recover from an error without a full page reload.

Create error UI by adding an `error.js` file inside a route segment and
exporting a React component:

![error.js special file](/_next/image?url=%2Fdocs%2Flight%2Ferror-special-
file.png&w=3840&q=75)![error.js special
file](/_next/image?url=%2Fdocs%2Fdark%2Ferror-special-file.png&w=3840&q=75)

    
    
    'use client'; // Error components must be Client Components
     
    import { useEffect } from 'react';
     
    export default function Error({
      error,
      reset,
    }: {
      error: Error;
      reset: () => void;
    }) {
      useEffect(() => {
        // Log the error to an error reporting service
        console.error(error);
      }, [error]);
     
      return (
        <div>
          <h2>Something went wrong!</h2>
          <button
            onClick={
              // Attempt to recover by trying to re-render the segment
              () => reset()
            }
          >
            Try again
          </button>
        </div>
      );
    }

![How error.js works](/_next/image?url=%2Fdocs%2Flight%2Ferror-
overview.png&w=3840&q=75)![How error.js
works](/_next/image?url=%2Fdocs%2Fdark%2Ferror-overview.png&w=3840&q=75)

  * `error.js` automatically creates an React Error Boundary that **wraps** a nested child segment or `page.js` component.
  * The React component exported from the `error.js` file is used as the **fallback** component.
  * If an error is thrown within the error boundary, the error is **contained** , and the fallback component is **rendered**.
  * When the fallback error component is active, layouts **above** the error boundary **maintain** their state and **remain** interactive, and the error component can display functionality to recover from the error.

The cause of an error can sometimes be temporary. In these cases, simply
trying again might resolve the issue.

An error component can use the `reset()` function to prompt the user to
attempt to recover from the error. When executed, the function will try to re-
render the Error boundary's contents. If successful, the fallback error
component is replaced with the result of the re-render.

    
    
    'use client';
     
    export default function Error({
      error,
      reset,
    }: {
      error: Error;
      reset: () => void;
    }) {
      return (
        <div>
          <h2>Something went wrong!</h2>
          <button onClick={() => reset()}>Try again</button>
        </div>
      );
    }

React components created through special files are rendered in a specific
nested hierarchy.

For example, a nested route with two segments that both include `layout.js`
and `error.js` files are rendered in the following _simplified_ component
hierarchy:

![Nested Error Component Hierarchy](/_next/image?url=%2Fdocs%2Flight%2Fnested-
error-component-hierarchy.png&w=3840&q=75)![Nested Error Component
Hierarchy](/_next/image?url=%2Fdocs%2Fdark%2Fnested-error-component-
hierarchy.png&w=3840&q=75)

The nested component hierarchy has implications for the behavior of `error.js`
files across a nested route:

  * Errors bubble up to the nearest parent error boundary. This means an `error.js` file will handle errors for all its nested child segments. More or less granular error UI can be achieved by placing `error.js` files at different levels in the nested folders of a route.
  * An `error.js` boundary will **not** handle errors thrown in a `layout.js` component in the **same** segment because the error boundary is nested **inside** that layouts component.

`error.js` boundaries do **not** catch errors thrown in `layout.js` or
`template.js` components of the same segment. This intentional hierarchy keeps
important UI that is shared between sibling routes (such as navigation)
visible and functional when an error occurs.

To handle errors within a specific layout or template, place an `error.js`
file in the layouts parent segment.

To handle errors within the root layout or template, use a variation of
`error.js` called `global-error.js`.

The root `app/error.js` boundary does **not** catch errors thrown in the root
`app/layout.js` or `app/template.js` component.

To specifically handle errors in these root components, use a variation of
`error.js` called `app/global-error.js` located in the root `app` directory.

Unlike the root `error.js`, the `global-error.js` error boundary wraps the
**entire** application, and its fallback component replaces the root layout
when active. Because of this, it is important to note that `global-error.js`
**must** define its own `<html>` and `<body>` tags.

`global-error.js` is the least granular error UI and can be considered "catch-
all" error handling for the whole application. It is unlikely to be triggered
often as root components are typically less dynamic, and other `error.js`
boundaries will catch most errors.

Even if a `global-error.js` is defined, it is still recommended to define a
root `error.js` whose fallback component will be rendered **within** the root
layout, which includes globally shared UI and branding.

    
    
    'use client';
     
    export default function GlobalError({
      error,
      reset,
    }: {
      error: Error;
      reset: () => void;
    }) {
      return (
        <html>
          <body>
            <h2>Something went wrong!</h2>
            <button onClick={() => reset()}>Try again</button>
          </body>
        </html>
      );
    }

If an error is thrown during data fetching or inside a Server Component,
Next.js will forward the resulting `Error` object to the nearest `error.js`
file as the `error` prop.

When running `next dev`, the `error` will be serialized and forwarded from the
Server Component to the client `error.js`. To ensure security when running
`next start` in production, a generic error message is forwarded to `error`
along with a `.digest` which contains a hash of the error message. This hash
can be used to correspond to server logs.





# Parallel Routes

Parallel Routing allows you to simultaneously or conditionally render one or
more pages in the same layout. For highly dynamic sections of an app, such as
dashboards and feeds on social sites, Parallel Routing can be used to
implement complex routing patterns.

For example, you can simultaneously render the team and analytics pages.

![Parallel Routes Diagram](/_next/image?url=%2Fdocs%2Flight%2Fparallel-
routes.png&w=3840&q=75)![Parallel Routes
Diagram](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes.png&w=3840&q=75)

Parallel Routing allows you to define independent error and loading states for
each route as they're being streamed in independently.

![Parallel routes enable custom error and loading
states](/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-cinematic-
universe.png&w=3840&q=75)![Parallel routes enable custom error and loading
states](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-cinematic-
universe.png&w=3840&q=75)

Parallel Routing also allow you to conditionally render a slot based on
certain conditions, such as authentication state. This enables fully separated
code on the same URL.

![Conditional routes diagram](/_next/image?url=%2Fdocs%2Flight%2Fconditional-
routes-ui.png&w=3840&q=75)![Conditional routes
diagram](/_next/image?url=%2Fdocs%2Fdark%2Fconditional-routes-
ui.png&w=3840&q=75)

Parallel routes are created using named **slots**. Slots are defined with the
`@folder` convention, and are passed to the same-level layout as props.

> Slots are _not_ route segments and _do not affect the URL structure_. The
> file path `/@team/members` would be accessible at `/members`.

For example, the following file structure defines two explicit slots:
`@analytics` and `@team`.

![Parallel Routes File-system
Structure](/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-file-
system.png&w=3840&q=75)![Parallel Routes File-system
Structure](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-file-
system.png&w=3840&q=75)

The folder structure above means that the component in `app/layout.js` now
accepts the `@analytics` and `@team` slots props, and can render them in
parallel alongside the `children` prop:

    
    
    export default function Layout(props: {
      children: React.ReactNode;
      analytics: React.ReactNode;
      team: React.ReactNode;
    }) {
      return (
        <>
          {props.children}
          {props.team}
          {props.analytics}
        </>
      );
    }

> **Good to know** : The `children` prop is an implicit slot that does not
> need to be mapped to a folder. This means `app/page.js` is equivalent to
> `app/@children/page.js`.

By default, the content rendered within a slot will match the current URL.

In the case of an unmatched slot, the content that Next.js renders differs
based on the routing technique and folder structure.

You can define a `default.js` file to render as a fallback when Next.js cannot
recover a slot's active state based on the current URL.

Consider the following folder structure. The `@team` slot has a `settings`
directory, but `@analytics` does not.

![Parallel Routes unmatched
routes](/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-unmatched-
routes.png&w=3840&q=75)![Parallel Routes unmatched
routes](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-unmatched-
routes.png&w=3840&q=75)

If you were to navigate from the root `/` to `/settings`, the content that
gets rendered is different based on the type of navigation and the
availability of the `default.js` file.

| With `@analytics/default.js`| Without `@analytics/default.js`  
---|---|---  
Soft Navigation| `@team/settings/page.js` and `@analytics/page.js`|
`@team/settings/page.js` and `@analytics/page.js`  
Hard Navigation| `@team/settings/page.js` and `@analytics/default.js`| 404  
  
On a soft navigation \- Next.js will render the slot's previously active
state, even if it doesn't match the current URL.

On a hard navigation \- a navigation that requires a full page reload -
Next.js will first try to render the unmatched slot's `default.js` file. If
that's not available, a 404 gets rendered.

> The 404 for unmatched routes helps ensure that you don't accidentally render
> a route that shouldn't be parallel rendered.

Both `useSelectedLayoutSegment` and `useSelectedLayoutSegments` accept a
`parallelRoutesKey`, which allows you read the active route segment within
that slot.

    
    
    'use client';
    import { useSelectedLayoutSegment } from 'next/navigation';
     
    export default async function Layout(props: {
      //...
      authModal: React.ReactNode;
    }) {
      const loginSegments = useSelectedLayoutSegment('authModal');
      // ...
    }

When a user navigates to `@authModal/login`, or `/login` in the URL bar,
`loginSegments` will be equal to the string `"login"`.

Parallel Routing can be used to render modals.

![Parallel Routes Diagram](/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-
auth-modal.png&w=3840&q=75)![Parallel Routes
Diagram](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-auth-
modal.png&w=3840&q=75)

The `@authModal` slot renders a`<Modal>` component that can be shown by
navigating to a matching route, for example `/login`.

    
    
    export default async function Layout(props: {
      // ...
      authModal: React.ReactNode;
    }) {
      return (
        <>
          {/* ... */}
          {props.authModal}
        </>
      );
    }
    
    
    import { Modal } from 'components/modal';
     
    export default function Login() {
      return (
        <Modal>
          <h1>Login</h1>
          {/* ... */}
        </Modal>
      );
    }

To ensure that the contents of the modal don't get rendered when it's not
active, you can create a `default.js` file that returns `null`.

    
    
    export default function Default() {
      return null;
    }

If a modal was initiated through client navigation, e.g. by using `<Link
href="/login">`, you can dismiss the modal by calling `router.back()` or by
using a `Link` component.

    
    
    'use client';
    import { useRouter } from 'next/navigation';
    import { Modal } from 'components/modal';
     
    export default async function Login() {
      const router = useRouter();
      return (
        <Modal>
          <span onClick={() => router.back()}>Close modal</span>
          <h1>Login</h1>
          ...
        </Modal>
      );
    }

> More information on modals is covered in the Intercepting Routes section.

If you want to navigate elsewhere and dismiss a modal, you can also use a
catch-all route.

![Parallel Routes Diagram](/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-
catchall.png&w=3840&q=75)![Parallel Routes
Diagram](/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-
catchall.png&w=3840&q=75)

    
    
    export default function CatchAll() {
      return null;
    }

> Catch-all routes take presedence over `default.js`.

Parallel Routes can be used to implement conditional routing. For example, you
can render a `@dashboard` or `@login` route depending on the authentication
state.

    
    
    import { getUser } from '@/lib/auth';
     
    export default function Layout({ params, dashboard, login }) {
      const isLoggedIn = getUser();
      return isLoggedIn ? dashboard : login;
    }

![Parallel routes authentication
example](/_next/image?url=%2Fdocs%2Flight%2Fconditional-routes-
ui.png&w=3840&q=75)![Parallel routes authentication
example](/_next/image?url=%2Fdocs%2Fdark%2Fconditional-routes-
ui.png&w=3840&q=75)





# Intercepting Routes

Intercepting routes allows you to load a route within the current layout while
keeping the context for the current page. This routing paradigm can be useful
when you want to "intercept" a certain route to show a different route.

For example, when clicking on a photo from within a feed, a modal overlaying
the feed should show up with the photo. In this case, Next.js intercepts the
`/feed` route and "masks" this URL to show `/photo/123` instead.

![Intercepting routes soft
navigation](/_next/image?url=%2Fdocs%2Flight%2Fintercepting-routes-soft-
navigate.png&w=3840&q=75)![Intercepting routes soft
navigation](/_next/image?url=%2Fdocs%2Fdark%2Fintercepting-routes-soft-
navigate.png&w=3840&q=75)

However, when navigating to the photo directly by for example when clicking a
shareable URL or by refreshing the page, the entire photo page should render
instead of the modal. No route interception should occur.

![Intercepting routes hard
navigation](/_next/image?url=%2Fdocs%2Flight%2Fintercepting-routes-hard-
navigate.png&w=3840&q=75)![Intercepting routes hard
navigation](/_next/image?url=%2Fdocs%2Fdark%2Fintercepting-routes-hard-
navigate.png&w=3840&q=75)

Intercepting routes can be defined with the `(..)` convention, which is
similar to relative path convention `../` but for segments.

You can use:

  * `(.)` to match segments on the **same level**
  * `(..)` to match segments **one level above**
  * `(..)(..)` to match segments **two levels above**
  * `(...)` to match segments from the **root** `app` directory

For example, you can intercept the `photo` segment from within the `feed`
segment by creating a `(..)photo` directory.

![Intercepting routes folder
structure](/_next/image?url=%2Fdocs%2Flight%2Fintercepted-routes-
files.png&w=3840&q=75)![Intercepting routes folder
structure](/_next/image?url=%2Fdocs%2Fdark%2Fintercepted-routes-
files.png&w=3840&q=75)

> Note that the `(..)` convention is based on _route segments_ , not the file-
> system.

Intercepting Routes can be used together with Parallel Routes to create
modals.

Using this pattern to create modals overcomes some common challenges when
working with modals, by allowing you to:

  * Make the modal content **shareable through a URL**
  * **Preserve context** when the page is refreshed, instead of closing the modal
  * **Close the modal on backwards navigation** rather than going to the previous route
  * **Reopen the modal on forwards navigation**

![Intercepting routes modal
example](/_next/image?url=%2Fdocs%2Flight%2Fintercepted-routes-modal-
example.png&w=3840&q=75)![Intercepting routes modal
example](/_next/image?url=%2Fdocs%2Fdark%2Fintercepted-routes-modal-
example.png&w=3840&q=75)

> In the above example, the path to the `photo` segment can use the `(..)`
> matcher since `@modal` is a _slot_ and not a _segment_. This means that the
> `photo` route is only one _segment_ level higher, despite being two _file-
> system_ levels higher.

Other examples could include opening a login modal in a top navbar while also
having a dedicated `/login` page, or opening a shopping cart in a side modal.

View an example of modals with Intercepted and Parallel Routes.





# Route Handlers

Route Handlers allow you to create custom request handlers for a given route
using the Web Request and Response APIs.

![Route.js Special File](/_next/image?url=%2Fdocs%2Flight%2Froute-special-
file.png&w=3840&q=75)![Route.js Special
File](/_next/image?url=%2Fdocs%2Fdark%2Froute-special-file.png&w=3840&q=75)

> **Good to know:** Route Handlers are only available inside the `app`
> directory. They are the equivalent of API Routes inside the `pages`
> directory meaning you **do not** need to use API Routes and Route Handlers
> together.

Route Handlers are defined in a `route.js|ts` file inside the `app` directory:

    
    
    export async function GET(request: Request) {}

Route Handlers can be nested inside the `app` directory, similar to `page.js`
and `layout.js`. But there **cannot** be a `route.js` file at the same route
segment level as `page.js`.

The following HTTP methods are supported: `GET`, `POST`, `PUT`, `PATCH`,
`DELETE`, `HEAD`, and `OPTIONS`. If an unsupported method is called, Next.js
will return a `405 Method Not Allowed` response.

In addition to supporting native Request and Response. Next.js extends them
with `NextRequest` and `NextResponse` to provide convenient helpers for
advanced use cases.

Route Handlers are statically evaluated by default when using the `GET` method
with the `Response` object.

    
    
    import { NextResponse } from 'next/server';
     
    export async function GET() {
      const res = await fetch('https://data.mongodb-api.com/...', {
        headers: {
          'Content-Type': 'application/json',
          'API-Key': process.env.DATA_API_KEY,
        },
      });
      const data = await res.json();
     
      return NextResponse.json({ data });
    }

> **TypeScript Warning:** Although `Response.json()` is valid, native
> TypeScript types currently shows an error, you can use `NextResponse.json()`
> for typed responses instead.

Route handlers are evaluated dynamically when:

For example:

    
    
    import { NextResponse } from 'next/server';
     
    export async function GET(request: Request) {
      const { searchParams } = new URL(request.url);
      const id = searchParams.get('id');
      const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {
        headers: {
          'Content-Type': 'application/json',
          'API-Key': process.env.DATA_API_KEY,
        },
      });
      const product = await res.json();
     
      return NextResponse.json({ product });
    }

Similarly, the `POST` method will cause the Route Handler to be evaluated
dynamically.

    
    
    import { NextResponse } from 'next/server';
     
    export async function POST() {
      const res = await fetch('https://data.mongodb-api.com/...', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'API-Key': process.env.DATA_API_KEY,
        },
        body: JSON.stringify({ time: new Date().toISOString() }),
      });
     
      const data = await res.json();
     
      return NextResponse.json(data);
    }

> **Note:** Previously, API Routes could have been used for use cases like
> handling form submissions. Route Handlers are likely not the solution for
> these uses cases. We will be recommending the use of mutations for this when
> ready.

You can consider a `route` the lowest level routing primitive.

  * They **do not** participate in layouts or client-side navigations like `page`.
  * There **cannot** be a `route.js` file at the same route as `page.js`.

Page| Route| Result  
---|---|---  
`app/page.js`| `app/route.js`|  Conflict  
`app/page.js`| `app/api/route.js`|  Valid  
`app/[user]/page.js`| `app/api/route.js`|  Valid  
  
Each `route.js` or `page.js` file takes over all HTTP verbs for that route.

    
    
    export default function Page() {
      return <h1>Hello, Next.js!</h1>;
    }
     
    // ❌ Conflict
    // `app/route.js`
    export async function POST(request) {}

The following examples show how to combine Route Handlers with other Next.js
APIs and features.

You can revalidate static data fetches using the `next.revalidate` option:

    
    
    import { NextResponse } from 'next/server';
     
    export async function GET() {
      const res = await fetch('https://data.mongodb-api.com/...', {
        next: { revalidate: 60 }, // Revalidate every 60 seconds
      });
      const data = await res.json();
     
      return NextResponse.json(data);
    }

Alternatively, you can use the `revalidate` segment config option:

    
    
    export const revalidate = 60;

Route Handlers can be used with dynamic functions from Next.js, like `cookies`
and `headers`.

You can read cookies with `cookies` from `next/headers`. This server function
can be called directly in a Route Handler, or nested inside of another
function.

This `cookies` instance is read-only. To set cookies, you need to return a new
`Response` using the `Set-Cookie` header.

    
    
    import { cookies } from 'next/headers';
     
    export async function GET(request: Request) {
      const cookieStore = cookies();
      const token = cookieStore.get('token');
     
      return new Response('Hello, Next.js!', {
        status: 200,
        headers: { 'Set-Cookie': `token=${token}` },
      });
    }

Alternatively, you can use abstractions on top of the underlying Web APIs to
read cookies (`NextRequest`):

    
    
    import { type NextRequest } from 'next/server';
     
    export async function GET(request: NextRequest) {
      const token = request.cookies.get('token');
    }

You can read headers with `headers` from `next/headers`. This server function
can be called directly in a Route Handler, or nested inside of another
function.

This `headers` instance is read-only. To set headers, you need to return a new
`Response` with new `headers`.

    
    
    import { headers } from 'next/headers';
     
    export async function GET(request: Request) {
      const headersList = headers();
      const referer = headersList.get('referer');
     
      return new Response('Hello, Next.js!', {
        status: 200,
        headers: { referer: referer },
      });
    }

Alternatively, you can use abstractions on top of the underlying Web APIs to
read headers (`NextRequest`):

    
    
    import { type NextRequest } from 'next/server';
     
    export async function GET(request: NextRequest) {
      const requestHeaders = new Headers(request.headers);
    }
    
    
    import { redirect } from 'next/navigation';
     
    export async function GET(request: Request) {
      redirect('https://nextjs.org/');
    }

> We recommend reading the Defining Routes page before continuing.

Route Handlers can use Dynamic Segments to create request handlers from
dynamic data.

    
    
    export async function GET(
      request: Request,
      {
        params,
      }: {
        params: { slug: string };
      },
    ) {
      const slug = params.slug; // 'a', 'b', or 'c'
    }

Route| Example URL| `params`  
---|---|---  
`app/items/[slug]/route.js`| `/items/a`| `{ slug: 'a' }`  
`app/items/[slug]/route.js`| `/items/b`| `{ slug: 'b' }`  
`app/items/[slug]/route.js`| `/items/c`| `{ slug: 'c' }`  
      
    
    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
    function iteratorToStream(iterator: any) {
      return new ReadableStream({
        async pull(controller) {
          const { value, done } = await iterator.next();
     
          if (done) {
            controller.close();
          } else {
            controller.enqueue(value);
          }
        },
      });
    }
     
    function sleep(time: number) {
      return new Promise((resolve) => {
        setTimeout(resolve, time);
      });
    }
     
    const encoder = new TextEncoder();
     
    async function* makeIterator() {
      yield encoder.encode('<p>One</p>');
      await sleep(200);
      yield encoder.encode('<p>Two</p>');
      await sleep(200);
      yield encoder.encode('<p>Three</p>');
    }
     
    export async function GET() {
      const iterator = makeIterator();
      const stream = iteratorToStream(iterator);
     
      return new Response(stream);
    }

You can read the `Request` body using the standard Web API methods:

    
    
    import { NextResponse } from 'next/server';
     
    export async function POST(request: Request) {
      const res = await request.json();
      return NextResponse.json({ res });
    }

You can set CORS headers on a `Response` using the standard Web API methods:

    
    
    export async function GET(request: Request) {
      return new Response('Hello, Next.js!', {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        },
      });
    }

Route Handlers have an isomorphic Web API to support both Edge and Node.js
runtimes seamlessly, including support for streaming. Since Route Handlers use
the same route segment configuration as Pages and Layouts, they support long-
awaited features like general-purpose statically regenerated Route Handlers.

You can use the `runtime` segment config option to specify the runtime:

    
    
    export const runtime = 'edge'; // 'nodejs' is the default

You can use Route Handlers to return non-UI content. Note that `sitemap.xml`,
`robots.txt`, `app icons`, and open graph images all have built-in support.

    
    
    export async function GET() {
      return new Response(`<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0">
     
    <channel>
      <title>Next.js Documentation</title>
      <link>https://nextjs.org/docs</link>
      <description>The React Framework for the Web</description>
    </channel>
     
    </rss>`);
    }

Route Handlers use the same route segment configuration as pages and layouts.

    
    
    export const dynamic = 'auto';
    export const dynamicParams = true;
    export const revalidate = false;
    export const fetchCache = 'auto';
    export const runtime = 'nodejs';
    export const preferredRegion = 'auto';

See the API reference for more details.





# Middleware

Middleware allows you to run code before a request is completed. Then, based
on the incoming request, you can modify the response by rewriting,
redirecting, modifying the request or response headers, or responding
directly.

Middleware runs before cached content and routes are matched. See Matching
Paths for more details.

Use the file `middleware.ts` (or `.js`) in the root of your project to define
Middleware. For example, at the same level as `pages` or `app`, or inside
`src` if applicable.

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    // This function can be marked `async` if using `await` inside
    export function middleware(request: NextRequest) {
      return NextResponse.redirect(new URL('/home', request.url));
    }
     
    // See "Matching Paths" below to learn more
    export const config = {
      matcher: '/about/:path*',
    };

Middleware will be invoked for **every route in your project**. The following
is the execution order:

  1. `headers` from `next.config.js`
  2. `redirects` from `next.config.js`
  3. Middleware (`rewrites`, `redirects`, etc.)
  4. `beforeFiles` (`rewrites`) from `next.config.js`
  5. Filesystem routes (`public/`, `_next/static/`, `pages/`, `app/`, etc.)
  6. `afterFiles` (`rewrites`) from `next.config.js`
  7. Dynamic Routes (`/blog/[slug]`)
  8. `fallback` (`rewrites`) from `next.config.js`

There are two ways to define which paths Middleware will run on:

  1. Custom matcher config
  2. Conditional statements

`matcher` allows you to filter Middleware to run on specific paths.

    
    
    export const config = {
      matcher: '/about/:path*',
    };

You can match a single path or multiple paths with an array syntax:

    
    
    export const config = {
      matcher: ['/about/:path*', '/dashboard/:path*'],
    };

The `matcher` config allows full regex so matching like negative lookaheads or
character matching is supported. An example of a negative lookahead to match
all except specific paths can be seen here:

    
    
    export const config = {
      matcher: [
        /*
         * Match all request paths except for the ones starting with:
         * - api (API routes)
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         */
        '/((?!api|_next/static|_next/image|favicon.ico).*)',
      ],
    };

> **Note** : The `matcher` values need to be constants so they can be
> statically analyzed at build-time. Dynamic values such as variables will be
> ignored.

Configured matchers:

  1. MUST start with `/`
  2. Can include named parameters: `/about/:path` matches `/about/a` and `/about/b` but not `/about/a/c`
  3. Can have modifiers on named parameters (starting with `:`): `/about/:path*` matches `/about/a/b/c` because `*` is _zero or more_. `?` is _zero or one_ and `+` _one or more_
  4. Can use regular expression enclosed in parenthesis: `/about/(.*)` is the same as `/about/:path*`

Read more details on path-to-regexp documentation.

> **Note** : For backward compatibility, Next.js always considers `/public` as
> `/public/index`. Therefore, a matcher of `/public/:path` will match.
    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      if (request.nextUrl.pathname.startsWith('/about')) {
        return NextResponse.rewrite(new URL('/about-2', request.url));
      }
     
      if (request.nextUrl.pathname.startsWith('/dashboard')) {
        return NextResponse.rewrite(new URL('/dashboard/user', request.url));
      }
    }

The `NextResponse` API allows you to:

  * `redirect` the incoming request to a different URL
  * `rewrite` the response by displaying a given URL
  * Set request headers for API Routes, `getServerSideProps`, and `rewrite` destinations
  * Set response cookies
  * Set response headers

To produce a response from Middleware, you can:

  1. `rewrite` to a route (Page or Edge API Route) that produces a response
  2. return a `NextResponse` directly. See Producing a Response

Cookies are regular headers. On a `Request`, they are stored in the `Cookie`
header. On a `Response` they are in the `Set-Cookie` header. Next.js provides
a convenient way to access and manipulate these cookies through the `cookies`
extension on `NextRequest` and `NextResponse`.

  1. For incoming requests, `cookies` comes with the following methods: `get`, `getAll`, `set`, and `delete` cookies. You can check for the existence of a cookie with `has` or remove all cookies with `clear`.
  2. For outgoing responses, `cookies` have the following methods `get`, `getAll`, `set`, and `delete`.

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      // Assume a "Cookie:nextjs=fast" header to be present on the incoming request
      // Getting cookies from the request using the `RequestCookies` API
      let cookie = request.cookies.get('nextjs')?.value;
      console.log(cookie); // => 'fast'
      const allCookies = request.cookies.getAll();
      console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]
     
      request.cookies.has('nextjs'); // => true
      request.cookies.delete('nextjs');
      request.cookies.has('nextjs'); // => false
     
      // Setting cookies on the response using the `ResponseCookies` API
      const response = NextResponse.next();
      response.cookies.set('vercel', 'fast');
      response.cookies.set({
        name: 'vercel',
        value: 'fast',
        path: '/test',
      });
      cookie = response.cookies.get('vercel');
      console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/test' }
      // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.
     
      return response;
    }

You can set request and response headers using the `NextResponse` API (setting
_request_ headers is available since Next.js v13.0.0).

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      // Clone the request headers and set a new header `x-hello-from-middleware1`
      const requestHeaders = new Headers(request.headers);
      requestHeaders.set('x-hello-from-middleware1', 'hello');
     
      // You can also set request headers in NextResponse.rewrite
      const response = NextResponse.next({
        request: {
          // New request headers
          headers: requestHeaders,
        },
      });
     
      // Set a new response header `x-hello-from-middleware2`
      response.headers.set('x-hello-from-middleware2', 'hello');
      return response;
    }

> **Note** : Avoid setting large headers as it might cause 431 Request Header
> Fields Too Large error depending on your backend web server configuration.

You can respond from Middleware directly by returning a `Response` or
`NextResponse` instance. (This is available since Next.js v13.1.0)

    
    
    import { NextRequest, NextResponse } from 'next/server';
    import { isAuthenticated } from '@lib/auth';
     
    // Limit the middleware to paths starting with `/api/`
    export const config = {
      matcher: '/api/:function*',
    };
     
    export function middleware(request: NextRequest) {
      // Call our authentication function to check the request
      if (!isAuthenticated(request)) {
        // Respond with JSON indicating an error message
        return new NextResponse(
          JSON.stringify({ success: false, message: 'authentication failed' }),
          { status: 401, headers: { 'content-type': 'application/json' } },
        );
      }
    }

In `v13.1` of Next.js two additional flags were introduced for middleware,
`skipMiddlewareUrlNormalize` and `skipTrailingSlashRedirect` to handle
advanced use cases.

`skipTrailingSlashRedirect` allows disabling Next.js default redirects for
adding or removing trailing slashes allowing custom handling inside middleware
which can allow maintaining the trailing slash for some paths but not others
allowing easier incremental migrations.

    
    
    module.exports = {
      skipTrailingSlashRedirect: true,
    };
    
    
    const legacyPrefixes = ['/docs', '/blog'];
     
    export default async function middleware(req) {
      const { pathname } = req.nextUrl;
     
      if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
        return NextResponse.next();
      }
     
      // apply trailing slash handling
      if (
        !pathname.endsWith('/') &&
        !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
      ) {
        req.nextUrl.pathname += '/';
        return NextResponse.redirect(req.nextUrl);
      }
    }

`skipMiddlewareUrlNormalize` allows disabling the URL normalizing Next.js does
to make handling direct visits and client-transitions the same. There are some
advanced cases where you need full control using the original URL which this
unlocks.

    
    
    module.exports = {
      skipMiddlewareUrlNormalize: true,
    };
    
    
    export default async function middleware(req) {
      const { pathname } = req.nextUrl;
     
      // GET /_next/data/build-id/hello.json
     
      console.log(pathname);
      // with the flag this now /_next/data/build-id/hello.json
      // without the flag this would be normalized to /hello
    }

Version| Changes  
---|---  
`v13.1.0`| Advanced Middleware flags added  
`v13.0.0`| Middleware can modify request headers, response headers, and send
responses  
`v12.2.0`| Middleware is stable, please see the upgrade guide  
`v12.0.9`| Enforce absolute URLs in Edge Runtime (PR)  
`v12.0.0`| Middleware (Beta) added





# Project Organization and File Colocation

Apart from routing folder and file conventions, Next.js is **unopinionated**
about how your project files are organized and colocated.

This page shares default behavior and features you can use to organize your
project.

In the `app` directory, nested folder hierarchy defines route structure.

Each folder represents a route segment that is mapped to a corresponding
segment in a URL path.

However, even though route structure is defined through folders, a route is
**not publically accessible** until a `page.js` or `route.js` file is added to
a route segment.

![A diagram showing how a route is not publically accessible until a page.js
or route.js file is added to a route
segment.](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-not-
routable.png&w=3840&q=75)![A diagram showing how a route is not publically
accessible until a page.js or route.js file is added to a route
segment.](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-not-
routable.png&w=3840&q=75)

And, even when a route is made publically accessible, only the content
returned by `page.js` or `route.js` is sent to the client.

![A diagram showing how page.js and route.js files make routes publically
accessible.](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-
routable.png&w=3840&q=75)![A diagram showing how page.js and route.js files
make routes publically accessible.](/_next/image?url=%2Fdocs%2Fdark%2Fproject-
organization-routable.png&w=3840&q=75)

This means that **project files** can be **safely colocated** inside route
segments in the `app` directory without accidentally being routable.

![A diagram showing colocated project files are not routable even when a
segment contains a page.js or route.js
file.](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-
colocation.png&w=3840&q=75)![A diagram showing colocated project files are not
routable even when a segment contains a page.js or route.js
file.](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-
colocation.png&w=3840&q=75)

> **Good to know** :
>
>   * This is different from the `pages` directory, where any file in `pages`
> is considered a route.
>   * While you **can** colocate your project files in `app` you don't
> **have** to. If you prefer, you can keep them outside the `app` directory.
>

Next.js provides several features to help you organize your project.

Private folders can be created by prefixing a folder with an underscore:
`_folderName`.

This indicates the folder is a private implementation detail and should not be
considered by the routing system, **opting the folder and all its subfolders
out of routing**.

![An example folder structure using private
folders](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-private-
folders.png&w=3840&q=75)![An example folder structure using private
folders](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-private-
folders.png&w=3840&q=75)

Since files in the `app` directory can be safely colocated by default, Private
folders are not required for colocation. However, they can be useful for:

  * Separating UI logic from routing logic.
  * Consistently organizing internal files across a project and the Next.js ecosystem.
  * Sorting and grouping files in code editors.
  * Avoiding potential naming conflicts with future Next.js file conventions.

> **Good to know**
>
>   * While not a framework convention, you might also consider marking files
> outside private folders as "private" using the same underscore pattern.
>   * You can create URL segments that start with an underscore by prefixing
> the folder name with `%5F` (the URL-encoded form of an underscore):
> `%5FfolderName`.
>   * If you don't use private folders, it would be helpful to know Next.js
> special file conventions to prevent unexpected naming conflicts.
>

In the `app` directory, nested folders are normally mapped to URL paths.
However, you can break out of this behavior using Route groups.

Route groups can be created by wrapping a folder in parenthesis:
`(folderName)`.

This indicates the folder is for organizational purposes and **should not be
included in the route's URL path**.

![An example folder structure using route
groups](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-route-
groups.png&w=3840&q=75)![An example folder structure using route
groups](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-route-
groups.png&w=3840&q=75)

Route groups are useful for:

Next.js supports storing application code (including `app`) inside a `src`
directory. This separates application code from project configuration files
which mostly live in the root of a project.

![An example folder structure with the `src`
directory](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-src-
directory.png&w=3840&q=75)![An example folder structure with the `src`
directory](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-src-
directory.png&w=3840&q=75)

Next.js supports Module Path Aliases which make it easier to read and maintain
imports across deeply nested project files.

    
    
    // before
    import { Button } from '../../../components/button';
     
    // after
    import { Button } from '@/components/button';

There is no "right" or "wrong" way when it comes to organizing your own files
and folders in Next.js a project.

The following section lists a very high-level overview of common strategies.
The simplest takeaway is to choose a strategy that works for you and your team
and be consistent across the project.

> **Note:** In our examples below, we're using `components` and `lib` folders
> as generalized placeholders, their naming has no special framework
> significance and your projects might use other folders like `ui`, `utils`,
> `hooks`, `styles`, etc.

This strategy keeps all application code in shared folders in the root of your
project and keeps the `app` directory purely for routing purposes.

![An example folder structure with project files outside of
app](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-project-
root.png&w=3840&q=75)![An example folder structure with project files outside
of app](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-project-
root.png&w=3840&q=75)

This strategy keeps all application code in shared folders in the **root** of
the `app` directory.

![An example folder structure with project files inside
app](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-app-
root.png&w=3840&q=75)![An example folder structure with project files inside
app](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-app-
root.png&w=3840&q=75)

This strategy keeps globally shared application code in the root `app`
directory and splits more specific application code into the route segments
that use them.

![An example folder structure with project files split by feature or
route](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-app-root-
split.png&w=3840&q=75)![An example folder structure with project files split
by feature or route](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-
app-root-split.png&w=3840&q=75)





# Internationalization

Next.js enables you to configure the routing and rendering of content to
support multiple languages. Making your site adaptive to different locales
includes translated content (localization) and internationalized routes.

  * **Locale:** An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and possibly their geographic region. 
    * `en-US`: English as spoken in the United States
    * `nl-NL`: Dutch as spoken in the Netherlands
    * `nl`: Dutch, no specific region

It’s recommended to use the user’s language preferences in the browser to
select which locale to use. Changing your preferred language will modify the
incoming `Accept-Language` header to your application.

For example, using the following libraries, you can look at an incoming
`Request` to determine which locale to select, based on the `Headers`, locales
you plan to support, and the default locale.

    
    
    import { match } from '@formatjs/intl-localematcher';
    import Negotiator from 'negotiator';
     
    let headers = { 'accept-language': 'en-US,en;q=0.5' };
    let languages = new Negotiator({ headers }).languages();
    let locales = ['en-US', 'nl-NL', 'nl'];
    let defaultLocale = 'en-US';
     
    match(languages, locales, defaultLocale); // -> 'en-US'

Routing can be internationalized by either the sub-path (`/fr/products`) or
domain (`my-site.fr/products`). With this information, you can now redirect
the user based on the locale inside Middleware.

    
    
    import { NextResponse } from 'next/server'
     
    let locales = ['en-US', 'nl-NL', 'nl']
     
    // Get the preferred locale, similar to above or using a library
    function getLocale(request) { ... }
     
    export function middleware(request) {
      // Check if there is any supported locale in the pathname
      const pathname = request.nextUrl.pathname
      const pathnameIsMissingLocale = locales.every(
        (locale) => !pathname.startsWith(`/${locale}/`) && pathname !== `/${locale}`
      )
     
      // Redirect if there is no locale
      if (pathnameIsMissingLocale) {
        const locale = getLocale(request)
     
        // e.g. incoming request is /products
        // The new URL is now /en-US/products
        return NextResponse.redirect(
          new URL(`/${locale}/${pathname}`, request.url)
        )
      }
    }
     
    export const config = {
      matcher: [
        // Skip all internal paths (_next)
        '/((?!_next).*)',
        // Optional: only run on root (/) URL
        // '/'
      ],
    }

Finally, ensure all special files inside `app/` are nested under `app/[lang]`.
This enables the Next.js router to dynamically handle different locales in the
route, and forward the `lang` parameter to every layout and page. For example:

    
    
    // You now have access to the current locale
    // e.g. /en-US/products -> `lang` is "en-US"
    export default async function Page({ params: { lang } }) {
      return ...
    }

The root layout can also be nested in the new folder (e.g.
`app/[lang]/layout.js`).

Changing displayed content based on the user’s preferred locale, or
localization, is not something specific to Next.js. The patterns described
below would work the same with any web application.

Let’s assume we want to support both English and Dutch content inside our
application. We might maintain two different “dictionaries”, which are objects
that give us a mapping from some key to a localized string. For example:

    
    
    {
      "products": {
        "cart": "Add to Cart"
      }
    }
    
    
    {
      "products": {
        "cart": "Toevoegen aan Winkelwagen"
      }
    }

We can then create a `getDictionary` function to load the translations for the
requested locale:

    
    
    import 'server-only';
     
    const dictionaries = {
      en: () => import('./dictionaries/en.json').then((module) => module.default),
      nl: () => import('./dictionaries/nl.json').then((module) => module.default),
    };
     
    export const getDictionary = async (locale) => dictionaries[locale]();

Given the currently selected language, we can fetch the dictionary inside of a
layout or page.

    
    
    import { getDictionary } from './dictionaries';
     
    export default async function Page({ params: { lang } }) {
      const dict = await getDictionary(lang); // en
      return <button>{dict.products.cart}</button>; // Add to Cart
    }

Because all layouts and pages in the `app/` directory default to Server
Components, we do not need to worry about the size of the translation files
affecting our client-side JavaScript bundle size. This code will **only run on
the server** , and only the resulting HTML will be sent to the browser.

To generate static routes for a given set of locales, we can use
`generateStaticParams` with any page or layout. This can be global, for
example, in the root layout:

    
    
    export async function generateStaticParams() {
      return [{ lang: 'en-US' }, { lang: 'de' }];
    }
     
    export default function Root({ children, params }) {
      return (
        <html lang={params.lang}>
          <body>{children}</body>
        </html>
      );
    }



  
  
# Rendering

Rendering converts the code you write into user interfaces.

React 18 and Next.js 13 introduced new ways to render your application. This
page will help you understand the differences between rendering environments,
strategies, runtimes, and how to opt into them.

There are two environments where your application code can be rendered: the
client and the server.

![Client and Server Environemnts](/_next/image?url=%2Fdocs%2Flight%2Fclient-
and-server-environments.png&w=3840&q=75)![Client and Server
Environemnts](/_next/image?url=%2Fdocs%2Fdark%2Fclient-and-server-
environments.png&w=3840&q=75)

  * The **client** refers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.
  * The **server** refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

> **Note:** Server can refer to computers in regions where your application is
> deployed to, the Edge Network where your application code is distributed, or
> Content Delivery Networks (CDNs) where the result of the rendering work can
> be cached.

Before React 18, the primary way to render your application **using React**
was entirely on the client.

Next.js provided an easier way to break down your application into **pages**
and prerender on the server by generating HTML and sending it to the client to
be hydrated by React. However, this led to additional JavaScript needed on the
client to make the initial HTML interactive.

Now, with Server and Client Components, React can render on the client **and**
the server meaning you can choose the rendering environment at the component
level.

By default, the `app` router uses **Server Components**, allowing you to
easily render components on the server and reducing the amount of JavaScript
sent to the client.

In addition to client-side and server-side rendering with React components,
Next.js gives you the option to optimize rendering on the server with
**Static** and **Dynamic** Rendering.

With **Static Rendering** , both Server _and_ Client Components can be
prerendered on the server at **build time**. The result of the work is cached
and reused on subsequent requests. The cached result can also be revalidated.

> **Note:** This is equivalent to Static Site Generation (SSG) and Incremental
> Static Regeneration (ISR) in the Pages Router.

Server and Client Components are rendered differently during Static Rendering:

  * Client Components have their HTML and JSON prerendered and cached on the server. The cached result is then sent to the client for hydration.
  * Server Components are rendered on the server by React, and their payload is used to generate HTML. The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.

With Dynamic Rendering, both Server _and_ Client Components are rendered on
the server at **request time**. The result of the work is not cached.

> **Note:** This is equivalent to Server-Side Rendering
> (`getServerSideProps()`) in the Pages Router.

To learn more about static and dynamic behavior, see the Static and Dynamic
Rendering page. To learn more about caching, see the Caching sections.

On the server, there are two runtimes where your pages can be rendered:

  * The **Node.js Runtime** (default) has access to all Node.js APIs and compatible packages from the ecosystem.
  * The **Edge Runtime** is based on Web APIs.

Both runtimes support streaming from the server, depending on your deployment
infrastructure.

To learn how to switch between runtimes, see the Edge and Node.js Runtimes
page.

Now that you understand the fundamentals of rendering, you can learn more
about implementing the different rendering strategies and runtimes:





# Static and Dynamic Rendering

In Next.js, a route can be statically or dynamically rendered.

  * In a **static** route, components are rendered on the server at build time. The result of the work is cached and reused on subsequent requests.
  * In a **dynamic** route, components are rendered on the server at request time.

By default, Next.js statically renders routes to improve performance. This
means all the rendering work is done ahead of time and can be served from a
Content Delivery Network (CDN) geographically closer to the user.

By default, Next.js will cache the result of `fetch()` requests that do not
specifically opt out of caching behavior. This means that fetch requests that
do not set a `cache` option will use the `force-cache` option.

If any fetch requests in the route use the `revalidate` option, the route will
be re-rendered statically during revalidation.

To learn more about caching data fetching requests, see the Caching and
Revalidating page.

During static rendering, if a dynamic function or a dynamic `fetch()` request
(no caching) is discovered, Next.js will switch to dynamically rendering the
whole route at request time. Any cached data requests can still be re-used
during dynamic rendering.

This table summarizes how dynamic functions and caching affect the rendering
behavior of a route:

Data Fetching| Dynamic Functions| Rendering  
---|---|---  
Static (Cached)| No| Static  
Static (Cached)| Yes| Dynamic  
Not Cached| No| Dynamic  
Not Cached| Yes| Dynamic  
  
Note how dynamic functions always opt the route into dynamic rendering,
regardless of whether the data fetching is cached or not. In other words,
static rendering is dependent not only on the data fetching behavior, but also
on the dynamic functions used in the route.

> **Note:** In the future, Next.js will introduce hybrid server-side rendering
> where layouts and pages in a route can be independently statically or
> dynamically rendered, instead of the whole route.

Dynamic functions rely on information that can only be known at request time
such as a user's cookies, current requests headers, or the URL's search
params. In Next.js, these dynamic functions are:

  * Using `cookies()` or `headers()` in a Server Component will opt the whole route into dynamic rendering at request time.
  * Using `useSearchParams()` in Client Components will skip static rendering and instead render all Client Components up to the nearest parent Suspense boundary on the client. 
    * We recommend wrapping the Client Component that uses `useSearchParams()` in a `<Suspense/>` boundary. This will allow any Client Components above it to be statically rendered. Example.
  * Using the `searchParams` Pages prop will opt the page into dynamic rendering at request time.

Dynamic data fetches are `fetch()` requests that specifically opt out of
caching behavior by setting the `cache` option to `'no-store'` or `revalidate`
to `0`.

The caching options for all `fetch` requests in a layout or page can also be
set using the segment config object.

To learn more about Dynamic Data Fetching, see the Data Fetching page.





# Edge and Node.js Runtimes

In the context of Next.js, "runtime" refers to the set of libraries, APIs, and
general functionality available to your code during execution.

Next.js has two server runtimes where you can render parts of your application
code:

Each runtime has its own set of APIs. Please refer to the Node.js Docs and
Edge Docs for the full list of available APIs. Both runtimes can also support
streaming depending on your deployment infrastructure.

By default, the `app` directory uses the Node.js runtime. However, you can opt
into different runtimes (e.g. Edge) on a per-route basis.

There are many considerations to make when choosing a runtime. This table
shows the major differences at a glance. If you want a more in-depth analysis
of the differences, check out the sections below.

| Node| Serverless| Edge  
---|---|---|---  
Cold Boot| /| ~250ms| Instant  
HTTP Streaming| Yes| Yes| Yes  
IO| All| All| `fetch`  
Scalability| /| High| Highest  
Security| Normal| High| High  
Latency| Normal| Low| Lowest  
npm Packages| All| All| A smaller subset  
  
In Next.js, the lightweight Edge Runtime is a subset of available Node.js
APIs.

The Edge Runtime is ideal if you need to deliver dynamic, personalized content
at low latency with small, simple functions. The Edge Runtime's speed comes
from its minimal use of resources, but that can be limiting in many scenarios.

For example, code executed in the Edge Runtime on Vercel cannot exceed between
1 MB and 4 MB, this limit includes imported packages, fonts and files, and
will vary depending on your deployment infrastructure.

Using the Node.js runtime gives you access to all Node.js APIs, and all npm
packages that rely on them. However, it's not as fast to start up as routes
using the Edge runtime.

Deploying your Next.js application to a Node.js server will require managing,
scaling, and configuring your infrastructure. Alternatively, you can consider
deploying your Next.js application to a serverless platform like Vercel, which
will handle this for you.

Serverless is ideal if you need a scalable solution that can handle more
complex computational loads than the Edge Runtime. With Serverless Functions
on Vercel, for example, your overall code size is 50MB including imported
packages, fonts, and files.

The downside compared to routes using the Edge is that it can take hundreds of
milliseconds for Serverless Functions to boot up before they begin processing
requests. Depending on the amount of traffic your site receives, this could be
a frequent occurrence as the functions are not frequently "warm".

You can specify a runtime for individual route segments in your Next.js
application. To do so, declare a variable called `runtime` and export it. The
variable must be a string, and must have a value of either `'nodejs'` or
`'edge'` runtime.

The following example demonstrates a page route segment that exports a
`runtime` with a value of `'edge'`:

    
    
    export const runtime = 'edge'; // 'nodejs' (default) | 'edge'

If the segment runtime is _not_ set, the default `nodejs` runtime will be
used. You do not need to use the `runtime` option if you do not plan to change
from the Node.js runtime.





# Data Fetching

The Next.js App Router introduces a new, simplified data fetching system built
on React and the Web platform. This page will go through the fundamental
concepts and patterns to help you manage your data's lifecycle.

Here's a quick overview of the recommendations on this page:

  1. Fetch data on the server using Server Components.
  2. Fetch data in parallel to minimize waterfalls and reduce loading times.
  3. For Layouts and Pages, fetch data where it's used. Next.js will automatically dedupe requests in a tree.
  4. Use Loading UI, Streaming and Suspense to progressively render a page and show a result to the user while the rest of the content loads.

The new data fetching system is built on top of the native `fetch()` Web API
and makes use of `async` and `await` in Server Components.

Learn how to use `fetch` in Next.js.

Whenever possible, we recommend fetching data in Server Components. Server
Components **always fetch data on the server**. This allows you to:

  * Have direct access to backend data resources (e.g. databases).
  * Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.
  * Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.
  * Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.
  * Reduce client-server waterfalls.
  * Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

> **Good to know:** It's still possible to fetch data client-side. We
> recommend using a third-party library such as SWR or React Query with Client
> Components. In the future, it'll also be possible to fetch data in Client
> Components using React's `use()` hook.

In the App Router, you can fetch data inside layouts, pages, and components.
Data fetching is also compatible with Streaming and Suspense.

> **Good to know:** For layouts, it's not possible to pass data between a
> parent layout and its `children` components. We recommend **fetching data
> directly inside the layout that needs it** , even if you're requesting the
> same data multiple times in a route. Behind the scenes, React and Next.js
> will cache and dedupe requests to avoid the same data being fetched more
> than once.

When fetching data inside components, you need to be aware of two data
fetching patterns: Parallel and Sequential.

![Sequential and Parallel Data
Fetching](/_next/image?url=%2Fdocs%2Flight%2Fsequential-parallel-data-
fetching.png&w=3840&q=75)![Sequential and Parallel Data
Fetching](/_next/image?url=%2Fdocs%2Fdark%2Fsequential-parallel-data-
fetching.png&w=3840&q=75)

  * With **parallel data fetching** , requests in a route are eagerly initiated and will load data at the same time. This reduces client-server waterfalls and the total time it takes to load data.
  * With **sequential data fetching** , requests in a route are dependent on each other and create waterfalls. There may be cases where you want this pattern because one fetch depends on the result of the other, or you want a condition to be satisfied before the next fetch to save resources. However, this behavior can also be unintentional and lead to longer loading times.

Learn how to implement parallel and sequential data fetching.

If you need to fetch the same data (e.g. current user) in multiple components
in a tree, Next.js will automatically cache `fetch` requests (`GET`) that have
the same input in a temporary cache. This optimization prevents the same data
from being fetched more than once during a rendering pass.

![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Flight%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Fdark%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)

  * On the server, the cache lasts the lifetime of a server request until the rendering process completes. 
    * This optimization applies to `fetch` requests made in Layouts, Pages, Server Components, `generateMetadata` and `generateStaticParams`.
    * This optimization also applies during static generation.
  * On the client, the cache lasts the duration of a session (which could include multiple client-side re-renders) before a full page reload.

> **Good to know:**
>
>   * `POST` requests are not automatically deduplicated. Learn more about
> caching.
>   * If you're unable to use `fetch`, React provides a `cache` function to
> allow you to manually cache data for the duration of the request.
>

There are two types of data: **Static** and **Dynamic**.

  * **Static Data** is data that doesn't change often. For example, a blog post.
  * **Dynamic Data** is data that changes often or can be specific to users. For example, a shopping cart list.

![Dynamic and Static Data
Fetching](/_next/image?url=%2Fdocs%2Flight%2Fdynamic-and-static-data-
fetching.png&w=3840&q=75)![Dynamic and Static Data
Fetching](/_next/image?url=%2Fdocs%2Fdark%2Fdynamic-and-static-data-
fetching.png&w=3840&q=75)

By default, Next.js automatically does static fetches. This means that the
data will be fetched at build time, cached, and reused on each request. As a
developer, you have control over how the static data is cached and
revalidated.

There are two benefits to using static data:

  1. It reduces the load on your database by minimizing the number of requests made.
  2. The data is automatically cached for improved loading performance.

However, if your data is personalized to the user or you want to always fetch
the latest data, you can mark requests as _dynamic_ and fetch data on each
request without caching.

Learn how to do Static and Dynamic data fetching.

Caching is the process of storing data in a location (e.g. Content Delivery
Network) so it doesn't need to be re-fetched from the original source on each
request.

![Static Site Generation](/_next/image?url=%2Fdocs%2Flight%2Fstatic-site-
generation.png&w=3840&q=75)![Static Site
Generation](/_next/image?url=%2Fdocs%2Fdark%2Fstatic-site-
generation.png&w=3840&q=75)

The **Next.js Cache** is a persistent HTTP cache that can be globally
distributed. This means the cache can scale automatically and be shared across
multiple regions depending on your platform (e.g. Vercel).

Next.js extends the options object of the `fetch()` function to allow each
request on the server to set its own persistent caching behavior. Together
with component-level data fetching, this allows you to configure caching
within your application code directly where the data is being used.

During server rendering, when Next.js comes across a fetch, it will check the
cache to see if the data is already available. If it is, it will return the
cached data. If not, it will fetch and store data for future requests.

> **Good to know:** If you're unable to use `fetch`, React provides a `cache`
> function to allow you to manually cache data for the duration of the
> request.

Learn more about caching in Next.js.

Revalidation is the process of purging the cache and re-fetching the latest
data. This is useful when your data changes and you want to ensure your
application shows the latest version without having to rebuild your entire
application.

Next.js provides two types of revalidation:

  * **Background**: Revalidates the data at a specific time interval.
  * **On-demand**: Revalidates the data whenever there is an update.

Learn how to revalidate data.

Streaming and Suspense are new React features that allow you to progressively
render and incrementally stream rendered units of the UI to the client.

With Server Components and nested layouts, you're able to instantly render
parts of the page that do not specifically require data, and show a loading
state for parts of the page that are fetching data. This means the user does
not have to wait for the entire page to load before they can start interacting
with it.

![Server Rendering with Streaming](/_next/image?url=%2Fdocs%2Flight%2Fserver-
rendering-with-streaming.png&w=3840&q=75)![Server Rendering with
Streaming](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-
streaming.png&w=3840&q=75)

To learn more about Streaming and Suspense, see the Loading UI and Streaming
and Suspense pages.

Previous Next.js data fetching methods such as `getServerSideProps`,
`getStaticProps`, and `getInitialProps` are **not** supported in the new App
Router. However, you can still use them in the Pages Router.

Now that you understand the fundamentals of data fetching in Next.js, you can
learn more about managing data in your application:





# Data Fetching

> **Good to know** :
>
>   * This new data fetching model is currently being developed by the React
> team. We recommend reading the support for promises React RFC which
> introduces `async` and `await` in Server Components and a new `use()` hook
> for Client Components.
>   * While you can try it out, it is not yet stable. We'll keep these docs
> updated to reflect the latest developments.
>

React and Next.js 13 introduced a new way to fetch and manage data in your
application. The new data fetching system works in the `app` directory and is
built on top of the `fetch()` Web API.

`fetch()` is a Web API used to fetch remote resources that **returns a
promise**. React extends `fetch` to provide automatic request deduping, and
Next.js extends the `fetch` options object to allow each request to set its
own caching and revalidating.

With the proposed React RFC, you can use `async` and `await` to fetch data in
Server Components.

    
    
    async function getData() {
      const res = await fetch('https://api.example.com/...');
      // The return value is *not* serialized
      // You can return Date, Map, Set, etc.
     
      // Recommendation: handle errors
      if (!res.ok) {
        // This will activate the closest `error.js` Error Boundary
        throw new Error('Failed to fetch data');
      }
     
      return res.json();
    }
     
    export default async function Page() {
      const data = await getData();
     
      return <main></main>;
    }

> **Async Server Component TypeScript Error**
>
>   * An `async` Server Components will cause a `'Promise<Element>' is not a
> valid JSX element` type error where it is used.
>   * This is a known issue with TypeScript and is being worked on upstream.
>   * As a temporary workaround, you can add `{/* @ts-expect-error Async
> Server Component */}` above the component to disable type checking for it.
>

Next.js provides helpful server functions you may need when fetching data in
Server Components:

`use` is a new React function that **accepts a promise** conceptually similar
to `await`. `use` **handles the promise** returned by a function in a way that
is compatible with components, hooks, and Suspense. Learn more about `use` in
the React RFC.

Wrapping `fetch` in `use` is currently **not** recommended in Client
Components and may trigger multiple re-renders. For now, if you need to fetch
data in a Client Component, we recommend using a third-party library such as
SWR or React Query.

> **Note:** We'll be adding more examples once `fetch` and `use` work in
> Client Components.

By default, `fetch` will automatically fetch and cache data indefinitely.

    
    
    fetch('https://...'); // cache: 'force-cache' is the default

To revalidate cached data at a timed interval, you can use the
`next.revalidate` option in `fetch()` to set the `cache` lifetime of a
resource (in seconds).

    
    
    fetch('https://...', { next: { revalidate: 10 } });

See Revalidating Data for more information.

> **NOTE:** Caching at the fetch level via `revalidate` or `cache: 'force-
> cache'` stores the data across requests in a shared cache. You should avoid
> using it for user-specific data (i.e. requests that derive data from
> `cookies()` or `headers()`)

To fetch fresh data on every `fetch` request, use the `cache: 'no-store'`
option.

    
    
    fetch('https://...', { cache: 'no-store' });

To minimize client-server waterfalls, we recommend this pattern to fetch data
in parallel:

    
    
    import Albums from './albums';
     
    async function getArtist(username: string) {
      const res = await fetch(`https://api.example.com/artist/${username}`);
      return res.json();
    }
     
    async function getArtistAlbums(username: string) {
      const res = await fetch(`https://api.example.com/artist/${username}/albums`);
      return res.json();
    }
     
    export default async function Page({
      params: { username },
    }: {
      params: { username: string };
    }) {
      // Initiate both requests in parallel
      const artistData = getArtist(username);
      const albumsData = getArtistAlbums(username);
     
      // Wait for the promises to resolve
      const [artist, albums] = await Promise.all([artistData, albumsData]);
     
      return (
        <>
          <h1>{artist.name}</h1>
          <Albums list={albums}></Albums>
        </>
      );
    }

By starting the fetch prior to calling `await` in the Server Component, each
request can eagerly start to fetch requests at the same time. This sets the
components up so you can avoid waterfalls.

We can save time by initiating both requests in parallel, however, the user
won't see the rendered result until both promises are resolved.

To improve the user experience, you can add a suspense boundary to break up
the rendering work and show part of the result as soon as possible:

    
    
    import { getArtist, getArtistAlbums, type Album } from './api';
     
    export default async function Page({
      params: { username },
    }: {
      params: { username: string };
    }) {
      // Initiate both requests in parallel
      const artistData = getArtist(username);
      const albumData = getArtistAlbums(username);
     
      // Wait for the artist's promise to resolve first
      const artist = await artistData;
     
      return (
        <>
          <h1>{artist.name}</h1>
          {/* Send the artist information first,
              and wrap albums in a suspense boundary */}
          <Suspense fallback={<div>Loading...</div>}>
            {/* @ts-expect-error Async Server Component */}
            <Albums promise={albumData} />
          </Suspense>
        </>
      );
    }
     
    // Albums Component
    async function Albums({ promise }: { promise: Promise<Album[]> }) {
      // Wait for the albums promise to resolve
      const albums = await promise;
     
      return (
        <ul>
          {albums.map((album) => (
            <li key={album.id}>{album.name}</li>
          ))}
        </ul>
      );
    }

Take a look at the preloading pattern for more information on improving
components structure.

To fetch data sequentially, you can `fetch` directly inside the component that
needs it, or you can `await` the result of `fetch` inside the component that
needs it:

    
    
    // ...
     
    async function Playlists({ artistID }: { artistID: string }) {
      // Wait for the playlists
      const playlists = await getArtistPlaylists(artistID);
     
      return (
        <ul>
          {playlists.map((playlist) => (
            <li key={playlist.id}>{playlist.name}</li>
          ))}
        </ul>
      );
    }
     
    export default async function Page({
      params: { username },
    }: {
      params: { username: string };
    }) {
      // Wait for the artist
      const artist = await getArtist(username);
     
      return (
        <>
          <h1>{artist.name}</h1>
          <Suspense fallback={<div>Loading...</div>}>
            {/* @ts-expect-error Async Server Component */}
            <Playlists artistID={artist.id} />
          </Suspense>
        </>
      );
    }

By fetching data inside the component, each fetch request and nested segment
in the route cannot start fetching data and rendering until the previous
request or segment has completed.

By fetching data in a layout, rendering for all route segments beneath it can
only start once the data has finished loading.

In the `pages` directory, pages using server-rendering would show the browser
loading spinner until `getServerSideProps` had finished, then render the React
component for that page. This can be described as "all or nothing" data
fetching. Either you had the entire data for your page, or none.

In the `app` directory, you have additional options to explore:

  1. First, you can use `loading.js` to show an instant loading state from the server while streaming in the result from your data fetching function.
  2. Second, you can move data fetching _lower_ in the component tree to only block rendering for the parts of the page that need it. For example, moving data fetching to a specific component rather than fetching it at the root layout.

Whenever possible, it's best to fetch data in the segment that uses it. This
also allows you to show a loading state for only the part of the page that is
loading, and not the entire page.

You might not always have the ability to use and configure `fetch` requests
directly if you're using a third-party library such as an ORM or database
client.

In cases where you cannot use `fetch` but still want to control the caching or
revalidating behavior of a layout or page, you can rely on the default caching
behavior of the segment or use the segment cache configuration.

Any data fetching libraries that do not use `fetch` directly **will not**
affect caching of a route, and will be static or dynamic depending on the
route segment.

If the segment is static (default), the output of the request will be cached
and revalidated (if configured) alongside the rest of the segment. If the
segment is dynamic, the output of the request will _not_ be cached and will be
re-fetched on every request when the segment is rendered.

> **Good to know:** Dynamic functions like `cookies()` and `headers()` will
> make the route segment dynamic.

As a temporary solution, until the caching behavior of third-party queries can
be configured, you can use segment configuration to customize the cache
behavior of the entire segment.

    
    
    import prisma from './lib/prisma';
     
    export const revalidate = 3600; // revalidate every hour
     
    async function getPosts() {
      const posts = await prisma.post.findMany();
      return posts;
    }
     
    export default async function Page() {
      const posts = await getPosts();
      // ...
    }





# Caching Data

Next.js has built-in support for caching data, both on a per-request basis
(recommended) or for an entire route segment.

![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Flight%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Fdark%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)

By default, all `fetch()` requests are cached and deduplicated automatically.
This means that if you make the same request twice, the second request will
reuse the result from the first request.

    
    
    async function getComments() {
      const res = await fetch('https://...'); // The result is cached
      return res.json();
    }
     
    // This function is called twice, but the result is only fetched once
    const comments = await getComments(); // cache MISS
     
    // The second call could be anywhere in your application
    const comments = await getComments(); // cache HIT

Requests are **not** cached if:

  * Dynamic methods (`next/headers`, `export const POST`, or similar) are used and the fetch is a `POST` request (or uses `Authorization` or `cookie` headers)
  * `fetchCache` is configured to skip cache by default
  * `revalidate: 0` or `cache: 'no-store'` is configured on individual `fetch`

Requests made using `fetch` can specify a `revalidate` option to control the
revalidation frequency of the request.

    
    
    export default async function Page() {
      // revalidate this data every 10 seconds at most
      const res = await fetch('https://...', { next: { revalidate: 10 } });
      const data = res.json();
      // ...
    }

React allows you to `cache()` and deduplicate requests, memoizing the result
of the wrapped function call. The same function called with the same arguments
will reuse a cached value instead of re-running the function.

    
    
    import { cache } from 'react';
     
    export const getUser = cache(async (id: string) => {
      const user = await db.user.findUnique({ id });
      return user;
    });
    
    
    import { getUser } from '@utils/getUser';
     
    export default async function UserLayout({ params: { id } }) {
      const user = await getUser(id);
      // ...
    }
    
    
    import { getUser } from '@utils/getUser';
     
    export default async function Page({
      params: { id },
    }: {
      params: { id: string };
    }) {
      const user = await getUser(id);
      // ...
    }

Although the `getUser()` function is called twice in the example above, only
one query will be made to the database. This is because `getUser()` is wrapped
in `cache()`, so the second request can reuse the result from the first
request.

> **Good to know:**
>
>   * `fetch()` caches requests automatically, so you don't need to wrap
> functions that use `fetch()` with `cache()`. See automatic request deduping
> for more information.
>   * In this new model, we recommend **fetching data directly in the
> component that needs it** , even if you're requesting the same data in
> multiple components, rather than passing the data between components as
> props.
>   * We recommend using the `server-only` package to make sure server data
> fetching functions are never used on the client.
>

`POST` requests are automatically deduplicated when using `fetch` – unless
they are inside of `POST` Route Handler or come after reading
`headers()`/`cookies()`. For example, if you are using GraphQL and `POST`
requests in the above cases, you can use `cache` to deduplicate requests. The
`cache` arguments must be flat and only include primitives. Deep objects won't
match for deduplication.

    
    
    import { cache } from 'react';
     
    export const getUser = cache(async (id: string) => {
      const res = await fetch('...', { method: 'POST', body: '...' });
      // ...
    });

As a pattern, we suggest optionally exposing a `preload()` export in utilities
or components that do data fetching.

    
    
    import { getUser } from '@utils/getUser';
     
    export const preload = (id: string) => {
      // void evaluates the given expression and returns undefined
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void
      void getUser(id);
    };
    export default async function User({ id }: { id: string }) {
      const result = await getUser(id);
      // ...
    }

By calling `preload`, you can eagerly start fetching data you're likely going
to need.

    
    
    import User, { preload } from '@components/User';
     
    export default async function Page({
      params: { id },
    }: {
      params: { id: string };
    }) {
      preload(id); // starting loading the user data now
      const condition = await fetchCondition();
      return condition ? <User id={id} /> : null;
    }

> **Good to know** :
>
>   * The `preload()` function can have any name. It's a pattern, not an API.
>   * This pattern is completely optional and something you can use to
> optimize on a case-by-case basis. This pattern is a further optimization on
> top of parallel data fetching. Now you don't have to pass promises down as
> props and can instead rely on the preload pattern.
>

You can combine the `cache` function, the `preload` pattern, and the `server-
only` package to create a data fetching utility that can be used throughout
your app.

    
    
    import { cache } from 'react';
    import 'server-only';
     
    export const preload = (id: string) => {
      void getUser(id);
    };
     
    export const getUser = cache(async (id: string) => {
      // ...
    });

With this approach, you can eagerly fetch data, cache responses, and guarantee
that this data fetching only happens on the server.

The `getUser.ts` exports can be used by layouts, pages, or components to give
them control over when a user's data is fetched.

> **Note:** We recommend using per-request caching for improved granularity
> and control over caching.

Segment-level caching allows you to cache and revalidate data used in route
segments.

This mechanism allows different segments of a path to control the cache
lifetime of the entire route. Each `page.tsx` and `layout.tsx` in the route
hierarchy can export a `revalidate` value that sets the revalidation time for
the route.

    
    
    export const revalidate = 60; // revalidate this segment every 60 seconds

> **Good to know:**
>
>   * If a page, layout, and fetch request inside components all specify a
> `revalidate` frequency, the lowest value of the three will be used.
>   * Advanced: You can set `fetchCache` to `'only-cache'` or `'force-cache'`
> to ensure that all `fetch` requests opt into caching but the revalidation
> frequency might still be lowered by individual `fetch` requests. See
> `fetchCache` for more information.
>





# Revalidating Data

Next.js allows you to update specific static routes **without needing to
rebuild your entire site**. Revalidation (also known as Incremental Static
Regeneration) allows you to retain the benefits of static while scaling to
millions of pages.

There are two types of revalidation in Next.js:

  * **Background** : Revalidates the data at a specific time interval.
  * **On-demand** : Revalidates the data based on an event such as an update.

To revalidate cached data at a specific interval, you can use the
`next.revalidate` option in `fetch()` to set the `cache` lifetime of a
resource (in seconds).

    
    
    fetch('https://...', { next: { revalidate: 60 } });

If you want to revalidate data that does not use `fetch` (i.e. using an
external package or query builder), you can use the route segment config.

    
    
    export const revalidate = 60; // revalidate this page every 60 seconds

In addition to `fetch`, you can also revalidate data using `cache`.

  1. When a request is made to the route that was statically rendered at build time, it will initially show the cached data.
  2. Any requests to the route after the initial request and before 60 seconds are also cached and instantaneous.
  3. After the 60-second window, the next request will still show the cached (stale) data.
  4. Next.js will trigger a regeneration of the data in the background.
  5. Once the route generates successfully, Next.js will invalidate the cache and show the updated route. If the background regeneration fails, the old data would still be unaltered.

When a request is made to a route segment that hasn’t been generated, Next.js
will dynamically render the route on the first request. Future requests will
serve the static route segments from the cache.

> **Note** : Check if your upstream data provider has caching enabled by
> default. You might need to disable (e.g. `useCdn: false`), otherwise a
> revalidation won't be able to pull fresh data to update the ISR cache.
> Caching can occur at a CDN (for an endpoint being requested) when it returns
> the `Cache-Control` header. ISR on Vercel persists the cache globally and
> handles rollbacks.

If you set a `revalidate` time of `60`, all visitors will see the same
generated version of your site for one minute. The only way to invalidate the
cache is if someone visits the page after the minute has passed.

The Next.js App Router supports revalidating content on-demand based on a
route or cache tag. This allows you to manually purge the Next.js cache for
specific fetches, making it easier to update your site when:

  * Content from your headless CMS is created or updated.
  * Ecommerce metadata changes (price, description, category, reviews, etc).

Data can be revalidated on-demand by path (`revalidatePath`) or by cache tag
(`revalidateTag`).

For example, the following `fetch` adds the cache tag `collection`:

    
    
    export default async function Page() {
      const res = await fetch('https://...', { next: { tags: ['collection'] } });
      const data = await res.json();
      // ...
    }

This cached data can then be revalidated on-demand by calling `revalidateTag`
in a Route Handler.

    
    
    import { NextRequest, NextResponse } from 'next/server';
    import { revalidateTag } from 'next/cache';
     
    export async function GET(request: NextRequest) {
      const tag = request.nextUrl.searchParams.get('tag');
      revalidateTag(tag);
      return NextResponse.json({ revalidated: true, now: Date.now() });
    }

If an error is thrown while attempting to revalidate data, the last
successfully generated data will continue to be served from the cache. On the
next subsequent request, Next.js will retry revalidating the data.





# Server Actions

Server Actions are an **alpha** feature in Next.js, built on top of React
Actions. They enable server-side data mutations, reduced client-side
JavaScript, and progressively enhanced forms.

    
    
    import { cookies } from 'next/headers';
     
    export default function AddToCart({ productId }) {
      async function addItem(data) {
        'use server';
     
        const cartId = cookies().get('cartId')?.value;
        await saveToDb({ cartId, data });
      }
     
      return (
        <form action={addItem}>
          <button type="submit">Add to Cart</button>
        </form>
      );
    }

You can enable Server Actions in your Next.js project by enabling the
**experimental** `serverActions` flag.

    
    
    module.exports = {
      experimental: {
        serverActions: true,
      },
    };

Create a Server Action by defining an asynchronous function with the `"use
server"` directive at the top of the function body. This function should have
**serializable arguments** and a **serializable return value** based on the
React Server Components protocol.

    
    
    async function myAction() {
      'use server';
      // ...
    }

You can also use a top-level `"use server"` directive on top of a file. This
can be useful if you have a single file that exports multiple Server Actions,
and it is **required** if you're importing a Server Action in a Client
Component.

    
    
    'use server';
     
    export async function myAction() {
      // ...
    }

> **Note:** When using a top-level `"use server"` directive, all exports will
> be considered Server Actions.

You can invoke Server Actions using the following methods:

  * Using `action`: React's `action` prop allows invoking a Server Action on a `<form>` element.
  * Using `formAction`: React's `formAction` prop allows handling `<button>`, `<input type="submit">`, and `<input type="image">` elements in a `<form>`.
  * Custom Invocation with `startTransition`: Invoke Server Actions without using `action` or `formAction` by using `startTransition`. This method **disablesProgressive Enhancement**.

You can use React's `action` prop to invoke a Server Action on a `form`
element. Server Actions passed with the action prop act as asynchronous side
effects in response to user interaction.

    
    
    export default function AddToCart({ productId }) {
      async function addItem(data) {
        'use server';
     
        const cartId = cookies().get('cartId')?.value;
        await saveToDb({ cartId, data });
      }
     
      return (
        <form action={addItem}>
          <button type="submit">Add to Cart</button>
        </form>
      );
    }

> **Note:** An `action` is similar to the HTML primitive `action`

You can use `formAction` prop to handle **Form Actions** on elements such as
`button`, `input type="submit"`, and `input type="image"`. The `formAction`
prop takes presedence over the form's `action`.

    
    
    export default function Form() {
      async function handleSubmit() {
        'use server';
        // ...
      }
     
      async function submitImage() {
        'use server';
        // ...
      }
     
      return (
        <form action={handleSubmit}>
          <input type="text" name="name" />
          <input type="image" formAction={submitImage} />
          <button type="submit">Submit</button>
        </form>
      );
    }

> **Note:** A `formAction` is the HTML primitive `formaction`. React now
> allows you to pass functions to this attribute.

You can also invoke Server Actions without using `action` or `formAction`. You
can achieve this by using `startTransition` provided by the `useTransition`
hook, which can be useful if you want to use Server Actions outside of forms,
buttons, or inputs.

> **Note:** Using `startTransition` disables the out-of-the-box Progressive
> Enhancement.
    
    
    'use client';
     
    import { useTransition } from 'react';
    import { addItem } from '../actions';
     
    function ExampleClientComponent({ id }) {
      let [isPending, startTransition] = useTransition();
     
      return (
        <button onClick={() => startTransition(() => addItem(id))}>
          Add To Cart
        </button>
      );
    }
    
    
    'use server';
     
    export async function addItem(id) {
      await addItemToDb(id);
      revalidatePath(`/product/${id}`);
    }

If you aren't doing Server Mutations, you can directly pass the function as a
prop like any other function.

    
    
    import kv from '@vercel/kv';
    import LikeButton from './like-button';
     
    export default function Page({ params }: { params: { id: string } }) {
      async function increment() {
        'use server';
        await kv.incr(`post:id:${params.id}`);
      }
     
      return <LikeButton increment={increment} />;
    }
    
    
    'use client';
     
    export default function LikeButton({
      increment,
    }: {
      increment: () => Promise<void>;
    }) {
      return (
        <button
          onClick={async () => {
            await increment();
          }}
        >
          Like
        </button>
      );
    }

The experimental `useOptimistic` hook provides a way to implement optimistic
updates in your application. Optimistic updates are a technique that enhances
user experience by making the app appear more responsive.

When a Server Action is invoked, the UI is updated immediately to reflect the
expected outcome, instead of waiting for the Server Action's response.

    
    
    'use client';
     
    import { experimental_useOptimistic as useOptimistic } from 'react';
    import { send } from './actions.js';
     
    export function Thread({ messages }) {
      const [optimisticMessages, addOptimisticMessage] = useOptimistic(
        messages,
        (state, newMessage) => [...state, { message: newMessage, sending: true }],
      );
      const formRef = useRef();
     
      return (
        <div>
          {optimisticMessages.map((m) => (
            <div>
              {m.message}
              {m.sending ? 'Sending...' : ''}
            </div>
          ))}
          <form
            action={async (formData) => {
              const message = formData.get('message');
              formRef.current.reset();
              addOptimisticMessage(message);
              await send(message);
            }}
            ref={formRef}
          >
            <input type="text" name="message" />
          </form>
        </div>
      );
    }

The **experimental** `useFormStatus` hook can be used within Form Actions, and
provides the `pending` property.

    
    
    import { experimental_useFormStatus as useFormStatus } from 'react-dom';
     
    function Submit() {
      const { pending } = useFormStatus();
     
      return (
        <input
          type="submit"
          className={pending ? 'button-pending' : 'button-normal'}
          disabled={pending}
        >
          Submit
        </input>
      );
    }

Progressive Enhancement allows a `<form>` to function properly without
JavaScript, or with JavaScript disabled. This allows users to interact with
the form and submit data even if the JavaScript for the form hasn't been
loaded yet or if it fails to load.

Both Server Form Actions and Client Form Actions support Progressive
Enhancement, using one of two strategies:

  * If a **Server Action** is passed directly to a `<form>`, the form is interactive **even if JavaScript is disabled**.
  * If a **Client Action** is passed to a `<form>`, the form is still interactive, but the action will be placed in a queue until the form has hydrated. The `<form>` is prioritized with Selective Hydration, so it happens quickly.

    
    
    'use client';
     
    import { useState } from 'react';
    import { handleSubmit } from './actions.js';
     
    export default function ExampleClientComponent({ myAction }) {
      const [input, setInput] = useState();
     
      return (
        <form action={handleSubmit} onChange={(e) => setInput(e.target.value)}>
          {/* ... */}
        </form>
      );
    }

In both cases, the form is interactive before hydration occurs. Although
Server Actions have the additional benefit of not relying on client
JavaScript, you can still compose additional behavior with Client Actions
where desired without sacrificing interactivity.

Server Actions **cannot** be _defined_ within Client Components, but they can
be _imported_. To use Server Actions in Client Components, you can import the
action from a file containing a top-level `"use server"` directive.

    
    
    'use server';
     
    export async function addItem() {
      // ...
    }
    
    
    'use client';
     
    import { useTransition } from 'react';
    import { addItem } from '../actions';
     
    function ExampleClientComponent({ id }) {
      let [isPending, startTransition] = useTransition();
     
      return (
        <button onClick={() => startTransition(() => addItem(id))}>
          Add To Cart
        </button>
      );
    }

Although importing Server Actions is recommended, in some cases you might want
to pass down a Server Action to a Client Component as a prop.

For example, you might want to use a dynamically generated value within the
action. In that case, passing a Server Action down as a prop might be a viable
solution.

    
    
    import { ExampleClientComponent } from './components/example-client-component.js';
     
    function ExampleServerComponent({ id }) {
      async function updateItem(data) {
        'use server';
        modifyItem({ id, data });
      }
     
      return <ExampleClientComponent updateItem={updateItem} />;
    }
    
    
    'use client';
     
    function ExampleClientComponent({ updateItem }) {
      async function action(formData: FormData) {
        await updateItem(formData);
      }
     
      return (
        <form action={action}>
          <input type="text" name="name" />
          <button type="submit">Update Item</button>
        </form>
      );
    }

Server Actions can be used to revalidate data on-demand by path
(`revalidatePath`) or by cache tag (`revalidateTag`).

    
    
    import { revalidateTag } from 'next/cache';
     
    async function revalidate() {
      'use server';
      revalidateTag('blog-posts');
    }

The data passed to a Server Action can be validated or sanitized before
invoking the action. For example, you can create a wrapper function that
receives the action as its argument, and returns a function that invokes the
action if it's valid.

    
    
    'use server';
     
    import { withValidate } from 'lib/form-validation';
     
    export const action = withValidate((data) => {
      // ...
    });
    
    
    export function withValidate(action) {
      return (formData: FormData) => {
        'use server';
     
        const isValidData = verifyData(formData);
     
        if (!isValidData) {
          throw new Error('Invalid input.');
        }
     
        const data = process(formData);
        return action(data);
      };
    }

You can read incoming request headers such as `cookies` and `headers` within a
Server Action.

    
    
    import { cookies } from 'next/headers';
     
    async function addItem(data) {
      'use server';
     
      const cartId = cookies().get('cartId')?.value;
     
      await saveToDb({ cartId, data });
    }

Additionally, you can modify cookies within a Server Action.

    
    
    import { cookies } from 'next/headers';
     
    async function create(data) {
      'use server';
     
      const cart = await createCart():
      cookies().set('cartId', cart.id)
      // or
      cookies().set({
        name: 'cartId',
        value: cart.id,
        httpOnly: true,
        path: '/'
      })
    }

Performs asynchronous side effects in response to user interaction, with
built-in solutions for error handling and optimistic updates. Similar to the
HTML primitive `action`.

Actions integrated into the web standard `<form>` API, and enable out-of-the-
box progressive enhancement and loading states. Similar to the HTML primitive
`formaction`.

Functions that run on the server, but can be called on the client.

Server Functions called as an action.

Server Actions that mutates your data and calls `redirect`, `revalidatePath`,
or `revalidateTag`.





Using App Router

Features available in /app





# CSS Modules

Next.js has built-in support for CSS Modules using the `.module.css`
extension.

CSS Modules locally scope CSS by automatically creating a unique class name.
This allows you to use the same class name in different files without worrying
about collisions. This behavior makes CSS Modules the ideal way to include
component-level CSS.

CSS Modules can be imported into any file inside the `app` directory:

    
    
    import styles from './styles.module.css';
     
    export default function DashboardLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return <section className={styles.dashboard}>{children}</section>;
    }
    
    
    .dashboard {
      padding: 24px;
    }

CSS Modules are an _optional feature_ and are **only enabled for files with
the`.module.css` extension**. Regular `<link>` stylesheets and global CSS
files are still supported.

In production, all CSS Module files will be automatically concatenated into
**many minified and code-split** `.css` files. These `.css` files represent
hot execution paths in your application, ensuring the minimal amount of CSS is
loaded for your application to paint.

Global styles can be imported into any layout, page, or component inside the
`app` directory.

> **Good to know:** This is different from the `pages` directory, where you
> can only import global styles inside the `_app.js` file.

For example, consider a stylesheet named `app/global.css`:

    
    
    body {
      padding: 20px 20px 60px;
      max-width: 680px;
      margin: 0 auto;
    }

Inside the root layout (`app/layout.js`), import the `global.css` stylesheet
to apply the styles to every route in your application:

    
    
    // These styles apply to every route in the application
    import './global.css';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Stylesheets published by external packages can be imported anywhere in the
`app` directory, including colocated components:

    
    
    import 'bootstrap/dist/css/bootstrap.css';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body className="container">{children}</body>
        </html>
      );
    }

> **Note:** External stylesheets must be directly imported from an npm package
> or downloaded and colocated with your codebase. You cannot use `<link
> rel="stylesheet" />`.

Next.js includes additional features to improve the authoring experience of
adding styles:

  * When running locally with `next dev`, local stylesheets (either global or CSS modules) will take advantage of Fast Refresh to instantly reflect changes as edits are saved.
  * When building for production with `next build`, CSS files will be bundled into fewer minified `.css` files to reduce the number of network requests needed to retrieve styles.
  * If you disable JavaScript, styles will still be loaded in the production build (`next start`). However, JavaScript is still required for `next dev` to enable Fast Refresh.





# Tailwind CSS

Tailwind CSS is a utility-first CSS framework that works exceptionally well
with Next.js.

Install the Tailwind CSS packages and run the `init` command to generate both
the `tailwind.config.js` and `postcss.config.js` files:

    
    
    npm install -D tailwindcss postcss autoprefixer
    npx tailwindcss init -p

Inside `tailwind.config.js`, add paths to the files that will use Tailwind CSS
class names:

    
    
    /** @type {import('tailwindcss').Config} */
    module.exports = {
      content: [
        './app/**/*.{js,ts,jsx,tsx,mdx}', // Note the addition of the `app` directory.
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
     
        // Or if using `src` directory:
        './src/**/*.{js,ts,jsx,tsx,mdx}',
      ],
      theme: {
        extend: {},
      },
      plugins: [],
    };

You do not need to modify `postcss.config.js`.

Add the Tailwind CSS directives that Tailwind will use to inject its generated
styles to a Global Stylesheet in your application, for example:

    
    
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

Inside the root layout (`app/layout.tsx`), import the `globals.css` stylesheet
to apply the styles to every route in your application.

    
    
    import type { Metadata } from 'next';
     
    // These styles apply to every route in the application
    import './globals.css';
     
    export const metadata: Metadata = {
      title: 'Create Next App',
      description: 'Generated by create next app',
    };
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

After installing Tailwind CSS and adding the global styles, you can use
Tailwind's utility classes in your application.

    
    
    export default function Page() {
      return <h1 className="text-3xl font-bold underline">Hello, Next.js!</h1>;
    }

As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.





# CSS-in-JS

> **Warning:** CSS-in-JS libraries which require runtime JavaScript are not
> currently supported in Server Components. Using CSS-in-JS with newer React
> features like Server Components and Streaming requires library authors to
> support the latest version of React, including concurrent rendering.
>
> We're working with the React team on upstream APIs to handle CSS and
> JavaScript assets with support for React Server Components and streaming
> architecture.

The following libraries are supported in Client Components in the `app`
directory:

The following are currently working on support:

> **Note:** We're testing out different CSS-in-JS libraries and we'll be
> adding more examples for libraries that support React 18 features and/or the
> `app` directory.

If you want to style Server Components, we recommend using CSS Modules or
other solutions that output CSS files, like PostCSS or Tailwind CSS.

Configuring CSS-in-JS is a three-step opt-in process that involves:

  1. A **style registry** to collect all CSS rules in a render.
  2. The new `useServerInsertedHTML` hook to inject rules before any content that might use them.
  3. A Client Component that wraps your app with the style registry during initial server-side rendering.

Using `styled-jsx` in Client Components requires using `v5.1.0`. First, create
a new registry:

    
    
    'use client';
     
    import React, { useState } from 'react';
    import { useServerInsertedHTML } from 'next/navigation';
    import { StyleRegistry, createStyleRegistry } from 'styled-jsx';
     
    export default function StyledJsxRegistry({
      children,
    }: {
      children: React.ReactNode;
    }) {
      // Only create stylesheet once with lazy initial state
      // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
      const [jsxStyleRegistry] = useState(() => createStyleRegistry());
     
      useServerInsertedHTML(() => {
        const styles = jsxStyleRegistry.styles();
        jsxStyleRegistry.flush();
        return <>{styles}</>;
      });
     
      return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>;
    }

Then, wrap your root layout with the registry:

    
    
    import StyledJsxRegistry from './registry';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html>
          <body>
            <StyledJsxRegistry>{children}</StyledJsxRegistry>
          </body>
        </html>
      );
    }

View an example here.

Below is an example of how to configure `styled-components@v6.0.0-rc.1` or
greater:

First, use the `styled-components` API to create a global registry component
to collect all CSS style rules generated during a render, and a function to
return those rules. Then use the `useServerInsertedHTML` hook to inject the
styles collected in the registry into the `<head>` HTML tag in the root
layout.

    
    
    'use client';
     
    import React, { useState } from 'react';
    import { useServerInsertedHTML } from 'next/navigation';
    import { ServerStyleSheet, StyleSheetManager } from 'styled-components';
     
    export default function StyledComponentsRegistry({
      children,
    }: {
      children: React.ReactNode;
    }) {
      // Only create stylesheet once with lazy initial state
      // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
      const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());
     
      useServerInsertedHTML(() => {
        const styles = styledComponentsStyleSheet.getStyleElement();
        styledComponentsStyleSheet.instance.clearTag();
        return <>{styles}</>;
      });
     
      if (typeof window !== 'undefined') return <>{children}</>;
     
      return (
        <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
          {children}
        </StyleSheetManager>
      );
    }

Wrap the `children` of the root layout with the style registry component:

    
    
    import StyledComponentsRegistry from './lib/registry';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html>
          <body>
            <StyledComponentsRegistry>{children}</StyledComponentsRegistry>
          </body>
        </html>
      );
    }

View an example here.

> **Good to know:**
>
>   * During server rendering, styles will be extracted to a global registry
> and flushed to the `<head>` of your HTML. This ensures the style rules are
> placed before any content that might use them. In the future, we may use an
> upcoming React feature to determine where to inject the styles.
>   * During streaming, styles from each chunk will be collected and appended
> to existing styles. After client-side hydration is complete, `styled-
> components` will take over as usual and inject any further dynamic styles.
>   * We specifically use a Client Component at the top level of the tree for
> the style registry because it's more efficient to extract CSS rules this
> way. It avoids re-generating styles on subsequent server renders, and
> prevents them from being sent in the Server Component payload.
>





> **Good to know** :
>
> Sass supports two different syntax, each with their own extension. The
> `.scss` extension requires you use the SCSS syntax, while the `.sass`
> extension requires you use the Indented Syntax ("Sass").
>
> If you're not sure which to choose, start with the `.scss` extension which
> is a superset of CSS, and doesn't require you learn the Indented Syntax
> ("Sass").
    
    
    const path = require('path');
     
    module.exports = {
      sassOptions: {
        includePaths: [path.join(__dirname, 'styles')],
      },
    };

Next.js supports Sass variables exported from CSS Module files.





# Optimizations

Next.js comes with a variety of built-in optimizations designed to improve
your application's speed and Core Web Vitals. This guide will cover the
optimizations you can leverage to enhance your user experience.

Built-in components abstract away the complexity of implementing common UI
optimizations. These components are:

  * **Images** : Built on the native `<img>` element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.
  * **Link** : Built on the native `<a>` tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.
  * **Scripts** : Built on the native `<script>` tags. The Script Component gives you control over loading and execution of third-party scripts.

Metadata helps search engines understand your content better (which can result
in better SEO), and allows you to customize how your content is presented on
social media, helping you create a more engaging and consistent user
experience across various platforms.

The Metadata API in Next.js allows you to modify the `<head>` element of a
page. You can configure metadata in two ways:

  * **Config-based Metadata** : Export a static metadata object or a dynamic generateMetadata function in a `layout.js` or `page.js` file.
  * **File-based Metadata** : Add static or dynamically generated special files to route segments.

Additionally, you can create dynamic Open Graph Images using JSX and CSS with
imageResponse constructor.

Next.js `/public` folder can be used to serve static assets like images,
fonts, and other files. Files inside `/public` can also be cached by CDN
providers so that they are delivered efficiently.

For large applications, Next.js integrates with popular analytics and
monitoring tools to help you understand how your application is performing.
Learn more in the , OpenTelemetry, and Instrumentation guides.





# Image Optimization

 **Examples**

The Next.js Image component extends the HTML `<img>` element with:

  * **Size Optimization:** Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
  * **Visual Stability:** Prevent layout shift automatically when images are loading.
  * **Faster Page Loads:** Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
  * **Asset Flexibility:** On-demand image resizing, even for images stored on remote servers

    
    
    import Image from 'next/image';

You can then define the `src` for your image (either local or remote).

To use a local image, `import` your `.jpg`, `.png`, or `.webp` image files.

Next.js will automatically determine the `width` and `height` of your image
based on the imported file. These values are used to prevent Cumulative Layout
Shift while your image is loading.

    
    
    import Image from 'next/image';
    import profilePic from './me.png';
     
    export default function Page() {
      return (
        <Image
          src={profilePic}
          alt="Picture of the author"
          // width={500} automatically provided
          // height={500} automatically provided
          // blurDataURL="data:..." automatically provided
          // placeholder="blur" // Optional blur-up while loading
        />
      );
    }

> **Warning:** Dynamic `await import()` or `require()` are _not_ supported.
> The `import` must be static so it can be analyzed at build time.

To use a remote image, the `src` property should be a URL string.

Since Next.js does not have access to remote files during the build process,
you'll need to provide the `width`, `height` and optional `blurDataURL` props
manually.

The `width` and `height` attributes are used to infer the correct aspect ratio
of image and avoid layout shift from the image loading in. The `width` and
`height` do _not_ determine the rendered size of the image file. Learn more
about Image Sizing.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <Image
          src="https://s3.amazonaws.com/my-bucket/profile.png"
          alt="Picture of the author"
          width={500}
          height={500}
        />
      );
    }

To safely allow optimizing images, define a list of supported URL patterns in
`next.config.js`. Be as specific as possible to prevent malicious usage. For
example, the following configuration will only allow images from a specific
AWS S3 bucket:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 's3.amazonaws.com',
            port: '',
            pathname: '/my-bucket/**',
          },
        ],
      },
    };

Learn more about `remotePatterns` configuration. If you want to use relative
URLs for the image `src`, use a `loader`.

Sometimes you may want to optimize a remote image, but still use the built-in
Next.js Image Optimization API. To do this, leave the `loader` at its default
setting and enter an absolute URL for the Image `src` prop.

To protect your application from malicious users, you must define a list of
remote hostnames you intend to use with the `next/image` component.

> Learn more about `remotePatterns` configuration.

Note that in the example earlier, a partial URL (`"/me.png"`) is provided for
a remote image. This is possible because of the loader architecture.

A loader is a function that generates the URLs for your image. It modifies the
provided `src`, and generates multiple URLs to request the image at different
sizes. These multiple URLs are used in the automatic srcset generation, so
that visitors to your site will be served an image that is the right size for
their viewport.

The default loader for Next.js applications uses the built-in Image
Optimization API, which optimizes images from anywhere on the web, and then
serves them directly from the Next.js web server. If you would like to serve
your images directly from a CDN or image server, you can write your own loader
function with a few lines of JavaScript.

You can define a loader per-image with the `loader` prop, or at the
application level with the `loaderFile` configuration.

You should add the `priority` property to the image that will be the Largest
Contentful Paint (LCP) element for each page. Doing so allows Next.js to
specially prioritize the image for loading (e.g. through preload tags or
priority hints), leading to a meaningful boost in LCP.

The LCP element is typically the largest image or text block visible within
the viewport of the page. When you run `next dev`, you'll see a console
warning if the LCP element is an `<Image>` without the `priority` property.

Once you've identified the LCP image, you can add the property like this:

    
    
    import Image from 'next/image';
    import profilePic from '../public/me.png';
     
    export default function Page() {
      return <Image src={profilePic} alt="Picture of the author" priority />;
    }

See more about priority in the `next/image` component documentation.

One of the ways that images most commonly hurt performance is through _layout
shift_ , where the image pushes other elements around on the page as it loads
in. This performance problem is so annoying to users that it has its own Core
Web Vital, called Cumulative Layout Shift. The way to avoid image-based layout
shifts is to always size your images. This allows the browser to reserve
precisely enough space for the image before it loads.

Because `next/image` is designed to guarantee good performance results, it
cannot be used in a way that will contribute to layout shift, and **must** be
sized in one of three ways:

  1. Automatically, using a static import
  2. Explicitly, by including a `width` and `height` property
  3. Implicitly, by using fill which causes the image to expand to fill its parent element.

> **What if I don't know the size of my images?**
>
> If you are accessing images from a source without knowledge of the images'
> sizes, there are several things you can do:
>
> **Use`fill`**
>
> The `fill` prop allows your image to be sized by its parent element.
> Consider using CSS to give the image's parent element space on the page
> along `sizes` prop to match any media query break points. You can also use
> `object-fit` with `fill`, `contain`, or `cover`, and `object-position` to
> define how the image should occupy that space.
>
> **Normalize your images**
>
> If you're serving images from a source that you control, consider modifying
> your image pipeline to normalize the images to a specific size.
>
> **Modify your API calls**
>
> If your application is retrieving image URLs using an API call (such as to a
> CMS), you may be able to modify the API call to return the image dimensions
> along with the URL.

If none of the suggested methods works for sizing your images, the
`next/image` component is designed to work well on a page alongside standard
`<img>` elements.

Styling the Image component is similar to styling a normal `<img>` element,
but there are a few guidelines to keep in mind:

  * Use `className` or `style`, not `styled-jsx`. 
    * In most cases, we recommend using the `className` prop. This can be an imported CSS Module, a global stylesheet, etc.
    * You can also use the `style` prop to assign inline styles.
    * You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as `global`).
  * When using `fill`, the parent element must have `position: relative`
    * This is necessary for the proper rendering of the image element in that layout mode.
  * When using `fill`, the parent element must have `display: block`
    * This is the default for `<div>` elements but should be specified otherwise.

For examples, see the Image Component Demo.

For examples of the Image component used with the various styles, see the
Image Component Demo.

**View all properties available to the`next/image` component.**

The `next/image` component and Next.js Image Optimization API can be
configured in the `next.config.js` file. These configurations allow you to
enable remote images, define custom image breakpoints, change caching behavior
and more.

**Read the full image configuration documentation for more information.**





# Font Optimization

 **`next/font`** will automatically optimize your fonts (including custom
fonts) and remove external network requests for improved privacy and
performance.

> **🎥 Watch:** Learn more about how to use `next/font` → YouTube (6 minutes).

`next/font` includes **built-in automatic self-hosting** for _any_ font file.
This means you can optimally load web fonts with zero layout shift, thanks to
the underlying CSS `size-adjust` property used.

This new font system also allows you to conveniently use all Google Fonts with
performance and privacy in mind. CSS and font files are downloaded at build
time and self-hosted with the rest of your static assets. **No requests are
sent to Google by the browser.**

Automatically self-host any Google Font. Fonts are included in the deployment
and served from the same domain as your deployment. **No requests are sent to
Google by the browser.**

Get started by importing the font you would like to use from
`next/font/google` as a function. We recommend using variable fonts for the
best performance and flexibility.

    
    
    import { Inter } from 'next/font/google';
     
    // If loading a variable font, you don't need to specify the font weight
    const inter = Inter({
      subsets: ['latin'],
      display: 'swap',
    });
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" className={inter.className}>
          <body>{children}</body>
        </html>
      );
    }

If you can't use a variable font, you will **need to specify a weight** :

    
    
    import { Roboto } from 'next/font/google';
     
    const roboto = Roboto({
      weight: '400',
      subsets: ['latin'],
      display: 'swap',
    });
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" className={roboto.className}>
          <body>{children}</body>
        </html>
      );
    }

You can specify multiple weights and/or styles by using an array:

    
    
    const roboto = Roboto({
      weight: ['400', '700'],
      style: ['normal', 'italic'],
      subsets: ['latin'],
      display: 'swap',
    });

> **Good to know** : Use an underscore (_) for font names with multiple words.
> E.g. `Roboto Mono` should be imported as `Roboto_Mono`.

Google Fonts are automatically subset. This reduces the size of the font file
and improves performance. You'll need to define which of these subsets you
want to preload. Failing to specify any subsets while `preload` is `true` will
result in a warning.

This can be done by adding it to the function call:

    
    
    const inter = Inter({ subsets: ['latin'] });

View the Font API Reference for more information.

You can import and use multiple fonts in your application. There are two
approaches you can take.

The first approach is to create a utility function that exports a font,
imports it, and applies its `className` where needed. This ensures the font is
preloaded only when it's rendered:

    
    
    import { Inter, Roboto_Mono } from 'next/font/google';
     
    export const inter = Inter({
      subsets: ['latin'],
      display: 'swap',
    });
     
    export const roboto_mono = Roboto_Mono({
      subsets: ['latin'],
      display: 'swap',
    });
    
    
    import { inter } from './fonts';
     
    export default function Layout({ children }: { children: React.ReactNode }) {
      return (
        <html lang="en" className={inter.className}>
          <body>
            <div>{children}</div>
          </body>
        </html>
      );
    }
    
    
    import { roboto_mono } from './fonts';
     
    export default function Page() {
      return (
        <>
          <h1 className={roboto_mono.className}>My page</h1>
        </>
      );
    }

In the example above, `Inter` will be applied globally, and `Roboto Mono` can
be imported and applied as needed.

Alternatively, you can create a CSS variable and use it with your preferred
CSS solution:

    
    
    import { Inter, Roboto_Mono } from 'next/font/google';
    import styles from './global.css';
     
    const inter = Inter({
      subsets: ['latin'],
      variable: '--font-inter',
      display: 'swap',
    });
     
    const roboto_mono = Roboto_Mono({
      subsets: ['latin'],
      variable: '--font-roboto-mono',
      display: 'swap',
    });
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" className={`${inter.variable} ${roboto_mono.variable}`}>
          <body>
            <h1>My App</h1>
            <div>{children}</div>
          </body>
        </html>
      );
    }
    
    
    html {
      font-family: var(--font-inter);
    }
     
    h1 {
      font-family: var(--font-roboto-mono);
    }

In the example above, `Inter` will be applied globally, and any `<h1>` tags
will be styled with `Roboto Mono`.

> **Recommendation** : Use multiple fonts conservatively since each new font
> is an additional resource the client has to download.

Import `next/font/local` and specify the `src` of your local font file. We
recommend using variable fonts for the best performance and flexibility.

    
    
    import localFont from 'next/font/local';
     
    // Font files can be colocated inside of `app`
    const myFont = localFont({
      src: './my-font.woff2',
      display: 'swap',
    });
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" className={myFont.className}>
          <body>{children}</body>
        </html>
      );
    }

If you want to use multiple files for a single font family, `src` can be an
array:

    
    
    const roboto = localFont({
      src: [
        {
          path: './Roboto-Regular.woff2',
          weight: '400',
          style: 'normal',
        },
        {
          path: './Roboto-Italic.woff2',
          weight: '400',
          style: 'italic',
        },
        {
          path: './Roboto-Bold.woff2',
          weight: '700',
          style: 'normal',
        },
        {
          path: './Roboto-BoldItalic.woff2',
          weight: '700',
          style: 'italic',
        },
      ],
    });

View the Font API Reference for more information.

`next/font` can be used with Tailwind CSS through a CSS variable.

In the example below, we use the font `Inter` from `next/font/google` (you can
use any font from Google or Local Fonts). Load your font with the `variable`
option to define your CSS variable name and assign it to `inter`. Then, use
`inter.variable` to add the CSS variable to your HTML document.

    
    
    import { Inter, Roboto_Mono } from 'next/font/google';
     
    const inter = Inter({
      subsets: ['latin'],
      display: 'swap',
      variable: '--font-inter',
    });
     
    const roboto_mono = Roboto_Mono({
      subsets: ['latin'],
      display: 'swap',
      variable: '--font-roboto-mono',
    });
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en" className={`${inter.variable} ${roboto_mono.variable}`}>
          <body>{children}</body>
        </html>
      );
    }

Finally, add the CSS variable to your Tailwind CSS config:

    
    
    /** @type {import('tailwindcss').Config} */
    module.exports = {
      content: [
        './pages/**/*.{js,ts,jsx,tsx}',
        './components/**/*.{js,ts,jsx,tsx}',
      ],
      theme: {
        extend: {
          fontFamily: {
            sans: ['var(--font-inter)'],
            mono: ['var(--font-roboto-mono)'],
          },
        },
      },
      plugins: [],
    };

You can now use the `font-sans` and `font-mono` utility classes to apply the
font to your elements.

When a font function is called on a page of your site, it is not globally
available and preloaded on all routes. Rather, the font is only preloaded on
the related routes based on the type of file where it is used:

  * If it's a unique page, it is preloaded on the unique route for that page.
  * If it's a layout, it is preloaded on all the routes wrapped by the layout.
  * If it's the root layout, it is preloaded on all routes.

Every time you call the `localFont` or Google font function, that font is
hosted as one instance in your application. Therefore, if you load the same
font function in multiple files, multiple instances of the same font are
hosted. In this situation, it is recommended to do the following:

  * Call the font loader function in one shared file
  * Export it as a constant
  * Import the constant in each file where you would like to use this font





# Script Optimization

To load a third-party script for multiple routes, import `next/script` and
include the script directly in your layout component:

    
    
    import Script from 'next/script';
     
    export default function DashboardLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <>
          <section>{children}</section>
          <Script src="https://example.com/script.js" />
        </>
      );
    }

The third-party script is fetched when the the folder route (e.g.
`dashboard/page.js`) or any nested route (e.g. `dashboard/settings/page.js`)
is accessed by the user. Next.js will ensure the script will **only load
once** , even if a user navigates between multiple routes in the same layout.

To load a third-party script for all routes, import `next/script` and include
the script directly in your root layout:

    
    
    import Script from 'next/script';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
          <Script src="https://example.com/script.js" />
        </html>
      );
    }

This script will load and execute when _any_ route in your application is
accessed. Next.js will ensure the script will **only load once** , even if a
user navigates between multiple pages.

> **Recommendation** : We recommend only including third-party scripts in
> specific pages or layouts in order to minimize any unnecessary impact to
> performance.

Although the default behavior of `next/script` allows you load third-party
scripts in any page or layout, you can fine-tune its loading behavior by using
the `strategy` property:

  * `beforeInteractive`: Load the script before any Next.js code and before any page hydration occurs.
  * `afterInteractive`: ( **default** ) Load the script early but after some hydration on the page occurs.
  * `lazyOnload`: Load the script later during browser idle time.
  * `worker`: (experimental) Load the script in a web worker.

Refer to the `next/script` API reference documentation to learn more about
each strategy and their use cases.

> **Warning:** The `worker` strategy is not yet stable and does not yet work
> with the `app` directory. Use with caution.

Scripts that use the `worker` strategy are offloaded and executed in a web
worker with Partytown. This can improve the performance of your site by
dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the
`nextScriptWorkers` flag is enabled in `next.config.js`:

    
    
    module.exports = {
      experimental: {
        nextScriptWorkers: true,
      },
    };

Then, run `next` (normally `npm run dev` or `yarn dev`) and Next.js will guide
you through the installation of the required packages to finish the setup:

You'll see instructions like these: Please install Partytown by running `npm
install @builder.io/partytown`

Once setup is complete, defining `strategy="worker"` will automatically
instantiate Partytown in your application and offload the script to a web
worker.

    
    
    import Script from 'next/script';
     
    export default function Home() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="worker" />
        </>
      );
    }

There are a number of trade-offs that need to be considered when loading a
third-party script in a web worker. Please see Partytown's tradeoffs
documentation for more information.

Inline scripts, or scripts not loaded from an external file, are also
supported by the Script component. They can be written by placing the
JavaScript within curly braces:

    
    
    <Script id="show-banner">
      {`document.getElementById('banner').classList.remove('hidden')`}
    </Script>

Or by using the `dangerouslySetInnerHTML` property:

    
    
    <Script
      id="show-banner"
      dangerouslySetInnerHTML={{
        __html: `document.getElementById('banner').classList.remove('hidden')`,
      }}
    />

> **Warning** : An `id` property must be assigned for inline scripts in order
> for Next.js to track and optimize the script.

Event handlers can be used with the Script component to execute additional
code after a certain event occurs:

  * `onLoad`: Execute code after the script has finished loading.
  * `onReady`: Execute code after the script has finished loading and every time the component is mounted.
  * `onError`: Execute code if the script fails to load.

These handlers will only work when `next/script` is imported and used inside
of a Client Component where `"use client"` is defined as the first line of
code:

    
    
    'use client';
     
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            onLoad={() => {
              console.log('Script has loaded');
            }}
          />
        </>
      );
    }

Refer to the `next/script` API reference to learn more about each event
handler and view examples.

There are many DOM attributes that can be assigned to a `<script>` element
that are not used by the Script component, like `nonce` or custom data
attributes. Including any additional attributes will automatically forward it
to the final, optimized `<script>` element that is included in the HTML.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            id="example-script"
            nonce="XUENAJFW"
            data-test="script"
          />
        </>
      );
    }





# Metadata

Next.js has a Metadata API that can used to define your application metadata
(e.g. `meta` and `link` tags inside your HTML `head` element) for improved SEO
and web shareability.

There are two ways you can add metadata to your application:

With both these options, Next.js will automatically generate the relevant
`<head>` elements for your pages. You can also create dynamic OG images using
the `ImageResponse` constructor.

To define static metadata, export a `Metadata` object from a `layout.js` or
static `page.js` file.

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: '...',
      description: '...',
    };
     
    export default function Page() {}

For all the available options, see the API Reference.

You can use `generateMetadata` function to `fetch` metadata that requires
dynamic values.

    
    
    import { Metadata, ResolvingMetadata } from 'next';
     
    type Props = {
      params: { id: string };
      searchParams: { [key: string]: string | string[] | undefined };
    };
     
    export async function generateMetadata(
      { params, searchParams }: Props,
      parent?: ResolvingMetadata,
    ): Promise<Metadata> {
      // read route params
      const id = params.id;
     
      // fetch data
      const product = await fetch(`https://.../${id}`).then((res) => res.json());
     
      // optionally access and extend (rather than replace) parent metadata
      const previousImages = (await parent).openGraph?.images || [];
     
      return {
        title: product.title,
        openGraph: {
          images: ['/some-specific-page-image.jpg', ...previousImages],
        },
      };
    }
     
    export default function Page({ params, searchParams }: Props) {}

For all the available params, see the API Reference.

> **Good to know:**
>
>   * Both static and dynamic metadata through `generateMetadata` are **only
> supported in Server Components**.
>   * When rendering a route, Next.js will automatically deduplicate `fetch`
> requests for the same data across `generateMetadata`,
> `generateStaticParams`, Layouts, Pages, and Server Components. React `cache`
> can be used if `fetch` is unavailable.
>   * Next.js will wait for data fetching inside `generateMetadata` to
> complete before streaming UI to the client. This guarantees the first part
> of a streamed response includes `<head>` tags.
>

These special files are available for metadata:

You can use these for static metadata, or you can programatically generate
these files with code.

For implementation and examples, see the Metadata Files API Reference and
Dynamic Image Generation.

File-based metadata has the higher priority and will override any config-based
metadata.

There are two default `meta` tags that are always added even if a route
doesn't define metadata:

  * The meta charset tag sets the character encoding for the website.
  * The meta viewport tag sets the viewport width and scale for the website to adjust for different devices.

    
    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

> **Note** : You can overwrite the default `viewport` meta tag.

Metadata is evaluated in order, starting from the root segment down to the
segment closest to the final `page.js` segment. For example:

  1. `app/layout.tsx` (Root Layout)
  2. `app/blog/layout.tsx` (Nested Blog Layout)
  3. `app/blog/[slug]/page.tsx` (Blog Page)

Following the evaluation order, Metadata objects exported from multiple
segments in the same route are **shallowly** merged together to form the final
metadata output of a route. Duplicate keys are **replaced** based on their
ordering.

This means metadata with nested fields such as `openGraph` and `robots` that
are defined in an earlier segment are **overwritten** by the last segment to
define them.

    
    
    export const metadata = {
      title: 'Acme',
      openGraph: {
        title: 'Acme',
        description: 'Acme is a...',
      },
    };
    
    
    export const metadata = {
      title: 'Blog',
      openGraph: {
        title: 'Blog',
      },
    };
     
    // Output:
    // <title>Blog</title>
    // <meta property="og:title" content="Blog" />

In the example above:

  * `title` from `app/layout.js` is **replaced** by `title` in `app/blog/page.js`.
  * All `openGraph` fields from `app/layout.js` are **replaced** in `app/blog/page.js` because `app/blog/page.js` sets `openGraph` metadata. Note the absence of `openGraph.description`.

If you'd like to share some nested fields between segments while overwriting
others, you can pull them out into a separate variable:

    
    
    export const openGraphImage = { images: ['http://...'] };
    
    
    import { openGraphImage } from './shared-metadata';
     
    export const metadata = {
      openGraph: {
        ...openGraphImage,
        title: 'Home',
      },
    };
    
    
    import { openGraphImage } from '../shared-metadata';
     
    export const metadata = {
      openGraph: {
        ...openGraphImage,
        title: 'About',
      },
    };

In the example above, the OG image is shared between `app/layout.js` and
`app/about/page.js` while the titles are different.

    
    
    export const metadata = {
      title: 'Acme',
      openGraph: {
        title: 'Acme',
        description: 'Acme is a...',
      },
    };
    
    
    export const metadata = {
      title: 'About',
    };
     
    // Output:
    // <title>About</title>
    // <meta property="og:title" content="Acme" />
    // <meta property="og:description" content="Acme is a..." />

**Notes**

  * `title` from `app/layout.js` is **replaced** by `title` in `app/about/page.js`.
  * All `openGraph` fields from `app/layout.js` are **inherited** in `app/about/page.js` because `app/about/page.js` doesn't set `openGraph` metadata.

The `ImageResponse` constructor allows you to generate dynamic images using
JSX and CSS. This is useful for creating social media images such as Open
Graph images, Twitter cards, and more.

`ImageResponse` uses the Edge Runtime, and Next.js automatically adds the
correct headers to cached images at the edge, helping improve performance and
reducing recomputation.

To use it, you can import `ImageResponse` from `next/server`:

    
    
    import { ImageResponse } from 'next/server';
     
    export const runtime = 'edge';
     
    export async function GET() {
      return new ImageResponse(
        (
          <div
            style={{
              fontSize: 128,
              background: 'white',
              width: '100%',
              height: '100%',
              display: 'flex',
              textAlign: 'center',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            Hello world!
          </div>
        ),
        {
          width: 1200,
          height: 600,
        },
      );
    }

`ImageResponse` integrates well with other Next.js APIs, including Route
Handlers and file-based Metadata. For example, you can use `ImageResponse` in
a `opengraph-image.tsx` file to generate Open Graph images at build time or
dynamically at request time.

`ImageResponse` supports common CSS properties including flexbox and absolute
positioning, custom fonts, text wrapping, centering, and nested images. See
the full list of supported CSS properties.

> **Good to know:**
>
>   * Examples are available in the Vercel OG Playground.
>   * `ImageResponse` uses @vercel/og, Satori, and Resvg to convert HTML and
> CSS into PNG.
>   * Only the Edge Runtime is supported. The default Node.js runtime will not
> work.
>   * Only flexbox and a subset of CSS properties are supported. Advanced
> layouts (e.g. `display: grid`) will not work.
>   * Maximum bundle size of `500KB`. The bundle size includes your JSX, CSS,
> fonts, images, and any other assets. If you exceed the limit, consider
> reducing the size of any assets or fetching at runtime.
>   * Only `ttf`, `otf`, and `woff` font formats are supported. To maximize
> the font parsing speed, `ttf` or `otf` are preferred over `woff`.
>

JSON-LD is a format for structured data that can be used by search engines to
understand your content. For example, you can use it to describe a person, an
event, an organization, a movie, a book, a recipe, and many other types of
entities.

Our current recommendation for JSON-LD is to render structured data as a
`<script>` tag in your `layout.js` or `page.js` components. For example:

    
    
    export default async function Page({ params }) {
      const product = await getProduct(params.id);
     
      const jsonLd = {
        '@context': 'https://schema.org',
        '@type': 'Product',
        name: product.name,
        image: product.image,
        description: product.description,
      };
     
      return (
        <section>
          {/* Add JSON-LD to your page */}
          <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
          />
          {/* ... */}
        </section>
      );
    }

You can validate and test your structured data with the Rich Results Test for
Google or the generic Schema Markup Validator.

You can type your JSON-LD with TypeScript using community packages like
`schema-dts`:

    
    
    import { Product, WithContext } from 'schema-dts';
     
    const jsonLd: WithContext<Product> = {
      '@context': 'https://schema.org',
      '@type': 'Product',
      name: 'Next.js Sticker',
      image: 'https://nextjs.org/imgs/sticker.png',
      description: 'Dynamic at the speed of static.',
    };





Using App Router

Features available in /app





# Lazy Loading

Lazy loading in Next.js helps improve the initial loading performance of an
application by decreasing the amount of JavaScript needed to render a route.

It allows you to defer loading of **Client Components** and imported
libraries, and only include them in the client bundle when they're needed. For
example, you might want to defer loading a modal until a user clicks to open
it.

There are two ways you can implement lazy loading in Next.js:

  1. Using Dynamic Imports with `next/dynamic`
  2. Using `React.lazy()` with Suspense

By default, Server Components are automatically code split, and you can use
streaming to progressively send pieces of UI from the server to the client.
Lazy loading applies to Client Components.

`next/dynamic` is a composite of `React.lazy()` and Suspense. It behaves the
same way in the `app` and `pages` directories to allow for incremental
migration.

    
    
    'use client';
     
    import { useState } from 'react';
    import dynamic from 'next/dynamic';
     
    // Client Components:
    const ComponentA = dynamic(() => import('../components/A'));
    const ComponentB = dynamic(() => import('../components/B'));
    const ComponentC = dynamic(() => import('../components/C'), { ssr: false });
     
    export default function ClientComponentExample() {
      const [showMore, setShowMore] = useState(false);
     
      return (
        <div>
          {/* Load immediately, but in a separate client bundle */}
          <ComponentA />
     
          {/* Load on demand, only when/if the condition is met */}
          {showMore && <ComponentB />}
          <button onClick={() => setShowMore(!showMore)}>Toggle</button>
     
          {/* Load only on the client side */}
          <ComponentC />
        </div>
      );
    }

When using `React.lazy()` and Suspense, Client Components will be pre-rendered
(SSR) by default.

If you want to disable pre-rendering for a Client Component, you can use the
`ssr` option set to `false`:

    
    
    const ComponentC = dynamic(() => import('../components/C'), { ssr: false });

If you dynamically import a Server Component, only the Client Components that
are children of the Server Component will be lazy-loaded - not the Server
Component itself.

    
    
    import dynamic from 'next/dynamic';
     
    // Server Component:
    const ServerComponent = dynamic(() => import('../components/ServerComponent'));
     
    export default function ServerComponentExample() {
      return (
        <div>
          <ServerComponent />
        </div>
      );
    }

External libraries can be loaded on demand using the `import()` function. This
example uses the external library `fuse.js` for fuzzy search. The module is
only loaded on the client after the user types in the search input.

    
    
    'use client';
     
    import { useState } from 'react';
     
    const names = ['Tim', 'Joe', 'Bel', 'Lee'];
     
    export default function Page() {
      const [results, setResults] = useState();
     
      return (
        <div>
          <input
            type="text"
            placeholder="Search"
            onChange={async (e) => {
              const { value } = e.currentTarget;
              // Dynamically load fuse.js
              const Fuse = (await import('fuse.js')).default;
              const fuse = new Fuse(names);
     
              setResults(fuse.search(value));
            }}
          />
          <pre>Results: {JSON.stringify(results, null, 2)}</pre>
        </div>
      );
    }
    
    
    import dynamic from 'next/dynamic';
     
    const WithCustomLoading = dynamic(
      () => import('../components/WithCustomLoading'),
      {
        loading: () => <p>Loading...</p>,
      },
    );
     
    export default function Page() {
      return (
        <div>
          {/* The loading component will be rendered while  <WithCustomLoading/> is loading */}
          <WithCustomLoading />
        </div>
      );
    }

To dynamically import a named export, you can return it from the Promise
returned by `import()` function:

    
    
    'use client';
     
    export function Hello() {
      return <p>Hello!</p>;
    }
    
    
    import dynamic from 'next/dynamic';
     
    const ClientComponent = dynamic(() =>
      import('../components/ClientComponent').then((mod) => mod.Hello),
    );





Using App Router

Features available in /app



  
  
# OpenTelemetry

> **Note** : This feature is experimental, you need to explicitly opt-in by
> providing `experimental.instrumentationHook = true;` in your
> `next.config.js`.

Observability is crucial for understanding and optimizing the behavior and
performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to
identify and diagnose issues that may arise. By leveraging observability
tools, such as logging and metrics, developers can gain insights into their
application's behavior and identify areas for optimization. With
observability, developers can proactively address issues before they become
major problems and provide a better user experience. Therefore, it is highly
recommended to use observability in your Next.js applications to improve
performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps. It's a platform-
agnostic way to instrument apps that allows you to change your observability
provider without changing your code. Read Official OpenTelemetry docs for more
information about OpenTelemetry and how it works.

This documentation uses terms like _Span_ , _Trace_ or _Exporter_ throughout
this doc, all of which can be found in the OpenTelemetry Observability Primer.

Next.js supports OpenTelemetry instrumentation out of the box, which means
that we already instrumented Next.js itself. When you enable OpenTelemetry we
will automatically wrap all your code like `getStaticProps` in _spans_ with
helpful attributes.

> **Note** : We currently support OpenTelemetry bindings only in serverless
> functions. We don't provide any for `edge` or client side code.

OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package `@vercel/otel` that helps you get started
quickly. It's not extensible and you should configure OpenTelemetry manually
you need to customize your setup.

To get started, you must install `@vercel/otel`:

Next, create a custom `instrumentation.ts` file in the root of the project:

    
    
    import { registerOTel } from '@vercel/otel';
     
    export function register() {
      registerOTel('next-app');
    }

> **Note** : We have created a basic with-opentelemetry example that you can
> use.

If our wrapper `@vercel/otel` doesn't suit your needs, you can configure
OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

    
    
    npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http

Now you can initialize `NodeSDK` in your `instrumentation.ts`. OpenTelemetry
APIs are not compatible with edge runtime, so you need to make sure that you
are importing them only when `process.env.NEXT_RUNTIME === 'nodejs'`. We
recommend creating a new file `instrumentation.node.ts` which you
conditionally import only when using node:

    
    
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        await import('./instrumentation.node.ts');
      }
    }
    
    
    import { trace, context } from '@opentelemetry/api';
    import { NodeSDK } from '@opentelemetry/sdk-node';
    import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
    import { Resource } from '@opentelemetry/resources';
    import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
    import { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node';
     
    const sdk = new NodeSDK({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: 'next-app',
      }),
      spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),
    });
    sdk.start();

Doing this is equivalent to using `@vercel/otel`, but it's possible to modify
and extend. For example, you could use `@opentelemetry/exporter-trace-otlp-
grpc` instead of `@opentelemetry/exporter-trace-otlp-http` or you can specify
more resource attributes.

You need an OpenTelemetry collector with a compatible backend to test
OpenTelemetry traces locally. We recommend using our OpenTelemetry dev
environment.

If everything works well you should be able to see the root server span
labeled as `GET /requested/pathname`. All other spans from that particular
trace will be nested under it.

Next.js traces more spans than are emitted by default. To see more spans, you
must set `NEXT_OTEL_VERBOSE=1`.

When you are deploying with OpenTelemetry Collector, you can use
`@vercel/otel`. It will work both on Vercel and when self-hosted.

We made sure that OpenTelemetry works out of the box on Vercel.

Follow Vercel documentation to connect your project to an observability
provider.

Deploying to other platforms is also straightforward. You will need to spin up
your own OpenTelemetry Collector to receive and process the telemetry data
from your Next.js app.

To do this, follow the OpenTelemetry Collector Getting Started guide, which
will walk you through setting up the collector and configuring it to receive
data from your Next.js app.

Once you have your collector up and running, you can deploy your Next.js app
to your chosen platform following their respective deployment guides.

We recommend using OpenTelemetry Collector. If that is not possible on your
platform, you can use a custom OpenTelemetry exporter with manual
OpenTelemetry configuration

You can add a custom span with OpenTelemetry APIs.

    
    
    npm install @opentelemetry/api

The following example demonstrates a function that fetches GitHub stars and
adds a custom `fetchGithubStars` span to track the fetch request's result:

    
    
    import { trace } from '@opentelemetry/api';
     
    export async function fetchGithubStars() {
      return await trace
        .getTracer('nextjs-example')
        .startActiveSpan('fetchGithubStars', async (span) => {
          try {
            return await getValue();
          } finally {
            span.end();
          }
        });
    }

The `register` function will execute before your code runs in a new
environment. You can start creating new spans, and they should be correctly
added to the exported trace.

Next.js automatically instruments several spans for you to provide useful
insights into your application's performance.

Attributes on spans follow OpenTelemetry semantic conventions. We also add
some custom attributes under the `next` namespace:

  * `next.span_name` \- duplicates span name
  * `next.span_type` \- each span type has a unique identifier
  * `next.route` \- The route pattern of the request (e.g., `/[param]/user`).
  * `next.page`
    * This is an internal value used by an app router.
    * You can think about it as a route to a special file (like `page.ts`, `layout.ts`, `loading.ts` and others)
    * It can be used as a unique identifier only when paired with `next.route` because `/layout` can be used to identify both `/(groupA)/layout.ts` and `/(groupB)/layout.ts`

  * `next.span_type`: `BaseServer.handleRequest`

This span represents the root span for each incoming request to your Next.js
application. It tracks the HTTP method, route, target, and status code of the
request.

Attributes:

  * `next.span_type`: `AppRender.getBodyResult`.

This span represents the process of rendering a route in the app router.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `AppRender.fetch`

This span represents the fetch request executed in your code.

Attributes:

  * `next.span_type`: `AppRouteRouteHandlers.runHandler`.

This span represents the execution of an API route handler in the app router.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.getServerSideProps`.

This span represents the execution of `getServerSideProps` for a specific
route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.getStaticProps`.

This span represents the execution of `getStaticProps` for a specific route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.renderDocument`.

This span represents the process of rendering the document for a specific
route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `ResolveMetadata.generateMetadata`.

This span represents the process of generating metadata for a specific page (a
single route can have multiple of these spans).

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.page`





# Instrumentation

> **Note** : This feature is experimental. To use it, you must explicitly opt
> in by defining `experimental.instrumentationHook = true;` in your
> `next.config.js`.

If you export a function named `register` from this file, we will call that
function whenever a new Next.js server instance is bootstrapped. When your
`register` function is deployed, it will be called on each cold boot (but
exactly once in each environment).

Sometimes, it may be useful to import a file in your code because of the side
effects it will cause. For example, you might import a file that defines a set
of global variables, but never explicitly use the imported file in your code.
You would still have access to the global variables the package has declared.

You can import files with side effects in `instrumentation.ts`, which you
might want to use in your `register` function as demonstrated in the following
example:

    
    
    import { init } from 'package-init';
     
    export function register() {
      init();
    }

However, we recommend importing files with side effects using `import` from
within your `register` function instead. The following example demonstrates a
basic usage of `import` in a `register` function:

    
    
    export async function register() {
      await import('package-with-side-effect');
    }

By doing this, you can colocate all of your side effects in one place in your
code, and avoid any unintended consequences from importing files.

We call `register` in all environments, so it's necessary to conditionally
import any code that doesn't support both `edge` and `nodejs`. You can use the
environment variable `NEXT_RUNTIME` to get the current environment. Importing
an environment-specific code would look like this:

    
    
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        await import('./instrumentation-node');
      }
     
      if (process.env.NEXT_RUNTIME === 'edge') {
        await import('./instrumentation-edge');
      }
    }





Using App Router

Features available in /app





# TypeScript

Next.js provides a TypeScript-first development experience for building your
React application.

It comes with built-in TypeScript support for automatically installing the
necessary packages and configuring the proper settings.

As well as a TypeScript Plugin for your editor.

> **🎥 Watch:** Learn about the built-in TypeScript plugin → YouTube (3
> minutes)

`create-next-app` now ships with TypeScript by default.

    
    
    npx create-next-app@latest

Add TypeScript to your project by renaming a file to `.ts` / `.tsx`. Run `next
dev` and `next build` to automatically install the necessary dependencies and
add a `tsconfig.json` file with the recommended config options.

Next.js includes a custom TypeScript plugin and type checker, which VSCode and
other code editors can use for advanced type-checking and auto-completion.

The first time you run `next dev` with a TypeScript file open, you will
receive a prompt to enable the plugin.

![TypeScript Prompt](/_next/image?url=%2Fdocs%2Flight%2Ftypescript-
prompt.png&w=3840&q=75)![TypeScript
Prompt](/_next/image?url=%2Fdocs%2Fdark%2Ftypescript-prompt.png&w=3840&q=75)

If you miss the prompt, you can enable the plugin manually by:

  1. Opening the command palette (`Ctrl/⌘` \+ `Shift` \+ `P`)
  2. Searching for "TypeScript: Select TypeScript Version"
  3. Selecting "Use Workspace Version"

![TypeScript Command Palette](/_next/image?url=%2Fdocs%2Flight%2Ftypescript-
command-palette.png&w=3840&q=75)![TypeScript Command
Palette](/_next/image?url=%2Fdocs%2Fdark%2Ftypescript-command-
palette.png&w=3840&q=75)

Now, when editing files, the custom plugin will be enabled. When running `next
build`, the custom type checker will be used. Further, we automatically create
a VSCode settings file for you to automate this process.

The TypeScript plugin can help with:

  * Warning if the invalid values for segment config options are passed.
  * Showing available options and in-context documentation.
  * Ensuring the `use client` directive is used correctly.
  * Ensuring client hooks (like `useState`) are only used in Client Components.

> **Note:** More features will be added in the future.

It is highly recommended to be on at least `v4.5.2` of TypeScript to get
syntax features such as type modifiers on import names and performance
improvements.

Next.js can statically type links to prevent typos and other errors when using
`next/link`, improving type safety when navigating between pages.

To opt-into this feature, `experimental.typedRoutes` need to be enabled and
the project needs to be using TypeScript.

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        typedRoutes: true,
      },
    };
     
    module.exports = nextConfig;

Next.js will generate a link definition in `.next/types` that contains
information about all existing routes in your application, which TypeScript
can then use to provide feedback in your editor about invalid links.

Currently, experimental support includes any string literal, including dynamic
segments. For non-literal strings, you currently need to manually cast the
`href` with `as Route`:

    
    
    import type { Route } from 'next';
    import Link from 'next/link'
     
    // No TypeScript errors if href is a valid route
    <Link href="/about" />
    <Link href="/blog/nextjs" />
    <Link href={`/blog/${slug}`} />
    <Link href={('/blog' + slug) as Route} />
     
    // TypeScript errors if href is not a valid route
    <Link href="/aboot" />

To accept `href` in a custom component wrapping `next/link`, use a generic:

    
    
    import type { Route } from 'next';
    import Link from 'next/link';
     
    function Card<T extends string>({ href }: { href: Route<T> | URL })
      return (
        <Link href={href}>
          <div>My Card</div>
        </Link>
      );
    }

> **How does it work?**
>
> When running `next dev` or `next build`, Next.js generates a hidden `.d.ts`
> file inside `.next` that contains information about all existing routes in
> your application (all valid routes as the `href` type of `Link`). This
> `.d.ts` file is included in `tsconfig.json` and the TypeScript compiler will
> check that `.d.ts` and provide feedback in your editor about invalid links.

Next.js 13 has **enhanced type safety**. This includes:

  1. **No serialization of data between fetching function and page** : You can `fetch` directly in components, layouts, and pages on the server. This data _does not_ need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since `app` uses Server Components by default, we can use values like `Date`, `Map`, `Set`, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.
  2. **Streamlined data flow between components** : With the removal of `_app` in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previous, data flowing between individual `pages` and `_app` were difficult to type and could introduce confusing bugs. With colocated data fetching in Next.js 13, this is no longer an issue.

Data Fetching in Next.js now provides as close to end-to-end type safety as
possible without being prescriptive about your database or content provider
selection.

We're able to type the response data as you would expect with normal
TypeScript. For example:

    
    
    async function getData() {
      const res = await fetch('https://api.example.com/...');
      // The return value is *not* serialized
      // You can return Date, Map, Set, etc.
      return res.json();
    }
     
    export default async function Page() {
      const name = await getData();
     
      return '...';
    }

For _complete_ end-to-end type safety, this also requires your database or
content provider to support TypeScript. This could be through using an ORM or
type-safe query builder.

  * An `async` Server Components will cause a `'Promise<Element>' is not a valid JSX element` type error where it is used.
  * This is a known issue with TypeScript and is being worked on upstream.
  * As a temporary workaround, you can add `{/* @ts-expect-error Async Server Component */}` above the component to disable type checking for it.

    
    
    import { ExampleAsyncComponent } from './ExampleAsyncComponent';
    export default function Page() {
      return (
        <>
          {/* @ts-expect-error Async Server Component */}
          <ExampleAsyncComponent />
        </>
      );
    }

  * This does not apply to Layout and Page components.
  * We are tracking this issue here. This will likely be fixed in TypeScript 5.1 (Stable).

When passing data between a Server and Client Component through props, the
data is still serialized (converted to a string) for use in the browser.
However, it does not need a special type. It’s typed the same as passing any
other props between components.

Further, there is less code to be serialized, as un-rendered data does not
cross between the server and client (it remains on the server). This is only
now possible through support for Server Components.

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"`
options.

You can learn more about this feature on the Module Path aliases
documentation.

The `next.config.js` file must be a JavaScript file as it does not get parsed
by Babel or TypeScript, however you can add some type checking in your IDE
using JSDoc as below:

    
    
    // @ts-check
     
    /**
     * @type {import('next').NextConfig}
     **/
    const nextConfig = {
      /* config options here */
    };
     
    module.exports = nextConfig;

Since `v10.2.1` Next.js supports incremental type checking when enabled in
your `tsconfig.json`, this can help speed up type checking in larger
applications.

Next.js fails your **production build** (`next build`) when TypeScript errors
are present in your project.

If you'd like Next.js to dangerously produce production code even when your
application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or
deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the
`typescript` config:

    
    
    module.exports = {
      typescript: {
        // !! WARN !!
        // Dangerously allow production builds to successfully complete even if
        // your project has type errors.
        // !! WARN !!
        ignoreBuildErrors: true,
      },
    };

Version| Changes  
---|---  
`v13.2.0`| Statically typed links are available in beta  
`v12.0.0`| SWC is now used by default to compile TypeScript and TSX for faster
builds.  
`v10.2.1`| Incremental type checking support added when enabled in your
`tsconfig.json`.





# ESLint

Next.js provides an integrated ESLint experience out of the box. Add `next
lint` as a script to `package.json`:

    
    
    "scripts": {
      "lint": "next lint"
    }

Then run `npm run lint` or `yarn lint`:

If you don't already have ESLint configured in your application, you will be
guided through the installation and configuration process.

> You'll see a prompt like this:
>
> ? How would you like to configure ESLint?
>
> ❯ Base configuration + Core Web Vitals rule-set (recommended) Base
> configuration None

One of the following three options can be selected:

  * **Strict** : Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.
    
        {
      "extends": "next/core-web-vitals"
    }

  * **Base** : Includes Next.js' base ESLint configuration.

  * **Cancel** : Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.

If either of the two configuration options are selected, Next.js will
automatically install `eslint` and `eslint-config-next` as development
dependencies in your application and create an `.eslintrc.json` file in the
root of your project that includes your selected configuration.

You can now run `next lint` every time you want to run ESLint to catch errors.
Once ESLint has been set up, it will also automatically run during every build
(`next build`). Errors will fail the build, while warnings will not.

> If you do not want ESLint to run during `next build`, refer to the
> documentation for Ignoring ESLint.

We recommend using an appropriate integration to view warnings and errors
directly in your code editor during development.

The default configuration (`eslint-config-next`) includes everything you need
to have an optimal out-of-the-box linting experience in Next.js. If you do not
have ESLint already configured in your application, we recommend using `next
lint` to set up ESLint along with this configuration.

> If you would like to use `eslint-config-next` along with other ESLint
> configurations, refer to the Additional Configurations section to learn how
> to do so without causing any conflicts.

Recommended rule-sets from the following ESLint plugins are all used within
`eslint-config-next`:

This will take precedence over the configuration from `next.config.js`.

Next.js provides an ESLint plugin, `eslint-plugin-next`, already bundled
within the base configuration that makes it possible to catch common issues
and problems in a Next.js application. The full set of rules is as follows:

Enabled in the recommended configuration

If you already have ESLint configured in your application, we recommend
extending from this plugin directly instead of including `eslint-config-next`
unless a few conditions are met. Refer to the Recommended Plugin Ruleset to
learn more.

If you're using `eslint-plugin-next` in a project where Next.js isn't
installed in your root directory (such as a monorepo), you can tell `eslint-
plugin-next` where to find your Next.js application using the `settings`
property in your `.eslintrc`:

    
    
    {
      "extends": "next",
      "settings": {
        "next": {
          "rootDir": "packages/my-app/"
        }
      }
    }

`rootDir` can be a path (relative or absolute), a glob (i.e. `"packages/*/"`),
or an array of paths and/or globs.

By default, Next.js will run ESLint for all files in the `pages/`, `app` (only
if the experimental `appDir` feature is enabled), `components/`, `lib/`, and
`src/` directories. However, you can specify which directories using the
`dirs` option in the `eslint` config in `next.config.js` for production
builds:

    
    
    module.exports = {
      eslint: {
        dirs: ['pages', 'utils'], // Only run ESLint on the 'pages' and 'utils' directories during production builds (next build)
      },
    };

Similarly, the `--dir` and `--file` flags can be used for `next lint` to lint
specific directories and files:

    
    
    next lint --dir pages --dir utils --file bar.js

To improve performance, information of files processed by ESLint are cached by
default. This is stored in `.next/cache` or in your defined build directory.
If you include any ESLint rules that depend on more than the contents of a
single source file and need to disable the cache, use the `--no-cache` flag
with `next lint`.

If you would like to modify or disable any rules provided by the supported
plugins (`react`, `react-hooks`, `next`), you can directly change them using
the `rules` property in your `.eslintrc`:

    
    
    {
      "extends": "next",
      "rules": {
        "react/no-unescaped-entities": "off",
        "@next/next/no-page-custom-font": "off"
      }
    }

The `next/core-web-vitals` rule set is enabled when `next lint` is run for the
first time and the **strict** option is selected.

    
    
    {
      "extends": "next/core-web-vitals"
    }

`next/core-web-vitals` updates `eslint-plugin-next` to error on a number of
rules that are warnings by default if they affect Core Web Vitals.

> The `next/core-web-vitals` entry point is automatically included for new
> applications built with Create Next App.

ESLint also contains code formatting rules, which can conflict with your
existing Prettier setup. We recommend including eslint-config-prettier in your
ESLint config to make ESLint and Prettier work together.

First, install the dependency:

    
    
    npm install --save-dev eslint-config-prettier
     
    yarn add --dev eslint-config-prettier

Then, add `prettier` to your existing ESLint config:

    
    
    {
      "extends": ["next", "prettier"]
    }

If you would like to use `next lint` with lint-staged to run the linter on
staged git files, you'll have to add the following to the `.lintstagedrc.js`
file in the root of your project in order to specify usage of the `--file`
flag.

    
    
    const path = require('path');
     
    const buildEslintCommand = (filenames) =>
      `next lint --fix --file ${filenames
        .map((f) => path.relative(process.cwd(), f))
        .join(' --file ')}`;
     
    module.exports = {
      '*.{js,jsx,ts,tsx}': [buildEslintCommand],
    };

If you already have ESLint configured in your application and any of the
following conditions are true:

  * You have one or more of the following plugins already installed (either separately or through a different config such as `airbnb` or `react-app`): 
    * `react`
    * `react-hooks`
    * `jsx-a11y`
    * `import`
  * You've defined specific `parserOptions` that are different from how Babel is configured within Next.js (this is not recommended unless you have customized your Babel configuration)
  * You have `eslint-plugin-import` installed with Node.js and/or TypeScript resolvers defined to handle imports

Then we recommend either removing these settings if you prefer how these
properties have been configured within `eslint-config-next` or extending
directly from the Next.js ESLint plugin instead:

    
    
    module.exports = {
      extends: [
        //...
        'plugin:@next/next/recommended',
      ],
    };

The plugin can be installed normally in your project without needing to run
`next lint`:

    
    
    npm install --save-dev @next/eslint-plugin-next
     
    yarn add --dev @next/eslint-plugin-next

This eliminates the risk of collisions or errors that can occur due to
importing the same plugin or parser across multiple configurations.

If you already use a separate ESLint configuration and want to include
`eslint-config-next`, ensure that it is extended last after other
configurations. For example:

    
    
    {
      "extends": ["eslint:recommended", "next"]
    }

The `next` configuration already handles setting default values for the
`parser`, `plugins` and `settings` properties. There is no need to manually
re-declare any of these properties unless you need a different configuration
for your use case.

If you include any other shareable configurations, **you will need to make
sure that these properties are not overwritten or modified**. Otherwise, we
recommend removing any configurations that share behavior with the `next`
configuration or extending directly from the Next.js ESLint plugin as
mentioned above.





# Environment Variables

 **Examples**

Next.js comes with built-in support for environment variables, which allows
you to do the following:

Next.js has built-in support for loading environment variables from
`.env.local` into `process.env`.

    
    
    DB_HOST=localhost
    DB_USER=myuser
    DB_PASS=mypassword

This loads `process.env.DB_HOST`, `process.env.DB_USER`, and
`process.env.DB_PASS` into the Node.js environment automatically allowing you
to use them in Route Handlers.

Next.js will automatically expand variables that use `$` to reference other
variables e.g. `$VARIABLE` inside of your `.env*` files. This allows you to
reference other secrets. For example:

    
    
    HOSTNAME=localhost
    PORT=8080
    HOST=http://$HOSTNAME:$PORT

In the above example, `process.env.HOST` would be set to
`http://localhost:8080`.

> **Note** : If you need to use variable with a `$` in the actual value, it
> needs to be escaped e.g. `\$`.

By default environment variables are only available in the Node.js
environment, meaning they won't be exposed to the browser.

In order to expose a variable to the browser you have to prefix the variable
with `NEXT_PUBLIC_`. For example:

    
    
    NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk

This loads `process.env.NEXT_PUBLIC_ANALYTICS_ID` into the Node.js environment
automatically, allowing you to use it anywhere in your code. The value will be
inlined into JavaScript sent to the browser because of the `NEXT_PUBLIC_`
prefix. This inlining occurs at build time, so your various `NEXT_PUBLIC_`
envs need to be set when the project is built.

    
    
    import setupAnalyticsService from '../lib/my-analytics-service';
     
    // 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.
    // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.
    setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID);
     
    function HomePage() {
      return <h1>Hello World</h1>;
    }
     
    export default HomePage;

Note that dynamic lookups will _not_ be inlined, such as:

    
    
    // This will NOT be inlined, because it uses a variable
    const varName = 'NEXT_PUBLIC_ANALYTICS_ID';
    setupAnalyticsService(process.env[varName]);
     
    // This will NOT be inlined, because it uses a variable
    const env = process.env;
    setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID);

In general only one `.env.local` file is needed. However, sometimes you might
want to add some defaults for the `development` (`next dev`) or `production`
(`next start`) environment.

Next.js allows you to set defaults in `.env` (all environments),
`.env.development` (development environment), and `.env.production`
(production environment).

`.env.local` always overrides the defaults set.

> **Note** : `.env`, `.env.development`, and `.env.production` files should be
> included in your repository as they define defaults. **`.env*.local` should
> be added to `.gitignore`**, as those files are intended to be ignored.
> `.env.local` is where secrets can be stored.

When deploying your Next.js application to Vercel, Environment Variables can
be configured in the Project Settings.

All types of Environment Variables should be configured there. Even
Environment Variables used in Development – which can be downloaded onto your
local device afterwards.

If you've configured Development Environment Variables you can pull them into
a `.env.local` for usage on your local machine using the following command:

    
    
    vercel env pull .env.local

Apart from `development` and `production` environments, there is a 3rd option
available: `test`. In the same way you can set defaults for development or
production environments, you can do the same with a `.env.test` file for the
`testing` environment (though this one is not as common as the previous two).
Next.js will not load environment variables from `.env.development` or
`.env.production` in the `testing` environment.

This one is useful when running tests with tools like `jest` or `cypress`
where you need to set specific environment vars only for testing purposes.
Test default values will be loaded if `NODE_ENV` is set to `test`, though you
usually don't need to do this manually as testing tools will address it for
you.

There is a small difference between `test` environment, and both `development`
and `production` that you need to bear in mind: `.env.local` won't be loaded,
as you expect tests to produce the same results for everyone. This way every
test execution will use the same env defaults across different executions by
ignoring your `.env.local` (which is intended to override the default set).

> **Note** : similar to Default Environment Variables, `.env.test` file should
> be included in your repository, but `.env.test.local` shouldn't, as
> `.env*.local` are intended to be ignored through `.gitignore`.

While running unit tests you can make sure to load your environment variables
the same way Next.js does by leveraging the `loadEnvConfig` function from the
`@next/env` package.

    
    
    // The below can be used in a Jest global setup file or similar for your testing set-up
    import { loadEnvConfig } from '@next/env';
     
    export default async () => {
      const projectDir = process.cwd();
      loadEnvConfig(projectDir);
    };

Environment variables are looked up in the following places, in order,
stopping once the variable is found.

  1. `process.env`
  2. `.env.$(NODE_ENV).local`
  3. `.env.local` (Not checked when `NODE_ENV` is `test`.)
  4. `.env.$(NODE_ENV)`
  5. `.env`

For example, if `NODE_ENV` is `development` and you define a variable in both
`.env.development.local` and `.env`, the value in `.env.development.local`
will be used.

> **Note** : The allowed values for `NODE_ENV` are `production`, `development`
> and `test`.

  * If you are using a `/src` directory, `env.*` files should remain in the root of your project.





# Absolute Imports and Module Path Aliases

 **Examples**

Next.js has in-built support for the `"paths"` and `"baseUrl"` options of
`tsconfig.json` and `jsconfig.json` files.

These options allow you to alias project directories to absolute paths, making
it easier to import modules. For example:

    
    
    // before
    import { Button } from '../../../components/button';
     
    // after
    import { Button } from '@/components/button';

> **Good to know** : `create-next-app` will prompt to configure these options
> for you.

The `baseUrl` configuration option allows you to import directly from the root
of the project.

An example of this configuration:

    
    
    {
      "compilerOptions": {
        "baseUrl": "."
      }
    }
    
    
    export default function Button() {
      return <button>Click me</button>;
    }
    
    
    import Button from 'components/button';
     
    export default function HomePage() {
      return (
        <>
          <h1>Hello World</h1>
          <Button />
        </>
      );
    }

In addition to configuring the `baseUrl` path, you can use the `"paths"`
option to "alias" module paths.

For example, the following configuration maps `@/components/*` to
`components/*`:

    
    
    {
      "compilerOptions": {
        "baseUrl": ".",
        "paths": {
          "@/components/*": ["components/*"]
        }
      }
    }
    
    
    export default function Button() {
      return <button>Click me</button>;
    }
    
    
    import Button from '@/components/button';
     
    export default function HomePage() {
      return (
        <>
          <h1>Hello World</h1>
          <Button />
        </>
      );
    }





# MDX

Markdown is a lightweight markup language used to format text. It allows you
to write using plain text syntax and convert it to structurally valid HTML.
It's commonly used for writing content on websites and blogs.

You write...

    
    
    I **love** using [Next.js](https://nextjs.org/)

Output:

    
    
    <p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>

MDX is a superset of markdown that lets you write JSX directly in your
markdown files. It is a powerful way to add dynamic interactivity and embed
React components within your content.

Next.js can support both local MDX content inside your application, as well as
remote MDX files fetched dynamically on the server. The Next.js plugin handles
tranforming Markdown and React components into HTML, including support for
usage in Server Components (default in `app`).

The `@next/mdx` package is configured in the `next.config.js` file at your
projects root. **It sources data from local files** , allowing you to create
pages with a `.mdx` extension, directly in your `/pages` or `/app` directory.

Install the `@next/mdx` package:

    
    
    npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx

Create `mdx-components.tsx` in the root of your application (the parent folder
of `app`):

    
    
    import type { MDXComponents } from 'mdx/types';
     
    // This file allows you to provide custom React components
    // to be used in MDX files. You can import and use any
    // React component you want, including components from
    // other libraries.
     
    // This file is required to use MDX in `app` directory.
    export function useMDXComponents(components: MDXComponents): MDXComponents {
      return {
        // Allows customizing built-in components, e.g. to add styling.
        // h1: ({ children }) => <h1 style={{ fontSize: "100px" }}>{children}</h1>,
        ...components,
      };
    }

Update `next.config.js` to use `mdxRs`:

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        mdxRs: true,
      },
    };
     
    const withMDX = require('@next/mdx')();
    module.exports = withMDX(nextConfig);

Add a new file with MDX content to your `app` directory:

    
    
    Hello, Next.js!
     
    You can import and use React components in MDX files.

Import the MDX file inside a `page` to display the content:

    
    
    import HelloWorld from './hello.mdx';
     
    export default function Page() {
      return <HelloWorld />;
    }

If your Markdown or MDX files do _not_ live inside your application, you can
fetch them dynamically on the server. This is useful for fetching content from
a CMS or other data source.

There are two popular community packages for fetching MDX content: `next-mdx-
remote` and `contentlayer`. For example, the following example uses `next-mdx-
remote`:

> **Note:** Please proceed with caution. MDX compiles to JavaScript and is
> executed on the server. You should only fetch MDX content from a trusted
> source, otherwise this can lead to remote code execution (RCE).
    
    
    import { MDXRemote } from 'next-mdx-remote/rsc';
     
    export default async function Home() {
      const res = await fetch('https://...');
      const markdown = await res.text();
      return <MDXRemote source={markdown} />;
    }

To share a layout around MDX content, you can use the built-in layouts support
with the App Router.

You can optionally provide `remark` and `rehype` plugins to transform the MDX
content. For example, you can use `remark-gfm` to support GitHub Flavored
Markdown.

Since the `remark` and `rehype` ecosystem is ESM only, you'll need to use
`next.config.mjs` as the configuration file.

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        appDir: true,
      },
    };
     
    const withMDX = require('@next/mdx')({
      options: {
        remarkPlugins: [],
        rehypePlugins: [],
        // If you use `MDXProvider`, uncomment the following line.
        // providerImportSource: "@mdx-js/react",
      },
    });
    module.exports = withMDX(nextConfig);

Frontmatter is a YAML like key/value pairing that can be used to store data
about a page. `@next/mdx` does **not** support frontmatter by default, though
there are many solutions for adding frontmatter to your MDX content, such as
gray-matter.

To access page metadata with `@next/mdx`, you can export a meta object from
within the `.mdx` file:

    
    
    export const meta = {
      author: 'Rich Haines',
    };
     
    # My MDX page

One of the pleasant aspects of using markdown, is that it maps to native
`HTML` elements, making writing fast, and intuitive:

    
    
    This is a list in markdown:
     
    - One
    - Two
    - Three

The above generates the following `HTML`:

    
    
    <p>This is a list in markdown:</p>
     
    <ul>
      <li>One</li>
      <li>Two</li>
      <li>Three</li>
    </ul>

When you want to style your own elements to give a custom feel to your website
or application, you can pass in shortcodes. These are your own custom
components that map to `HTML` elements. To do this you use the `MDXProvider`
and pass a components object as a prop. Each object key in the components
object maps to a `HTML` element name.

To enable you need to specify `providerImportSource: "@mdx-js/react"` in
`next.config.js`.

    
    
    const withMDX = require('@next/mdx')({
      // ...
      options: {
        providerImportSource: '@mdx-js/react',
      },
    });

Then setup the provider in your page

    
    
     
    import { MDXProvider } from '@mdx-js/react'
    import Image from 'next/image'
    import { Heading, InlineCode, Pre, Table, Text } from 'my-components'
     
    const ResponsiveImage = (props) => (
      <Image alt={props.alt} sizes="100vw" style={ width: '100%', height: 'auto' }  {...props} />
    )
     
    const components = {
      img: ResponsiveImage,
      h1: Heading.H1,
      h2: Heading.H2,
      p: Text,
      pre: Pre,
      code: InlineCode,
    }
     
    export default function Post(props) {
      return (
        <MDXProvider components={components}>
          <main {...props} />
        </MDXProvider>
      )
    }

If you use it across the site you may want to add the provider to `_app.js` so
all MDX pages pick up the custom element config.

React does not natively understand Markdown. The markdown plaintext needs to
first be transformed into HTML. This can be accomplished with `remark` and
`rehype`.

`remark` is an ecosystem of tools around markdown. `rehype` is the same, but
for HTML. For example, the following code snippet transforms markdown into
HTML:

    
    
    import { unified } from 'unified';
    import remarkParse from 'remark-parse';
    import remarkRehype from 'remark-rehype';
    import rehypeSanitize from 'rehype-sanitize';
    import rehypeStringify from 'rehype-stringify';
     
    main();
     
    async function main() {
      const file = await unified()
        .use(remarkParse) // Convert into markdown AST
        .use(remarkRehype) // Transform to HTML AST
        .use(rehypeSanitize) // Sanitize HTML input
        .use(rehypeStringify) // Convert AST into serialized HTML
        .process('Hello, Next.js!');
     
      console.log(String(file)); // <p>>Hello, Next.js!</p>
    }

The `remark` and `rehype` ecosystem contains plugins for syntax highlighting,
linking headings, generating a table of contents, and more.

When using `@next/mdx` as shown below, you **do not** need to use `remark` or
`rehype` directly, as it is handled for you.

Next.js supports a new MDX compiler written in Rust. This compiler is still
experimental and is not recommended for production use. To use the new
compiler, you need to configure `next.config.js` when you pass it to
`withMDX`:

    
    
    module.exports = withMDX({
      experimental: {
        mdxRs: true,
      },
    });





Using App Router

Features available in /app



  
  
# Draft Mode

Static rendering is useful when your pages fetch data from a headless CMS.
However, it’s not ideal when you’re writing a draft on your headless CMS and
want to view the draft immediately on your page. You’d want Next.js to render
these pages at **request time** instead of build time and fetch the draft
content instead of the published content. You’d want Next.js to to switch to
dynamic rendering only for this specific case.

Next.js has a feature called **Draft Mode** which solves this problem. Here
are instructions on how to use it.

First, create a Route Handler. It can have any name - e.g.
`app/api/draft/route.ts`

Then, import `draftMode` from `next/headers` and call the `enable()` method.

    
    
    // route handler enabling draft mode
    import { draftMode } from 'next/headers';
     
    export async function GET(request: Request) {
      draftMode().enable();
      return new Response('Draft mode is enabled');
    }

This will set a **cookie** to enable draft mode. Subsequent requests
containing this cookie will trigger **Draft Mode** changing the behavior for
statically generated pages (more on this later).

You can test this manually by visiting `/api/draft` and looking at your
browser’s developer tools. Notice the `Set-Cookie` response header with a
cookie named `__prerender_bypass`.

In practice, you’d want to call this Route Handler _securely_ from your
headless CMS. The specific steps will vary depending on which headless CMS
you’re using, but here are some common steps you could take.

These steps assume that the headless CMS you’re using supports setting
**custom draft URLs**. If it doesn’t, you can still use this method to secure
your draft URLs, but you’ll need to construct and access the draft URL
manually.

**First** , you should create a **secret token string** using a token
generator of your choice. This secret will only be known by your Next.js app
and your headless CMS. This secret prevents people who don’t have access to
your CMS from accessing draft URLs.

**Second** , if your headless CMS supports setting custom draft URLs, specify
the following as the draft URL. This assumes that your Route Handler is
located at `app/api/draft/route.ts`

    
    
    https://<your-site>/api/draft?secret=<token>&slug=<path>

  * `<your-site>` should be your deployment domain.
  * `<token>` should be replaced with the secret token you generated.
  * `<path>` should be the path for the page that you want to view. If you want to view `/posts/foo`, then you should use `&slug=/posts/foo`.

Your headless CMS might allow you to include a variable in the draft URL so
that `<path>` can be set dynamically based on the CMS’s data like so:
`&slug=/posts/{entry.fields.slug}`

**Finally** , in the Route Handler:

  * Check that the secret matches and that the `slug` parameter exists (if not, the request should fail).
  * Call `draftMode.enable()` to set the cookie.
  * Then redirect the browser to the path specified by `slug`.

    
    
    // route handler with secret and slug
    import { draftMode } from 'next/headers';
    import { redirect } from 'next/navigation';
     
    export async function GET(request: Request) {
      // Parse query string parameters
      const { searchParams } = new URL(request.url);
      const secret = searchParams.get('secret');
      const slug = searchParams.get('slug');
     
      // Check the secret and next parameters
      // This secret should only be known to this route handler and the CMS
      if (secret !== 'MY_SECRET_TOKEN' || !slug) {
        return new Response('Invalid token', { status: 401 });
      }
     
      // Fetch the headless CMS to check if the provided `slug` exists
      // getPostBySlug would implement the required fetching logic to the headless CMS
      const post = await getPostBySlug(slug);
     
      // If the slug doesn't exist prevent draft mode from being enabled
      if (!post) {
        return new Response('Invalid slug', { status: 401 });
      }
     
      // Enable Draft Mode by setting the cookie
      draftMode().enable();
     
      // Redirect to the path from the fetched post
      // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities
      redirect(post.slug);
    }

If it succeeds, then the browser will be redirected to the path you want to
view with the draft mode cookie.

The next step is to update your page to check the value of
`draftMode().isEnabled`.

If you request a page which has the cookie set, then data will be fetched at
**request time** (instead of at build time).

Furthermore, the value of `isEnabled` will be `true`.

    
    
    // page that fetches data
    import { draftMode } from 'next/headers';
     
    async function getData() {
      const { isEnabled } = draftMode();
     
      const url = isEnabled
        ? 'https://draft.example.com'
        : 'https://production.example.com';
     
      const res = await fetch(url);
     
      return res.json();
    }
     
    export default async function Page() {
      const { title, desc } = await getData();
     
      return (
        <main>
          <h1>{title}</h1>
          <p>{desc}</p>
        </main>
      );
    }

That's it! If you access the draft Route Handler (with `secret` and `slug`)
from your headless CMS or manually, you should now be able to see the draft
content. And if you update your draft without publishing, you should be able
to view the draft.

Set this as the draft URL on your headless CMS or access manually, and you
should be able to see the draft.

    
    
    https://<your-site>/api/draft?secret=<token>&slug=<path>

By default, the Draft Mode session ends when the browser is closed.

To clear the Draft Mode cookie manually, create a Route Handler that calls
`draftMode().disable()`:

    
    
    import { draftMode } from 'next/headers';
     
    export async function GET(request: Request) {
      draftMode().disable();
      return new Response('Draft mode is disabled');
    }

Then, send a request to `/api/disable-draft` to invoke the Route Handler. If
calling this route using `next/link`, you must pass `prefetch={false}` to
prevent accidentally deleting the cookie on prefetch.

A new bypass cookie value will be generated each time you run `next build`.

This ensures that the bypass cookie can’t be guessed.

> **Note** : To test Draft Mode locally over HTTP, your browser will need to
> allow third-party cookies and local storage access.





# Deploying

Congratulations! You're here because you are ready to deploy your Next.js
application. This page will show how to deploy either managed or self-hosted
using the Next.js Build API.

`next build` generates an optimized version of your application for
production. This standard output includes:

  * HTML files for pages using `getStaticProps` or Automatic Static Optimization
  * CSS files for global styles or for individually scoped styles
  * JavaScript for pre-rendering dynamic content from the Next.js server
  * JavaScript for interactivity on the client-side through React

This output is generated inside the `.next` folder:

  * `.next/static/chunks/pages` – Each JavaScript file inside this folder relates to the route with the same name. For example, `.next/static/chunks/pages/about.js` would be the JavaScript file loaded when viewing the `/about` route in your application
  * `.next/static/media` – Statically imported images from `next/image` are hashed and copied here
  * `.next/static/css` – Global CSS files for all pages in your application
  * `.next/server/pages` – The HTML and JavaScript entry points prerendered from the server. The `.nft.json` files are created when Output File Tracing is enabled and contain all the file paths that depend on a given page.
  * `.next/server/chunks` – Shared JavaScript chunks used in multiple places throughout your application
  * `.next/cache` – Output for the build cache and cached images, responses, and pages from the Next.js server. Using a cache helps decrease build times and improve performance of loading images

All JavaScript code inside `.next` has been **compiled** and browser bundles
have been **minified** to help achieve the best performance and support all
modern browsers.

Vercel is the fastest way to deploy your Next.js application with zero
configuration.

When deploying to Vercel, the platform automatically detects Next.js, runs
`next build`, and optimizes the build output for you, including:

In addition, Vercel provides features like:

Deploy a Next.js application to Vercel for free to try it out.

You can self-host Next.js with support for all features using Node.js or
Docker. You can also do a Static HTML Export, which has some limitations.

Next.js can be deployed to any hosting provider that supports Node.js. For
example, AWS EC2 or a DigitalOcean Droplet.

First, ensure your `package.json` has the `"build"` and `"start"` scripts:

    
    
    {
      "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start"
      }
    }

Then, run `npm run build` to build your application. Finally, run `npm run
start` to start the Node.js server. This server supports all features of
Next.js.

> If you are using `next/image`, consider adding `sharp` for more performant
> Image Optimization in your production environment by running `npm install
> sharp` in your project directory. On Linux platforms, `sharp` may require
> additional configuration to prevent excessive memory usage.

Next.js can be deployed to any hosting provider that supports Docker
containers. You can use this approach when deploying to container
orchestrators such as Kubernetes or HashiCorp Nomad, or when running inside a
single node in any cloud provider.

  1. Install Docker on your machine
  2. Clone the with-docker example
  3. Build your container: `docker build -t nextjs-docker .`
  4. Run your container: `docker run -p 3000:3000 nextjs-docker`

If you need to use different Environment Variables across multiple
environments, check out our with-docker-multi-env example.

If you’d like to do a static HTML export of your Next.js app, follow the
directions on our Static HTML Export documentation.

The following services support Next.js `v12+`. Below, you’ll find examples or
guides to deploy Next.js to each service.

> **Note** : There are also managed platforms that allow you to use a
> Dockerfile as shown in the example above.

The following services only support deploying Next.js using `output:
'export'`.

You can also manually deploy the output from `output: 'export'` to any static
hosting provider, often through your CI/CD pipeline like GitHub Actions,
Jenkins, AWS CodeBuild, Circle CI, Azure Pipelines, and more.

> **Note** : Not all serverless providers implement the Next.js Build API from
> `next start`. Please check with the provider to see what features are
> supported.

When you deploy your Next.js application, you want to see the latest version
without needing to reload.

Next.js will automatically load the latest version of your application in the
background when routing. For client-side navigations, `next/link` will
temporarily function as a normal `<a>` tag.

**Note** : If a new page (with an old version) has already been prefetched by
`next/link`, Next.js will use the old version. Navigating to a page that has
_not_ been prefetched (and is not cached at the CDN level) will load the
latest version.

Sometimes you might want to run some cleanup code on process signals like
`SIGTERM` or `SIGINT`.

You can do that by setting the env variable `NEXT_MANUAL_SIG_HANDLE` to `true`
and then register a handler for that signal inside your `_document.js` file.
Please note that you need to register env variable directly in the system env
variable, not in the `.env` file.

    
    
    {
      "scripts": {
        "dev": "NEXT_MANUAL_SIG_HANDLE=true next dev",
        "build": "next build",
        "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
      }
    }
    
    
    if (process.env.NEXT_MANUAL_SIG_HANDLE) {
      // this should be added in your custom _document
      process.on('SIGTERM', () => {
        console.log('Received SIGTERM: ', 'cleaning up');
        process.exit(0);
      });
     
      process.on('SIGINT', () => {
        console.log('Received SIGINT: ', 'cleaning up');
        process.exit(0);
      });
    }





# Static Exports

Next.js enables starting as a static site or Single-Page Application (SPA),
then later optionally upgrading to use features that require a server.

When running `next build`, Next.js generates an HTML file per route. By
breaking a strict SPA into individual HTML files, Next.js can avoid loading
unnecessary JavaScript code on the client-side, reducing the bundle size and
enabling faster page loads.

Since Next.js supports this static export, it can be deployed and hosted on
any web server that can serve HTML/CSS/JS static assets.

To enable a static export, change the output mode inside `next.config.js`:

    
    
    /**
     * @type {import('next').NextConfig}
     */
    const nextConfig = {
      output: 'export',
      // Optional: Add a trailing slash to all paths `/about` -> `/about/`
      // trailingSlash: true,
      // Optional: Change the output directory `out` -> `dist`
      // distDir: 'dist',
    };
     
    module.exports = nextConfig;

After running `next build`, Next.js will produce an `out` folder which
contains the HTML/CSS/JS assets for your application.

The core of Next.js has been designed to support static exports.

When you run `next build` to generate a static export, Server Components
consumed inside the `app` directory will run during the build, similar to
traditional static-site generation.

The resulting component will be rendered into static HTML for the initial page
load and a static payload for client navigation between routes. No changes are
required for your Server Components when using the static export, unless they
consume dynamic server functions.

    
    
    export default async function Page() {
      // This fetch will run on the server during `next build`
      const res = await fetch('https://api.example.com/...');
      const data = await res.json();
     
      return <main>...</main>;
    }

If you want to perform data fetching on the client, you can use a Client
Component with SWR to deduplicate requests.

    
    
    'use client';
     
    import useSWR from 'swr';
     
    const fetcher = (url: string) => fetch(url).then((r) => r.json());
     
    export default function Page() {
      const { data, error } = useSWR(
        `https://jsonplaceholder.typicode.com/posts/1`,
        fetcher,
      );
      if (error) return 'Failed to load';
      if (!data) return 'Loading...';
     
      return data.title;
    }

Since route transitions happen client-side, this behaves like a traditional
SPA. For example, the following index route allows you to navigate to
different posts on the client:

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return (
        <>
          <h1>Index Page</h1>
          <hr />
          <ul>
            <li>
              <Link href="/post/1">Post 1</Link>
            </li>
            <li>
              <Link href="/post/2">Post 2</Link>
            </li>
          </ul>
        </>
      );
    }

Image Optimization through `next/image` can be used with a static export by
defining a custom image loader in `next.config.js`. For example, you can
optimize images with a service like Cloudinary:

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      output: 'export',
      images: {
        loader: 'custom',
        loaderFile: './app/image.ts',
      },
    };
     
    module.exports = nextConfig;

This custom loader will define how to fetch images from a remote source. For
example, the following loader will construct the URL for Cloudinary:

    
    
    export default function cloudinaryLoader({
      src,
      width,
      quality,
    }: {
      src: string;
      width: number;
      quality?: number;
    }) {
      const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
      return `https://res.cloudinary.com/demo/image/upload/${params.join(
        ',',
      )}${src}`;
    }

You can then use `next/image` in your application, defining relative paths to
the image in Cloudinary:

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return <Image alt="turtles" src="/turtles.jpg" width={300} height={300} />;
    }

Route Handlers will render a static response when running `next build`. Only
the `GET` HTTP verb is supported. This can be used to generate static HTML,
JSON, TXT, or other files from dynamic or static data. For example:

    
    
    import { NextResponse } from 'next/server';
     
    export async function GET() {
      return NextResponse.json({ name: 'Lee' });
    }

The above file `app/data.json/route.ts` will render to a static file during
`next build`, producing `data.json` containing `{ name: 'Lee' }`.

If you need to read dynamic values from the incoming request, you cannot use a
static export.

Client Components are pre-rendered to HTML during `next build`. Because Web
APIs like `window`, `localStorage`, and `navigator` are not available on the
server, you need to safely access these APIs only when running in the browser.
For example:

    
    
    'use client';
     
    import { useEffect } from 'react';
     
    export default function ClientComponent() {
      useEffect(() => {
        // You now have access to `window`
        console.log(window.innerHeight);
      }, [])
     
      return ...;
    }

After enabling the static export `output` mode, all routes inside `app` are
opted-into the following Route Segment Config:

    
    
    export const dynamic = 'error';

With this configuration, your application **will produce an error** if you try
to use server functions like `headers` or `cookies`, since there is no runtime
server. This ensures local development matches the same behavior as a static
export. If you need to use server functions, you cannot use a static export.

The following additional dynamic features are not supported with a static
export:

With a static export, Next.js can be deployed and hosted on any web server
that can serve HTML/CSS/JS static assets.

When running `next build`, Next.js generates the static export into the `out`
folder. Using `next export` is no longer needed. For example, let's say you
have the following routes:

After running `next build`, Next.js will generate the following files:

  * `/out/index.html`
  * `/out/404.html`
  * `/out/blog/post-1.html`
  * `/out/blog/post-2.html`

If you are using a static host like Nginx, you can configure rewrites from
incoming requests to the correct files:

    
    
    server {
      listen 80;
      server_name acme.com;
     
      root /var/www;
     
      location / {
          try_files /out/index.html =404;
      }
     
      location /blog/ {
          rewrite ^/blog/(.*)$ /out/blog/$1.html break;
      }
     
      error_page 404 /out/404.html;
      location = /404.html {
          internal;
      }
    }

Version| Changes  
---|---  
`v13.4.0`| App Router (Stable) adds enhanced static export support, including
using React Server Components and Route Handlers  
`v13.3.0`| `next export` is deprecated and replaced with `"output": "export"`





Using App Router

Features available in /app





# Codemods

Codemods are transformations that run on your codebase programmatically. This
allows a large number of changes to be programmatically applied without having
to manually go through every file.

Next.js provides Codemod transformations to help upgrade your Next.js codebase
when an API is updated or deprecated.

In your terminal, navigate (`cd`) into your project's folder, then run:

    
    
    npx @next/codemod <transform> <path>

Replacing `<transform>` and `<path>` with appropriate values.

  * `transform` \- name of transform
  * `path` \- files or directory to transform
  * `--dry` Do a dry-run, no code will be edited
  * `--print` Prints the changed output for comparison

    
    
    npx @next/codemod@latest built-in-next-font

This codemod uninstalls the `@next/font` package and transforms `@next/font`
imports into the built-in `next/font`.

For example:

    
    
    import { Inter } from '@next/font/google';

Transforms into:

    
    
    import { Inter } from 'next/font/google';
    
    
    npx @next/codemod@latest next-image-to-legacy-image ./pages

Safely renames `next/image` imports in existing Next.js 10, 11, or 12
applications to `next/legacy/image` in Next.js 13. Also renames
`next/future/image` to `next/image`.

For example:

    
    
    import Image1 from 'next/image';
    import Image2 from 'next/future/image';
     
    export default function Home() {
      return (
        <div>
          <Image1 src="/test.jpg" width="200" height="300" />
          <Image2 src="/test.png" width="500" height="400" />
        </div>
      );
    }

Transforms into:

    
    
    // 'next/image' becomes 'next/legacy/image'
    import Image1 from 'next/legacy/image';
    // 'next/future/image' becomes 'next/image'
    import Image2 from 'next/image';
     
    export default function Home() {
      return (
        <div>
          <Image1 src="/test.jpg" width="200" height="300" />
          <Image2 src="/test.png" width="500" height="400" />
        </div>
      );
    }
    
    
    npx @next/codemod@latest next-image-experimental ./pages

Dangerously migrates from `next/legacy/image` to the new `next/image` by
adding inline styles and removing unused props.

  * Removes `layout` prop and adds `style`.
  * Removes `objectFit` prop and adds `style`.
  * Removes `objectPosition` prop and adds `style`.
  * Removes `lazyBoundary` prop.
  * Removes `lazyRoot` prop.

    
    
    npx @next/codemod@latest new-link ./pages

Remove `<a>` tags inside Link Components, or add a `legacyBehavior` prop to
Links that cannot be auto-fixed.

For example:

    
    
    <Link href="/about">
      <a>About</a>
    </Link>
    // transforms into
    <Link href="/about">
      About
    </Link>
     
    <Link href="/about">
      <a onClick={() => console.log('clicked')}>About</a>
    </Link>
    // transforms into
    <Link href="/about" onClick={() => console.log('clicked')}>
      About
    </Link>

In cases where auto-fixing can't be applied, the `legacyBehavior` prop is
added. This allows your app to keep functioning using the old behavior for
that particular link.

    
    
    const Component = () => <a>About</a>
     
    <Link href="/about">
      <Component />
    </Link>
    // becomes
    <Link href="/about" legacyBehavior>
      <Component />
    </Link>
    
    
    npx @next/codemod cra-to-next

Migrates a Create React App project to Next.js; creating a Pages Router and
necessary config to match behavior. Client-side only rendering is leveraged
initially to prevent breaking compatibility due to `window` usage during SSR
and can be enabled seamlessly to allow the gradual adoption of Next.js
specific features.

Please share any feedback related to this transform in this discussion.

    
    
    npx @next/codemod add-missing-react-import

Transforms files that do not import `React` to include the import in order for
the new React JSX transform to work.

For example:

    
    
    export default class Home extends React.Component {
      render() {
        return <div>Hello World</div>;
      }
    }

Transforms into:

    
    
    import React from 'react';
    export default class Home extends React.Component {
      render() {
        return <div>Hello World</div>;
      }
    }
    
    
    npx @next/codemod name-default-component

**Versions 9 and above.**

Transforms anonymous components into named components to make sure they work
with Fast Refresh.

For example:

    
    
    export default function () {
      return <div>Hello World</div>;
    }

Transforms into:

    
    
    export default function MyComponent() {
      return <div>Hello World</div>;
    }

The component will have a camel-cased name based on the name of the file, and
it also works with arrow functions.

    
    
    npx @next/codemod withamp-to-config

Transforms the `withAmp` HOC into Next.js 9 page configuration.

For example:

    
    
    // Before
    import { withAmp } from 'next/amp';
     
    function Home() {
      return <h1>My AMP Page</h1>;
    }
     
    export default withAmp(Home);
    
    
    // After
    export default function Home() {
      return <h1>My AMP Page</h1>;
    }
     
    export const config = {
      amp: true,
    };
    
    
    npx @next/codemod url-to-withrouter

Transforms the deprecated automatically injected `url` property on top level
pages to using `withRouter` and the `router` property it injects. Read more
here: https://nextjs.org/docs/messages/url-deprecated

For example:

    
    
    import React from 'react';
    export default class extends React.Component {
      render() {
        const { pathname } = this.props.url;
        return <div>Current pathname: {pathname}</div>;
      }
    }
    
    
    import React from 'react';
    import { withRouter } from 'next/router';
    export default withRouter(
      class extends React.Component {
        render() {
          const { pathname } = this.props.router;
          return <div>Current pathname: {pathname}</div>;
        }
      },
    );

This is one case. All the cases that are transformed (and tested) can be found
in the `__testfixtures__` directory.





# App Router Incremental Adoption Guide

This guide will help you:

The minimum Node.js version is now **v16.8**. See the Node.js documentation
for more information.

To update to Next.js version 13, run the following command using your
preferred package manager:

    
    
    npm install next@latest react@latest react-dom@latest

If you're using ESLint, you need to upgrade your ESLint version:

    
    
    npm install -D eslint-config-next@latest

> **Note:** You may need to restart the ESLint server in VS Code for the
> ESLint changes to take effect. Open the Command Palette (`cmd+shift+p` on
> Mac; `ctrl+shift+p` on Windows) and search for `ESLint: Restart ESLint
> Server`.

After you've updated, see the following sections for next steps:

Next.js 13 introduced the new App Router with new features and conventions.
The new Router is available in the `app` directory and co-exists with the
`pages` directory.

Upgrading to Next.js 13 does **not** require using the new App Router. You can
continue using `pages` with new features that work in both directories, such
as the updated Image component, Link component, Script component, and Font
optimization.

Next.js 12 introduced new improvements to the Image Component with a temporary
import: `next/future/image`. These improvements included less client-side
JavaScript, easier ways to extend and style images, better accessibility, and
native browser lazy loading.

In version 13, this new behavior is now the default for `next/image`.

There are two codemods to help you migrate to the new Image Component:

  * **`next-image-to-legacy-image` codemod**: Safely and automatically renames `next/image` imports to `next/legacy/image`. Existing components will maintain the same behavior.
  * **`next-image-experimental` codemod**: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run the `next-image-to-legacy-image` codemod first.

The `<Link>` Component no longer requires manually adding an `<a>` tag as a
child. This behavior was added as an experimental option in version 12.2 and
is now the default. In Next.js 13, `<Link>` always renders `<a>` and allows
you to forward props to the underlying tag.

For example:

    
    
    import Link from 'next/link'
     
    // Next.js 12: `<a>` has to be nested otherwise it's excluded
    <Link href="/about">
      <a>About</a>
    </Link>
     
    // Next.js 13: `<Link>` always renders `<a>` under the hood
    <Link href="/about">
      About
    </Link>

To upgrade your links to Next.js 13, you can use the `new-link` codemod.

The behavior of `next/script` has been updated to support both `pages` and
`app`, but some changes need to be made to ensure a smooth migration:

  * Move any `beforeInteractive` scripts you previously included in `_document.js` to the root layout file (`app/layout.tsx`).
  * The experimental `worker` strategy does not yet work in `app` and scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g. `lazyOnload`).
  * `onLoad`, `onReady`, and `onError` handlers will not work in Server Components so make sure to move them to a Client Component or remove them altogether.

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13
introduces the new `next/font` module which gives you the ability to customize
your font loading experience while still ensuring great performance and
privacy. `next/font` is supported in both the `pages` and `app` directories.

While inlining CSS still works in `pages`, it does not work in `app`. You
should use `next/font` instead.

See the Font Optimization page to learn how to use `next/font`.

Moving to the App Router may be the first time using React features that
Next.js builds on top of such as Server Components, Suspense, and more. When
combined with new Next.js features such as special files and layouts,
migration means new concepts, mental models, and behavioral changes to learn.

We recommend reducing the combined complexity of these updates by breaking
down your migration into smaller steps. The `app` directory is intentionally
designed to work simultaneously with the `pages` directory to allow for
incremental page-by-page migration.

  * The `app` directory supports nested routes _and_ layouts. Learn more.
  * Use nested folders to define routes and a special `page.js` file to make a route segment publicly accessible. Learn more.
  * Special file conventions are used to create UI for each route segment. The most common special files are `page.js` and `layout.js`. 
    * Use `page.js` to define UI unique to a route.
    * Use `layout.js` to define UI that is shared across multiple routes.
    * `.js`, `.jsx`, or `.tsx` file extensions can be used for special files.
  * You can colocate other files inside the `app` directory such as components, styles, tests, and more. Learn more.
  * Data fetching functions like `getServerSideProps` and `getStaticProps` have been replaced with a new API inside `app`. `getStaticPaths` has been replaced with `generateStaticParams`.
  * `pages/_app.js` and `pages/_document.js` have been replaced with a single `app/layout.js` root layout. Learn more.
  * `pages/_error.js` has been replaced with more granular `error.js` special files. Learn more.
  * `pages/404.js` has been replaced with the `not-found.js` file.
  * You can colocate other files inside the `app` directory such as components, styles, tests, and more. Learn more.
  * `pages/api/*` currently remain inside the `pages` directory.

Update to the latest Next.js version (requires 13.4 or greater):

Then, create a new `app` directory at the root of your project (or `src/`
directory).

Create a new `app/layout.tsx` file inside the `app` directory. This is a root
layout that will apply to all routes inside `app`.

    
    
    export default function RootLayout({
      // Layouts must accept a children prop.
      // This will be populated with nested layouts or pages
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

  * The `app` directory **must** include a root layout.
  * The root layout must define `<html>`, and `<body>` tags since Next.js does not automatically create them
  * The root layout replaces the `pages/_app.tsx` and `pages/_document.tsx` files.
  * `.js`, `.jsx`, or `.tsx` extensions can be used for layout files.

To manage `<head>` HTML elements, you can use the built-in SEO support:

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'Home',
      description: 'Welcome to Next.js',
    };

If you have an existing `_app` or `_document` file, you can copy the contents
(e.g. global styles) to the root layout (`app/layout.tsx`). Styles in
`app/layout.tsx` will _not_ apply to `pages/*`. You should keep
`_app`/`_document` while migrating to prevent your `pages/*` routes from
breaking. Once fully migrated, you can then safely delete them.

If you are using any React Context providers, they will need to be moved to a
Client Component.

Next.js recommended adding a property to Page components to achieve per-page
layouts in the `pages` directory. This pattern can be replaced with native
support for nested layouts in the `app` directory.

**See before and after example**

 **Before**

    
    
     export default function DashboardLayout({ children }) {
      return (
        <div>
          <h2>My Dashboard</h2>
          {children}
        </div>
      );
    }
    
    
    import DashboardLayout from '../components/DashboardLayout';
     
    export default function Page() {
      return <p>My Page</p>;
    }
     
    Page.getLayout = function getLayout(page) {
      return <DashboardLayout>{page}</DashboardLayout>;
    };

 **After**

  * Remove the `Page.getLayout` property from `pages/dashboard/index.js` and follow the steps for migrating pages to the `app` directory.
    
        export default function Page() {
      return <p>My Page</p>;
    }

  * Move the contents of `DashboardLayout` into a new Client Component to retain `pages` directory behavior.
    
        'use client'; // this directive should be at top of the file, before any imports.
     
    // This is a Client Component
    export default function DashboardLayout({ children }) {
      return (
        <div>
          <h2>My Dashboard</h2>
          {children}
        </div>
      );
    }

  * Import the `DashboardLayout` into a new `layout.js` file inside the `app` directory.
    
        import DashboardLayout from './DashboardLayout';
     
    // This is a Server Component
    export default function Layout({ children }) {
      return <DashboardLayout>{children}</DashboardLayout>;
    }

  * You can incrementally move non-interactive parts of `DashboardLayout.js` (Client Component) into `layout.js` (Server Component) to reduce the amount of component JavaScript you send to the client.

In the `pages` directory, the `next/head` React component is used to manage
`<head>` HTML elements such as `title` and `meta` . In the `app` directory,
`next/head` is replaced with the new built-in SEO support.

**Before:**

    
    
    import Head from 'next/head';
     
    export default function Page() {
      return (
        <>
          <Head>
            <title>My page title</title>
          </Head>
        </>
      );
    }

**After:**

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'My Page Title',
    };
     
    export default function Page() {
      return '...';
    }

See all metadata options.

  * Pages in the `app` directory are Server Components by default. This is different from the `pages` directory where pages are Client Components.
  * Data fetching has changed in `app`. `getServerSideProps`, `getStaticProps` and `getInitialProps` have been replaced for a simpler API.
  * The `app` directory uses nested folders to define routes and a special `page.js` file to make a route segment publicly accessible.
  * `pages` Directory| `app` Directory| Route  
---|---|---  
`index.js`| `page.js`| `/`  
`about.js`| `about/page.js`| `/about`  
`blog/[slug].js`| `blog/[slug]/page.js`| `/blog/post-1`  

We recommend breaking down the migration of a page into two main steps:

  * Step 1: Move the default exported Page Component into a new Client Component.
  * Step 2: Import the new Client Component into a new `page.js` file inside the `app` directory.

> **Note:** This is the easiest migration path because it has the most
> comparable behavior to the `pages` directory.

**Step 1: Create a new Client Component**

  * Create a new separate file inside the `app` directory (i.e. `app/home-page.tsx` or similar) that exports a Client Component. To define Client Components, add the `'use client'` directive to the top of the file (before any imports).
  * Move the default exported page component from `pages/index.js` to `app/home-page.tsx`.

    
    
    'use client';
     
    // This is a Client Component. It receives data as props and
    // has access to state and effects just like Page components
    // in the `pages` directory.
    export default function HomePage({ recentPosts }) {
      return (
        <div>
          {recentPosts.map((post) => (
            <div key={post.id}>{post.title}</div>
          ))}
        </div>
      );
    }

**Step 2: Create a new page**

  * Create a new `app/page.tsx` file inside the `app` directory. This is a Server Component by default.

  * Import the `home-page.tsx` Client Component into the page.

  * If you were fetching data in `pages/index.js`, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details.
    
        // Import your Client Component
    import HomePage from './home-page';
     
    async function getPosts() {
      const res = await fetch('https://...');
      const posts = await res.json();
      return posts;
    }
     
    export default async function Page() {
      // Fetch data directly in a Server Component
      const recentPosts = await getPosts();
      // Forward fetched data to your Client Component
      return <HomePage recentPosts={recentPosts} />;
    }

  * If your previous page used `useRouter`, you'll need to update to the new routing hooks. Learn more.

  * Start your development server and visit `http://localhost:3000`. You should see your existing index route, now served through the app directory.

A new router has been added to support the new behavior in the `app`
directory.

In `app`, you should use the three new hooks imported from `next/navigation`:
`useRouter()`, `usePathname()`, and `useSearchParams()`.

  * The new `useRouter` hook is imported from `next/navigation` and has different behavior to the `useRouter` hook in `pages` which is imported from `next/router`. 
  * The new `useRouter` does not return the `pathname` string. Use the separate `usePathname` hook instead.
  * The new `useRouter` does not return the `query` object. Use the separate `useSearchParams` hook instead.
  * You can use `useSearchParams` and `usePathname` together to listen to page changes. See the Router Events section for more details.
  * These new hooks are only supported in Client Components. They cannot be used in Server Components.

    
    
    'use client';
     
    import { useRouter, usePathname, useSearchParams } from 'next/navigation';
     
    export default function ExampleClientComponent() {
      const router = useRouter();
      const pathname = usePathname();
      const searchParams = useSearchParams();
     
      // ...
    }

In addition, the new `useRouter` hook has the following changes:

  * `isFallback` has been removed because `fallback` has been replaced.
  * The `locale`, `locales`, `defaultLocales`, `domainLocales` values have been removed because built-in i18n Next.js features are no longer necessary in the `app` directory. Learn more about i18n.
  * `basePath` has been removed. The alternative will not be part of `useRouter`. It has not yet been implemented.
  * `asPath` has been removed because the concept of `as` has been removed from the new router.
  * `isReady` has been removed because it is no longer necessary. During static rendering, any component that uses the `useSearchParams()` hook will skip the prerendering step and instead be rendered on the client at runtime.

View the `useRouter()` API reference.

The `pages` directory uses `getServerSideProps` and `getStaticProps` to fetch
data for pages. Inside the `app` directory, these previous data fetching
functions are replaced with a simpler API built on top of `fetch()` and
`async` React Server Components.

    
    
    export default async function Page() {
      // This request should be cached until manually invalidated.
      // Similar to `getStaticProps`.
      // `force-cache` is the default and can be omitted.
      const staticData = await fetch(`https://...`, { cache: 'force-cache' });
     
      // This request should be refetched on every request.
      // Similar to `getServerSideProps`.
      const dynamicData = await fetch(`https://...`, { cache: 'no-store' });
     
      // This request should be cached with a lifetime of 10 seconds.
      // Similar to `getStaticProps` with the `revalidate` option.
      const revalidatedData = await fetch(`https://...`, {
        next: { revalidate: 10 },
      });
     
      return <div>...</div>;
    }

In the `pages` directory, `getServerSideProps` is used to fetch data on the
server and forward props to the default exported React component in the file.
The initial HTML for the page is prerendered from the server, followed by
"hydrating" the page in the browser (making it interactive).

    
    
    // `pages` directory
     
    export async function getServerSideProps() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return { props: { projects } };
    }
     
    export default function Dashboard({ projects }) {
      return (
        <ul>
          {projects.map((project) => (
            <li key={project.id}>{project.name}</li>
          ))}
        </ul>
      );
    }

In the `app` directory, we can colocate our data fetching inside our React
components using Server Components. This allows us to send less JavaScript to
the client, while maintaining the rendered HTML from the server.

By setting the `cache` option to `no-store`, we can indicate that the fetched
data should never be cached. This is similar to `getServerSideProps` in the
`pages` directory.

    
    
    // `app` directory
     
    // This function can be named anything
    async function getProjects() {
      const res = await fetch(`https://...`, { cache: 'no-store' });
      const projects = await res.json();
     
      return projects;
    }
     
    export default async function Dashboard() {
      const projects = await getProjects();
     
      return (
        <ul>
          {projects.map((project) => (
            <li key={project.id}>{project.name}</li>
          ))}
        </ul>
      );
    }

In the `pages` directory, you can retrieve request-based data based on the
Node.js HTTP API.

For example, you can retrieve the `req` object from `getServerSideProps` and
use it to retrieve the request's cookies and headers.

    
    
    // `pages` directory
     
    export async function getServerSideProps({ req, query }) {
      const authHeader = req.getHeaders()['authorization'];
      const theme = req.cookies['theme'];
     
      return { props: { ... }}
    }
     
    export default function Page(props) {
      return ...
    }

The `app` directory exposes new read-only functions to retrieve request data:

    
    
    // `app` directory
    import { cookies, headers } from 'next/headers';
     
    async function getData() {
      const authHeader = headers().get('authorization');
     
      return '...';
    }
     
    export default async function Page() {
      // You can use `cookies()` or `headers()` inside Server Components
      // directly or in your data fetching function
      const theme = cookies().get('theme');
      const data = await getData();
      return '...';
    }

In the `pages` directory, the `getStaticProps` function is used to pre-render
a page at build time. This function can be used to fetch data from an external
API or directly from a database, and pass this data down to the entire page as
it's being generated during the build.

    
    
    // `pages` directory
     
    export async function getStaticProps() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return { props: { projects } };
    }
     
    export default function Index({ projects }) {
      return projects.map((project) => <div>{project.name}</div>);
    }

In the `app` directory, data fetching with `fetch()` will default to `cache:
'force-cache'`, which will cache the request data until manually invalidated.
This is similar to `getStaticProps` in the `pages` directory.

    
    
    // `app` directory
     
    // This function can be named anything
    async function getProjects() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return projects;
    }
     
    export default async function Index() {
      const projects = await getProjects();
     
      return projects.map((project) => <div>{project.name}</div>);
    }

In the `pages` directory, the `getStaticPaths` function is used to define the
dynamic paths that should be pre-rendered at build time.

    
    
    // `pages` directory
    import PostLayout from '@/components/post-layout';
     
    export async function getStaticPaths() {
      return {
        paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
      };
    }
     
    export async function getStaticProps({ params }) {
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      return { props: { post } };
    }
     
    export default function Post({ post }) {
      return <PostLayout post={post} />;
    }

In the `app` directory, `getStaticPaths` is replaced with
`generateStaticParams`.

`generateStaticParams` behaves similarly to `getStaticPaths`, but has a
simplified API for returning route parameters and can be used inside layouts.
The return shape of `generateStaticParams` is an array of segments instead of
an array of nested `param` objects or a string of resolved paths.

    
    
    // `app` directory
    import PostLayout from '@/components/post-layout';
     
    export async function generateStaticParams() {
      return [{ id: '1' }, { id: '2' }];
    }
     
    async function getPost(params) {
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      return post;
    }
     
    export default async function Post({ params }) {
      const post = await getPost(params);
     
      return <PostLayout post={post} />;
    }

Using the name `generateStaticParams` is more appropriate than
`getStaticPaths` for the new model in the `app` directory. The `get` prefix is
replaced with a more descriptive `generate`, which sits better alone now that
`getStaticProps` and `getServerSideProps` are no longer necessary. The `Paths`
suffix is replaced by `Params`, which is more appropriate for nested routing
with multiple dynamic segments.

* * *

In the `pages` directory, the `fallback` property returned from
`getStaticPaths` is used to define the behavior of a page that isn't pre-
rendered at build time. This property can be set to `true` to show a fallback
page while the page is being generated, `false` to show a 404 page, or
`blocking` to generate the page at request time.

    
    
    // `pages` directory
     
    export async function getStaticPaths() {
      return {
        paths: [],
        fallback: 'blocking'
      };
    }
     
    export async function getStaticProps({ params }) {
      ...
    }
     
    export default function Post({ post }) {
      return ...
    }

In the `app` directory the `config.dynamicParams` property controls how params
outside of `generateStaticParams` are handled:

  * **`true`** : (default) Dynamic segments not included in `generateStaticParams` are generated on demand.
  * **`false`** : Dynamic segments not included in `generateStaticParams` will return a 404.

This replaces the `fallback: true | false | 'blocking'` option of
`getStaticPaths` in the `pages` directory. The `fallback: 'blocking'` option
is not included in `dynamicParams` because the difference between `'blocking'`
and `true` is negligible with streaming.

    
    
    // `app` directory
     
    export const dynamicParams = true;
     
    export async function generateStaticParams() {
      return [...]
    }
     
    async function getPost(params) {
      ...
    }
     
    export default async function Post({ params }) {
      const post = await getPost(params);
     
      return ...
    }

With `dynamicParams` set to `true` (the default), when a route segment is
requested that hasn't been generated, it will be server-rendered and cached as
static data on success.

In the `pages` directory, the `getStaticProps` function allows you to add a
`revalidate` field to automatically regenerate a page after a certain amount
of time. This is called Incremental Static Regeneration (ISR) and helps you
update static content without redeploying.

    
    
    // `pages` directory
     
    export async function getStaticProps() {
      const res = await fetch(`https://.../posts`);
      const posts = await res.json();
     
      return {
        props: { posts },
        revalidate: 60,
      };
    }
     
    export default function Index({ posts }) {
      return (
        <Layout>
          <PostList posts={posts} />
        </Layout>
      );
    }

In the `app` directory, data fetching with `fetch()` can use `revalidate`,
which will cache the request for the specified amount of seconds.

    
    
    // `app` directory
     
    async function getPosts() {
      const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } });
      const data = await res.json();
     
      return data.posts;
    }
     
    export default async function PostList() {
      const posts = await getPosts();
     
      return posts.map((post) => <div>{post.name}</div>);
    }

API Routes continue to work in the `pages/api` directory without any changes.
However, they have been replaced by Route Handlers in the `app` directory.

Route Handlers allow you to create custom request handlers for a given route
using the Web Request and Response APIs.

    
    
    export async function GET(request: Request) {}

> **Note:** If you previously used API routes to call an external API from the
> client, you can now use Server Components instead to securely fetch data.
> Learn more about data fetching.

In the `pages` directory, global stylesheets are restricted to only
`pages/_app.js`. With the `app` directory, this restriction has been lifted.
Global styles can be added to any layout, page, or component.

If you're using Tailwind CSS, you'll need to add the `app` directory to your
`tailwind.config.js` file:

    
    
    module.exports = {
      content: [
        './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add this line
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
      ],
    };

You'll also need to import your global styles in your `app/layout.js` file:

    
    
    import '../styles/globals.css';
     
    export default function RootLayout({ children }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Learn more about styling with Tailwind CSS

Next.js provides Codemod transformations to help upgrade your codebase when a
feature is deprecated. See Codemods for more information.



  
  
Using App Router

Features available in /app



  
  
# Font Module

This API reference will help you understand how to use `next/font/google` and
`next/font/local`. For features and usage, please see the Optimizing Fonts
page.

For usage, review Google Fonts and Local Fonts.

The path of the font file as a string or an array of objects (with type
`Array<{path: string, weight?: string, style?: string}>`) relative to the
directory where the font loader function is called.

Used in `next/font/local`

Examples:

  * `src:'./fonts/my-font.woff2'` where `my-font.woff2` is placed in a directory named `fonts` inside the `app` directory
  * `src:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]`
  * if the font loader function is called in `app/page.tsx` using `src:'../styles/fonts/my-font.ttf'`, then `my-font.ttf` is placed in `styles/fonts` at the root of the project

The font `weight` with the following possibilities:

  * A string with possible values of the weights available for the specific font or a range of values if it's a variable font
  * An array of weight values if the font is not a variable google font. It applies to `next/font/google` only.

Used in `next/font/google` and `next/font/local`

  * Required if the font being used is **not** variable

Examples:

  * `weight: '400'`: A string for a single weight value - for the font `Inter`, the possible values are `'100'`, `'200'`, `'300'`, `'400'`, `'500'`, `'600'`, `'700'`, `'800'`, `'900'` or `'variable'` where `'variable'` is the default)
  * `weight: '100 900'`: A string for the range between `100` and `900` for a variable font
  * `weight: ['100','400','900']`: An array of 3 possible values for a non variable font

The font `style` with the following possibilities:

  * A string value with default value of `'normal'`
  * An array of style values if the font is not a variable google font. It applies to `next/font/google` only.

Used in `next/font/google` and `next/font/local`

Examples:

  * `style: 'italic'`: A string - it can be `normal` or `italic` for `next/font/google`
  * `style: 'oblique'`: A string - it can take any value for `next/font/local` but is expected to come from standard font styles
  * `style: ['italic','normal']`: An array of 2 values for `next/font/google` \- the values are from `normal` and `italic`

The font `subsets` defined by an array of string values with the names of each
subset you would like to be preloaded. Fonts specified via `subsets` will have
a link preload tag injected into the head when the `preload` option is true,
which is the default.

Used in `next/font/google`

Examples:

  * `subsets: ['latin']`: An array with the subset `latin`

You can find a list of all subsets on the Google Fonts page for your font.

Some variable fonts have extra `axes` that can be included. By default, only
the font weight is included to keep the file size down. The possible values of
`axes` depend on the specific font.

Used in `next/font/google`

Examples:

  * `axes: ['slnt']`: An array with value `slnt` for the `Inter` variable font which has `slnt` as additional `axes` as shown here. You can find the possible `axes` values for your font by using the filter on the Google variable fonts page and looking for axes other than `wght`

The font `display` with possible string values of `'auto'`, `'block'`,
`'swap'`, `'fallback'` or `'optional'` with default value of `'swap'`.

Used in `next/font/google` and `next/font/local`

Examples:

  * `display: 'optional'`: A string assigned to the `optional` value

A boolean value that specifies whether the font should be preloaded or not.
The default is `true`.

Used in `next/font/google` and `next/font/local`

Examples:

The fallback font to use if the font cannot be loaded. An array of strings of
fallback fonts with no default.

Used in `next/font/google` and `next/font/local`

Examples:

  * `fallback: ['system-ui', 'arial']`: An array setting the fallback fonts to `system-ui` or `arial`

  * For `next/font/google`: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The default is `true`.
  * For `next/font/local`: A string or boolean `false` value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The possible values are `'Arial'`, `'Times New Roman'` or `false`. The default is `'Arial'`.

Used in `next/font/google` and `next/font/local`

Examples:

  * `adjustFontFallback: false`: for ``next/font/google`
  * `adjustFontFallback: 'Times New Roman'`: for `next/font/local`

A string value to define the CSS variable name to be used if the style is
applied with the CSS variable method.

Used in `next/font/google` and `next/font/local`

Examples:

  * `variable: '--my-font'`: The CSS variable `--my-font` is declared

An array of font face descriptor key-value pairs that define the generated
`@font-face` further.

Used in `next/font/local`

Examples:

  * `declarations: [{ prop: 'ascent-override', value: '90%' }]`

You can apply the font styles in three ways:

Returns a read-only CSS `className` for the loaded font to be passed to an
HTML element.

    
    
    <p className={inter.className}>Hello, Next.js!</p>

Returns a read-only CSS `style` object for the loaded font to be passed to an
HTML element, including `style.fontFamily` to access the font family name and
fallback fonts.

    
    
    <p style={inter.style}>Hello World</p>

If you would like to set your styles in an external style sheet and specify
additional options there, use the CSS variable method.

In addition to importing the font, also import the CSS file where the CSS
variable is defined and set the variable option of the font loader object as
follows:

    
    
    import { Inter } from 'next/font/google';
    import styles from '../styles/component.module.css';
     
    const inter = Inter({
      variable: '--font-inter',
    });

To use the font, set the `className` of the parent container of the text you
would like to style to the font loader's `variable` value and the `className`
of the text to the `styles` property from the external CSS file.

    
    
    <main className={inter.variable}>
      <p className={styles.text}>Hello World</p>
    </main>

Define the `text` selector class in the `component.module.css` CSS file as
follows:

    
    
    .text {
      font-family: var(--font-inter);
      font-weight: 200;
      font-style: italic;
    }

In the example above, the text `Hello World` is styled using the `Inter` font
and the generated font fallback with `font-weight: 200` and `font-style:
italic`.

Every time you call the `localFont` or Google font function, that font will be
hosted as one instance in your application. Therefore, if you need to use the
same font in multiple places, you should load it in one place and import the
related font object where you need it. This is done using a font definitions
file.

For example, create a `fonts.ts` file in a `styles` folder at the root of your
app directory.

Then, specify your font definitions as follows:

    
    
    import { Inter, Lora, Source_Sans_Pro } from 'next/font/google';
    import localFont from 'next/font/local';
     
    // define your variable fonts
    const inter = Inter();
    const lora = Lora();
    // define 2 weights of a non-variable font
    const sourceCodePro400 = Source_Sans_Pro({ weight: '400' });
    const sourceCodePro700 = Source_Sans_Pro({ weight: '700' });
    // define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder
    const greatVibes = localFont({ src: './GreatVibes-Regular.ttf' });
     
    export { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes };

You can now use these definitions in your code as follows:

    
    
    import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts';
     
    export default function Page() {
      return (
        <div>
          <p className={inter.className}>Hello world using Inter font</p>
          <p style={lora.style}>Hello world using Lora font</p>
          <p className={sourceCodePro700.className}>
            Hello world using Source_Sans_Pro font with weight 700
          </p>
          <p className={greatVibes.className}>My title in Great Vibes font</p>
        </div>
      );
    }

To make it easier to access the font definitions in your code, you can define
a path alias in your `tsconfig.json` or `jsconfig.json` files as follows:

    
    
    {
      "compilerOptions": {
        "paths": {
          "@/fonts": ["./styles/fonts"]
        }
      }
    }

You can now import any font definition as follows:

    
    
    import { greatVibes, sourceCodePro400 } from '@/fonts';

Version| Changes  
---|---  
`v13.2.0`| `@next/font` renamed to `next/font`. Installation no longer
required.  
`v13.0.0`| `@next/font` was added.





# <Image>

 **Examples**

This API reference will help you understand how to use props and configuration
options available for the Image Component. For features and usage, please see
the Image Component page.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <Image
          src="/profile.png"
          width={500}
          height={500}
          alt="Picture of the author"
        />
      );
    }

Here's a summary of the props available for the Image Component:

Prop| Example| Type| Required  
---|---|---|---  
`src`| `src="/profile.png"`| String| Yes  
`width`| `width={500}`| Integer (px)| Yes  
`height`| `height={500}`| Integer (px)| Yes  
`alt`| `alt="Picture of the author"`| String| Yes  
`loader`| `loader={imageLoader}`| Function| -  
`fill`| `fill={true}`| Boolean| -  
`sizes`| `sizes="(max-width: 768px) 100vw"`| String| -  
`quality`| `quality={80}`| Integer (1-100)| -  
`priority`| `priority={true}`| Boolean| -  
`placeholder`| `placeholder="blur"`| String| -  
`style`| `style={{objectFit: "contain"}}`| Object| -  
`onLoadingComplete`| `onLoadingComplete={img => done())}`| Function| -  
`onLoad`| `onLoad={event => done())}`| Function| -  
`onError`| `onError(event => fail()}`| Function| -  
`loading`| `loading="lazy"`| String| -  
`blurDataURL`| `blurDataURL="data:image/jpeg..."`| String| -  
  
The Image Component requires the following properties: `src`, `width`,
`height`, and `alt`.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <div>
          <Image
            src="/profile.png"
            width={500}
            height={500}
            alt="Picture of the author"
          />
        </div>
      );
    }

Must be one of the following:

  * A statically imported image file
  * A path string. This can be either an absolute external URL, or an internal path depending on the loader prop.

When using an external URL, you must add it to remotePatterns in
`next.config.js`.

The `width` property represents the _rendered_ width in pixels, so it will
affect how large the image appears.

Required, except for statically imported images or images with the `fill`
property.

The `height` property represents the _rendered_ height in pixels, so it will
affect how large the image appears.

Required, except for statically imported images or images with the `fill`
property.

The `alt` property is used to describe the image for screen readers and search
engines. It is also the fallback text if images have been disabled or an error
occurs while loading the image.

It should contain text that could replace the image without changing the
meaning of the page. It is not meant to supplement the image and should not
repeat information that is already provided in the captions above or below the
image.

If the image is purely decorative or not intended for the user, the `alt`
property should be an empty string (`alt=""`).

Learn more

The `<Image />` component accepts a number of additional properties beyond
those which are required. This section describes the most commonly-used
properties of the Image component. Find details about more rarely-used
properties in the Advanced Props section.

A custom function used to resolve image URLs.

A `loader` is a function returning a URL string for the image, given the
following parameters:

Here is an example of using a custom loader:

    
    
    import Image from 'next/image';
     
    const imageLoader = ({ src, width, quality }) => {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    };
     
    export default function Page() {
      return (
        <Image
          loader={imageLoader}
          src="me.png"
          alt="Picture of the author"
          width={500}
          height={500}
        />
      );
    }

Alternatively, you can use the loaderFile configuration in `next.config.js` to
configure every instance of `next/image` in your application, without passing
a prop.

    
    
    fill={true} // {true} | {false}

A boolean that causes the image to fill the parent element instead of setting
`width` and `height`.

The parent element _must_ assign `position: "relative"`, `position: "fixed"`,
or `position: "absolute"` style.

By default, the img element will automatically be assigned the `position:
"absolute"` style.

The default image fit behavior will stretch the image to fit the container.
You may prefer to set `object-fit: "contain"` for an image which is
letterboxed to fit the container and preserve aspect ratio.

Alternatively, `object-fit: "cover"` will cause the image to fill the entire
container and be cropped to preserve aspect ratio. For this to look correct,
the `overflow: "hidden"` style should be assigned to the parent element.

For more information, see also:

A string that provides information about how wide the image will be at
different breakpoints. The value of `sizes` will greatly affect performance
for images using `fill` or which are styled to have a responsive size.

The `sizes` property serves two important purposes related to image
performance:

  * First, the value of `sizes` is used by the browser to determine which size of the image to download, from `next/image`'s automatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. The `sizes` property allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify a `sizes` value in an image with the `fill` property, a default value of `100vw` (full screen width) is used.
  * Second, the `sizes` property configures how `next/image` automatically generates an image source set. If no `sizes` value is present, a small source set is generated, suitable for a fixed-size image. If `sizes` is defined, a large source set is generated, suitable for a responsive image. If the `sizes` property includes sizes such as `50vw`, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which are too small to ever be necessary.

For example, if you know your styling will cause an image to be full-width on
mobile devices, in a 2-column layout on tablets, and a 3-column layout on
desktop displays, you should include a sizes property such as the following:

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <div className="grid-element">
          <Image
            fill
            src="/example.png"
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        </div>
      );
    }

This example `sizes` could have a dramatic effect on performance metrics.
Without the `33vw` sizes, the image selected from the server would be 3 times
as wide as it needs to be. Because file size is proportional to the square of
the width, without `sizes` the user would download an image that's 9 times
larger than necessary.

Learn more about `srcset` and `sizes`:

    
    
    quality={75} // {number 1-100}

The quality of the optimized image, an integer between `1` and `100`, where
`100` is the best quality and therefore largest file size. Defaults to `75`.

    
    
    priority={false} // {false} | {true}

When true, the image will be considered high priority and preload. Lazy
loading is automatically disabled for images using `priority`.

You should use the `priority` property on any image detected as the Largest
Contentful Paint (LCP) element. It may be appropriate to have multiple
priority images, as different images may be the LCP element for different
viewport sizes.

Should only be used when the image is visible above the fold. Defaults to
`false`.

    
    
    placeholder = 'empty'; // {empty} | {blur}

A placeholder to use while the image is loading. Possible values are `blur` or
`empty`. Defaults to `empty`.

When `blur`, the `blurDataURL` property will be used as the placeholder. If
`src` is an object from a static import and the imported image is `.jpg`,
`.png`, `.webp`, or `.avif`, then `blurDataURL` will be automatically
populated.

For dynamic images, you must provide the `blurDataURL` property. Solutions
such as Plaiceholder can help with `base64` generation.

When `empty`, there will be no placeholder while the image is loading, only
empty space.

Try it out:

In some cases, you may need more advanced usage. The `<Image />` component
optionally accepts the following advanced properties.

Allows passing CSS styles to the underlying image element.

    
    
    const imageStyle = {
      borderRadius: '50%',
      border: '1px solid #fff',
    };
     
    export default function ProfileImage() {
      return <Image src="..." style={imageStyle} />;
    }

Remember that the required width and height props can interact with your
styling. If you use styling to modify an image's width, you should also style
its height to `auto` to preserve its intrinsic aspect ratio, or your image
will be distorted.

    
    
    <Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />

A callback function that is invoked once the image is completely loaded and
the placeholder has been removed.

The callback function will be called with one argument, a reference to the
underlying `<img>` element.

    
    
    <Image onLoad={(e) => console.log(e.target.naturalWidth)} />

A callback function that is invoked when the image is loaded.

Note that the load event might occur before the placeholder is removed and the
image is fully decoded.

Instead, use `onLoadingComplete`.

    
    
    <Image onError={(e) => console.error(e.target.id)} />

A callback function that is invoked if the image fails to load.

> **Recommendation** : This property is only meant for advanced use cases.
> Switching an image to load with `eager` will normally **hurt performance**.
> We recommend using the `priority` property instead, which will eagerly
> preload the image.
    
    
    loading = 'lazy'; // {lazy} | {eager}

The loading behavior of the image. Defaults to `lazy`.

When `lazy`, defer loading the image until it reaches a calculated distance
from the viewport.

When `eager`, load the image immediately.

Learn more about the `loading` attribute.

A Data URL to be used as a placeholder image before the `src` image
successfully loads. Only takes effect when combined with `placeholder="blur"`.

Must be a base64-encoded image. It will be enlarged and blurred, so a very
small image (10px or less) is recommended. Including larger images as
placeholders may harm your application performance.

Try it out:

You can also generate a solid color Data URL to match the image.

    
    
    unoptimized = {false} // {false} | {true}

When true, the source image will be served as-is instead of changing quality,
size, or format. Defaults to `false`.

    
    
    import Image from 'next/image';
     
    const UnoptimizedImage = (props) => {
      return <Image {...props} unoptimized />;
    };

Since Next.js 12.3.0, this prop can be assigned to all images by updating
`next.config.js` with the following configuration:

    
    
    module.exports = {
      images: {
        unoptimized: true,
      },
    };

Other properties on the `<Image />` component will be passed to the underlying
`img` element with the exception of the following:

  * `srcSet`. Use Device Sizes instead.
  * `decoding`. It is always `"async"`.

In addition to props, you can configure the Image Component in
`next.config.js`. The following options are available:

To protect your application from malicious users, configuration is required in
order to use external images. This ensures that only external images from your
account can be served from the Next.js Image Optimization API. These external
images can be configured with the `remotePatterns` property in your
`next.config.js` file, as shown below:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 'example.com',
            port: '',
            pathname: '/account123/**',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of `next/image`
> must start with `https://example.com/account123/`. Any other protocol,
> hostname, port, or unmatched path will respond with 400 Bad Request.

Below is another example of the `remotePatterns` property in the
`next.config.js` file:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: '**.example.com',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of `next/image`
> must start with `https://img1.example.com` or
> `https://me.avatar.example.com` or any number of subdomains. Any other
> protocol or unmatched hostname will respond with 400 Bad Request.

Wildcard patterns can be used for both `pathname` and `hostname` and have the
following syntax:

  * `*` match a single path segment or subdomain
  * `**` match any number of path segments at the end or subdomains at the beginning

The `**` syntax does not work in the middle of the pattern.

> **Warning** : We recommend configuring strict `remotePatterns` instead of
> `domains` in order to protect your application from malicious users. Only
> use `domains` if you own all the content served from the domain.

Similar to `remotePatterns`, the `domains` configuration can be used to
provide a list of allowed hostnames for external images.

However, the `domains` configuration does not support wildcard pattern
matching and it cannot restrict protocol, port, or pathname.

Below is an example of the `domains` property in the `next.config.js` file:

    
    
    module.exports = {
      images: {
        domains: ['assets.acme.com'],
      },
    };

If you want to use a cloud provider to optimize images instead of using the
Next.js built-in Image Optimization API, you can configure the `loaderFile` in
your `next.config.js` like the following:

    
    
    module.exports = {
      images: {
        loader: 'custom',
        loaderFile: './my/image/loader.js',
      },
    };

This must point to a file relative to the root of your Next.js application.
The file must export a default function that returns a string, for example:

    
    
    export default function myImageLoader({ src, width, quality }) {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    }

Alternatively, you can use the `loader` prop to configure each instance of
`next/image`.

Examples:

The following configuration is for advanced use cases and is usually not
necessary. If you choose to configure the properties below, you will override
any changes to the Next.js defaults in future updates.

If you know the expected device widths of your users, you can specify a list
of device width breakpoints using the `deviceSizes` property in
`next.config.js`. These widths are used when the `next/image` component uses
`sizes` prop to ensure the correct image is served for user's device.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
      },
    };

You can specify a list of image widths using the `images.imageSizes` property
in your `next.config.js` file. These widths are concatenated with the array of
device sizes to form the full array of sizes used to generate image srcsets.

The reason there are two separate lists is that imageSizes is only used for
images which provide a `sizes` prop, which indicates that the image is less
than the full width of the screen. **Therefore, the sizes in imageSizes should
all be smaller than the smallest size in deviceSizes.**

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
      },
    };

The default Image Optimization API will automatically detect the browser's
supported image formats via the request's `Accept` header.

If the `Accept` head matches more than one of the configured formats, the
first match in the array is used. Therefore, the array order matters. If there
is no match (or the source image is animated), the Image Optimization API will
fallback to the original image's format.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        formats: ['image/webp'],
      },
    };

You can enable AVIF support with the following configuration.

    
    
    module.exports = {
      images: {
        formats: ['image/avif', 'image/webp'],
      },
    };

> **Note** : AVIF generally takes 20% longer to encode but it compresses 20%
> smaller compared to WebP. This means that the first time an image is
> requested, it will typically be slower and then subsequent requests that are
> cached will be faster.

> **Note** : If you self-host with a Proxy/CDN in front of Next.js, you must
> configure the Proxy to forward the `Accept` header.

The following describes the caching algorithm for the default loader. For all
other loaders, please refer to your cloud provider's documentation.

Images are optimized dynamically upon request and stored in the
`<distDir>/cache/images` directory. The optimized image file will be served
for subsequent requests until the expiration is reached. When a request is
made that matches a cached but expired file, the expired image is served stale
immediately. Then the image is optimized again in the background (also called
revalidation) and saved to the cache with the new expiration date.

The cache status of an image can be determined by reading the value of the
`x-nextjs-cache` response header. The possible values are the following:

  * `MISS` \- the path is not in the cache (occurs at most once, on the first visit)
  * `STALE` \- the path is in the cache but exceeded the revalidate time so it will be updated in the background
  * `HIT` \- the path is in the cache and has not exceeded the revalidate time

The expiration (or rather Max Age) is defined by either the `minimumCacheTTL`
configuration or the upstream image `Cache-Control` header, whichever is
larger. Specifically, the `max-age` value of the `Cache-Control` header is
used. If both `s-maxage` and `max-age` are found, then `s-maxage` is
preferred. The `max-age` is also passed-through to any downstream clients
including CDNs and browsers.

  * You can configure `minimumCacheTTL` to increase the cache duration when the upstream image does not include `Cache-Control` header or the value is very low.
  * You can configure `deviceSizes` and `imageSizes` to reduce the total number of possible generated images.
  * You can configure formats to disable multiple formats in favor of a single image format.

You can configure the Time to Live (TTL) in seconds for cached optimized
images. In many cases, it's better to use a Static Image Import which will
automatically hash the file contents and cache the image forever with a
`Cache-Control` header of `immutable`.

    
    
    module.exports = {
      images: {
        minimumCacheTTL: 60,
      },
    };

The expiration (or rather Max Age) of the optimized image is defined by either
the `minimumCacheTTL` or the upstream image `Cache-Control` header, whichever
is larger.

If you need to change the caching behavior per image, you can configure
`headers` to set the `Cache-Control` header on the upstream image (e.g.
`/some-asset.jpg`, not `/_next/image` itself).

There is no mechanism to invalidate the cache at this time, so its best to
keep `minimumCacheTTL` low. Otherwise you may need to manually change the
`src` prop or delete `<distDir>/cache/images`.

The default behavior allows you to import static files such as `import icon
from './icon.png` and then pass that to the `src` property.

In some cases, you may wish to disable this feature if it conflicts with other
plugins that expect the import to behave differently.

You can disable static image imports inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        disableStaticImages: true,
      },
    };

The default loader does not optimize SVG images for a few reasons. First, SVG
is a vector format meaning it can be resized losslessly. Second, SVG has many
of the same features as HTML/CSS, which can lead to vulnerabilities without
proper Content Security Policy (CSP) headers.

If you need to serve SVG images with the default Image Optimization API, you
can set `dangerouslyAllowSVG` inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        dangerouslyAllowSVG: true,
        contentDispositionType: 'attachment',
        contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
      },
    };

In addition, it is strongly recommended to also set `contentDispositionType`
to force the browser to download the image, as well as `contentSecurityPolicy`
to prevent scripts embedded in the image from executing.

The default loader will automatically bypass Image Optimization for animated
images and serve the image as-is.

Auto-detection for animated files is best-effort and supports GIF, APNG, and
WebP. If you want to explicitly bypass Image Optimization for a given animated
image, use the unoptimized prop.

This `next/image` component uses browser native lazy loading, which may
fallback to eager loading for older browsers before Safari 15.4. When using
the blur-up placeholder, older browsers before Safari 12 will fallback to
empty placeholder. When using styles with `width`/`height` of `auto`, it is
possible to cause Layout Shift on older browsers before Safari 15 that don't
preserve the aspect ratio. For more details, see this MDN video.

  * Safari 15 and 16 display a gray border while loading. Safari 16.4 fixed this issue. Possible solutions: 
    * Use CSS `@supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading="lazy"] { clip-path: inset(0.6px) } }`
    * Use `priority` if the image is above the fold
  * Firefox 67+ displays a white background while loading. Possible solutions: 

Version| Changes  
---|---  
`v13.2.0`| `contentDispositionType` configuration added.  
`v13.0.6`| `ref` prop added.  
`v13.0.0`| The `next/image` import was renamed to `next/legacy/image`. The
`next/future/image` import was renamed to `next/image`. A codemod is available
to safely and automatically rename your imports. `<span>` wrapper removed.
`layout`, `objectFit`, `objectPosition`, `lazyBoundary`, `lazyRoot` props
removed. `alt` is required. `onLoadingComplete` receives reference to `img`
element. Built-in loader config removed.  
`v12.3.0`| `remotePatterns` and `unoptimized` configuration is stable.  
`v12.2.0`| Experimental `remotePatterns` and experimental `unoptimized`
configuration added. `layout="raw"` removed.  
`v12.1.1`| `style` prop added. Experimental support for `layout="raw"` added.  
`v12.1.0`| `dangerouslyAllowSVG` and `contentSecurityPolicy` configuration
added.  
`v12.0.9`| `lazyRoot` prop added.  
`v12.0.0`| `formats` configuration added.  
AVIF support added.  
Wrapper `<div>` changed to `<span>`.  
`v11.1.0`| `onLoadingComplete` and `lazyBoundary` props added.  
`v11.0.0`| `src` prop support for static import.  
`placeholder` prop added.  
`blurDataURL` prop added.  
`v10.0.5`| `loader` prop added.  
`v10.0.1`| `layout` prop added.  
`v10.0.0`| `next/image` introduced.





# <Link>

 **Examples**

`<Link>` is a React component that extends the HTML `<a>` element to provide
prefetching and client-side navigation between routes. It is the primary way
to navigate between routes in Next.js.

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return <Link href="/dashboard">Dashboard</Link>;
    }

Here's a summary of the props available for the Link Component:

Prop| Example| Type| Required  
---|---|---|---  
`href`| `href="/dashboard"`| String or Object| Yes  
`replace`| `replace={false}`| Boolean| -  
`prefetch`| `prefetch={false}`| Boolean| -  
  
> **Good to know** : `<a>` tag attributes such as `className` or
> `target="_blank"` can be added to `<Link>` as props and will be passed to
> the underlying `<a>` element.

The path or URL to navigate to.

    
    
    <Link href="/dashboard">Dashboard</Link>

`href` can also accept an object, for example:

    
    
    // Navigate to /about?name=test
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>

**Defaults to`false`.** When `true`, `next/link` will replace the current
history state instead of adding a new URL into the browser’s history stack.

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return (
        <Link href="/dashboard" replace>
          Dashboard
        </Link>
      );
    }

**Defaults to`true`.** When `true`, `next/link` will prefetch the page
(denoted by the `href`) in the background. This is useful for improving the
performance of client-side navigations. Any `<Link />` in the viewport
(initially or through scroll) will be preloaded.

Prefetch can be disabled by passing `prefetch={false}`. Prefetching is only
enabled in production.

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return (
        <Link href="/dashboard" prefetch={false}>
          Dashboard
        </Link>
      );
    }

For dynamic routes, it can be handy to use template literals to create the
link's path.

For example, you can generate a list of links to the dynamic route
`app/blog/[slug]/page.js`:

    
    
    import Link from 'next/link';
     
    function Page({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/blog/${post.slug}`}>{post.title}</Link>
            </li>
          ))}
        </ul>
      );
    }

It's common to use Middleware for authentication or other purposes that
involve rewriting the user to a different page. In order for the `<Link />`
component to properly prefetch links with rewrites via Middleware, you need to
tell Next.js both the URL to display and the URL to prefetch. This is required
to avoid un-necessary fetches to middleware to know the correct route to
prefetch.

For example, if you have want to serve a `/dashboard` route that has
authenticated and visitor views, you may add something similar to the
following in your Middleware to redirect the user to the correct page:

    
    
    export function middleware(req) {
      const nextUrl = req.nextUrl;
      if (nextUrl.pathname === '/dashboard') {
        if (req.cookies.authToken) {
          return NextResponse.rewrite(new URL('/auth/dashboard', req.url));
        } else {
          return NextResponse.rewrite(new URL('/public/dashboard', req.url));
        }
      }
    }

In this case, you would want to use the following code in your `<Link />`
component:

    
    
    import Link from 'next/link';
    import useIsAuthed from './hooks/useIsAuthed';
     
    export default function Page() {
      const isAuthed = useIsAuthed();
      const path = isAuthed ? '/auth/dashboard' : '/dashboard';
      return (
        <Link as="/dashboard" href={path}>
          Dashboard
        </Link>
      );
    }





# <Script>

This API reference will help you understand how to use props available for the
Script Component. For features and usage, please see the Optimizing Scripts
page.

    
    
    import Script from 'next/script';
     
    export default function Dashboard() {
      return (
        <>
          <Script src="https://example.com/script.js" />
        </>
      );
    }

Here's a summary of the props available for the Script Component:

Prop| Example| Type| Required  
---|---|---|---  
`src`| `src="http://example.com/script"`| String| Required unless inline
script is used  
`strategy`| `strategy="lazyOnload"`| String| -  
`onLoad`| `onLoad={onLoadFunc}`| Function| -  
`onReady`| `onReady={onReadyFunc}`| Function| -  
`onError`| `onError={onErrorFunc}`| Function| -  
  
The `<Script />` component requires the following properties.

A path string specifying the URL of an external script. This can be either an
absolute external URL or an internal path. The `src` property is required
unless an inline script is used.

The `<Script />` component accepts a number of additional properties beyond
those which are required.

The loading strategy of the script. There are four different strategies that
can be used:

  * `beforeInteractive`: Load before any Next.js code and before any page hydration occurs.
  * `afterInteractive`: ( **default** ) Load early but after some hydration on the page occurs.
  * `lazyOnload`: Load during browser idle time.
  * `worker`: (experimental) Load in a web worker.

Scripts that load with the `beforeInteractive` strategy are injected into the
initial HTML from the server, downloaded before any Next.js module, and
executed in the order they are placed before _any_ hydration occurs on the
page.

Scripts denoted with this strategy are preloaded and fetched before any first-
party code, but their execution does not block page hydration from occurring.

`beforeInteractive` scripts must be placed inside the root layout
(`app/layout.tsx)` and are designed to load scripts that are needed by the
entire site (i.e. the script will load when any page in the application has
been loaded server-side).

**This strategy should only be used for critical scripts that need to be
fetched before any part of the page becomes interactive.**

    
    
    import Script from 'next/script';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
          <Script
            src="https://example.com/script.js"
            strategy="beforeInteractive"
          />
        </html>
      );
    }

> **Good to know** : Scripts with `beforeInteractive` will always be injected
> inside the `head` of the HTML document regardless of where it's placed in
> the component.

Some examples of scripts that should be loaded as soon as possible with
`beforeInteractive` include:

  * Bot detectors
  * Cookie consent managers

Scripts that use the `afterInteractive` strategy are injected into the HTML
client-side and will load after some (or all) hydration occurs on the page.
**This is the default strategy** of the Script component and should be used
for any script that needs to load as soon as possible but not before any
first-party Next.js code.

`afterInteractive` scripts can be placed inside of any page or layout and will
only load and execute when that page (or group of pages) is opened in the
browser.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="afterInteractive" />
        </>
      );
    }

Some examples of scripts that are good candidates for `afterInteractive`
include:

Scripts that use the `lazyOnload` strategy are injected into the HTML client-
side during browser idle time and will load after all resources on the page
have been fetched. This strategy should be used for any background or low
priority scripts that do not need to load early.

`lazyOnload` scripts can be placed inside of any page or layout and will only
load and execute when that page (or group of pages) is opened in the browser.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="lazyOnload" />
        </>
      );
    }

Examples of scripts that do not need to load immediately and can be fetched
with `lazyOnload` include:

  * Chat support plugins
  * Social media widgets

> **Warning:** The `worker` strategy is not yet stable and does not yet work
> with the `app` directory. Use with caution.

Scripts that use the `worker` strategy are off-loaded to a web worker in order
to free up the main thread and ensure that only critical, first-party
resources are processed on it. While this strategy can be used for any script,
it is an advanced use case that is not guaranteed to support all third-party
scripts.

To use `worker` as a stratgy, the `nextScriptWorkers` flag must be enabled in
`next.config.js`:

    
    
    module.exports = {
      experimental: {
        nextScriptWorkers: true,
      },
    };

`worker` scripts can **only currently be used in the`pages/` directory**:

    
    
    import Script from 'next/script';
     
    export default function Home() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="worker" />
        </>
      );
    }

> **Warning:** `onLoad` does not yet work with Server Components and can only
> be used in Client Components. Further, `onLoad` can't be used with
> `beforeInteractive` – consider using `onReady` instead.

Some third-party scripts require users to run JavaScript code once after the
script has finished loading in order to instantiate content or call a
function. If you are loading a script with either afterInteractive or
lazyOnload as a loading strategy, you can execute code after it has loaded
using the onLoad property.

Here's an example of executing a lodash method only after the library has been
loaded.

    
    
    'use client';
     
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"
            onLoad={() => {
              console.log(_.sample([1, 2, 3, 4]));
            }}
          />
        </>
      );
    }

> **Warning:** `onReady` does not yet work with Server Components and can only
> be used in Client Components.

Some third-party scripts require users to run JavaScript code after the script
has finished loading and every time the component is mounted (after a route
navigation for example). You can execute code after the script's load event
when it first loads and then after every subsequent component re-mount using
the onReady property.

Here's an example of how to re-instantiate a Google Maps JS embed every time
the component is mounted:

    
    
    'use client';
     
    import { useRef } from 'react';
    import Script from 'next/script';
     
    export default function Page() {
      const mapRef = useRef();
     
      return (
        <>
          <div ref={mapRef}></div>
          <Script
            id="google-maps"
            src="https://maps.googleapis.com/maps/api/js"
            onReady={() => {
              new google.maps.Map(mapRef.current, {
                center: { lat: -34.397, lng: 150.644 },
                zoom: 8,
              });
            }}
          />
        </>
      );
    }

> **Warning:** `onError` does not yet work with Server Components and can only
> be used in Client Components. `onError` cannot be used with the
> `beforeInteractive` loading strategy.

Sometimes it is helpful to catch when a script fails to load. These errors can
be handled with the onError property:

    
    
    'use client';
     
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            onError={(e: Error) => {
              console.error('Script failed to load', e);
            }}
          />
        </>
      );
    }

Version| Changes  
---|---  
`v13.0.0`| `beforeInteractive` and `afterInteractive` is modified to support
`app`  
`v12.2.4`| `onReady` prop added.  
`v12.2.2`| Allow `next/script` with `beforeInteractive` to be placed in
`_document`.  
`v11.0.0`| `next/script` introduced.





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# layout.js

A **layout** is UI that is shared between routes.

    
    
    export default function DashboardLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return <section>{children}</section>;
    }

A **root layout** is the top-most layout in the root `app` directory. It is
used to define the `<html>` and `<body>` tags and other globally shared UI.

    
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Layout components should accept and use a `children` prop. During rendering,
`children` will be populated with the route segments the layout is wrapping.
These will primarily be the component of a child Layout (if it exists) or
Page, but could also be other special files like Loading or Error when
applicable.

The dynamic route parameters object from the root segment down to that layout.

Example| URL| `params`  
---|---|---  
`app/dashboard/[team]/layout.js`| `/dashboard/1`| `{ team: '1' }`  
`app/shop/[tag]/[item]/layout.js`| `/shop/1/2`| `{ tag: '1', item: '2' }`  
`app/blog/[...slug]/layout.js`| `/blog/1/2`| `{ slug: ['1', '2'] }`  
  
For example:

    
    
    export default function ShopLayout({
      children,
      params,
    }: {
      children: React.ReactNode;
      params: {
        tag: string;
        item: string;
      };
    }) {
      // URL -> /shop/shoes/nike-air-max-97
      // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }
      return <section>{children}</section>;
    }

Unlike Pages, Layout components **do not** receive the `searchParams` prop.
This is because a shared layout is not re-rendered during navigation which
could lead to stale `searchParams` between navigations.

When using client-side navigation, Next.js automatically only renders the part
of the page below the common layout between two routes.

For example, in the following directory structure, `dashboard/layout.tsx` is
the common layout for both `/dashboard/settings` and `/dashboard/analytics`:

    
    
    app
    └── dashboard
        ├── layout.tsx
        ├── settings
        │   └── page.tsx
        └── analytics
            └── page.js

When navigating from `/dashboard/settings` to `/dashboard/analytics`,
`page.tsx` in `/dashboard/analytics` will be rendered on the server because it
is UI that changed, while `dashboard/layout.tsx` will **not** be re-rendered
because it is a common UI between the two routes.

This performance optimization allows navigation between pages that share a
layout to be quicker as only the data fetching and rendering for the page has
to run, instead of the entire route that could include shared layouts that
fetch their own data.

Because `dashboard/layout.tsx` doesn't re-render, the `searchParams` prop in
the layout Server Component might become **stale** after navigation.

  * Instead, use the Page `searchParams` prop or the `useSearchParams` hook in a Client Component, which is re-rendered on the client with the latest `searchParams`.

  * The `app` directory **must** include a root `app/layout.js`.
  * The root layout **must** define `<html>` and `<body>` tags. 
    * You should **not** manually add `<head>` tags such as `<title>` and `<meta>` to root layouts. Instead, you should use the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating `<head>` elements.
  * You can use route groups to create multiple root layouts. 
    * Navigating **across multiple root layouts** will cause a **full page load** (as opposed to a client-side navigation). For example, navigating from `/cart` that uses `app/(shop)/layout.js` to `/blog` that uses `app/(marketing)/layout.js` will cause a full page load. This **only** applies to multiple root layouts.





Using App Router

Features available in /app



  
  
> **Note:** In addition to catching expected `notFound()` errors, the root
> `app/not-found.js` file also handles any unmatched URLs for your whole
> application. This means users that visit a URL that is not handled by your
> app will be shown the UI exported by the `app/not-found.js` file.





Using App Router

Features available in /app





# route.js

Route Handlers allow you to create custom request handlers for a given route
using the Web Request and Response APIs.

A **route** file allows you to create custom request handlers for a given
route. The following HTTP methods are supported: `GET`, `POST`, `PUT`,
`PATCH`, `DELETE`, `HEAD`, and `OPTIONS`.

    
    
    export async function GET(request: Request) {}
     
    export async function HEAD(request: Request) {}
     
    export async function POST(request: Request) {}
     
    export async function PUT(request: Request) {}
     
    export async function DELETE(request: Request) {}
     
    export async function PATCH(request: Request) {}
     
    // If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and  set the appropriate Response `Allow` header depending on the other methods defined in the route handler.
    export async function OPTIONS(request: Request) {}

> **Good to know:** Route Handlers are only available inside the `app`
> directory. You **do not** need to use API Routes (`pages`) and Route
> Handlers (`app`) together, as Route Handlers should be able to handle all
> use cases.

The `request` object is a NextRequest object, which is an extension of the Web
Request API. `NextRequest` gives you further control over the incoming
request, including easily accessing `cookies` and an extended, parsed, URL
object `nextUrl`.

    
    
    export async function GET(request, context: { params }) {
      const team = params.team; // '1'
    }

Currently, the only value of `context` is `params`, which is an object
containing the dynamic route parameters for the current route.

Example| URL| `params`  
---|---|---  
`app/dashboard/[team]/route.js`| `/dashboard/1`| `{ team: '1' }`  
`app/shop/[tag]/[item]/route.js`| `/shop/1/2`| `{ tag: '1', item: '2' }`  
`app/blog/[...slug]/route.js`| `/blog/1/2`| `{ slug: ['1', '2'] }`  
  
Route Handlers can extend the Web Response API by returning a `NextResponse`
object. This allows you to easily set cookies, headers, redirect, and rewrite.
View the API reference.





# Route Segment Config

The Route Segment options allows you configure the behavior of a Page, Layout,
or Route Handler by directly exporting the following variables:

Option| Type| Default  
---|---|---  
`dynamic`| `'auto' | 'force-dynamic' | 'error' | 'force-static'`| `'auto'`  
`dynamicParams`| `boolean`| `true`  
`revalidate`| `false | 'force-cache' | 0 | number`| `false`  
`fetchCache`| `'auto' | 'default-cache' | 'only-cache' | 'force-cache' |
'force-no-store' | 'default-no-store' | 'only-no-store'`| `'auto'`  
`runtime`| `'nodejs' | 'edge'`| `'nodejs'`  
`preferredRegion`| `'auto' | 'global' | 'home' | string | string[]`| `'auto'`  
      
    
    export const dynamic = 'auto';
    export const dynamicParams = true;
    export const revalidate = false;
    export const fetchCache = 'auto';
    export const runtime = 'nodejs';
    export const preferredRegion = 'all';
     
    export default function MyComponent() {}

> **Good to know:**
>
>   * The values of the config options currently need be statically
> analyzable. For example `revalidate = 600` is valid, but `revalidate = 60 *
> 10` is not.
>

Change the dynamic behavior of a layout or page to fully static or fully
dynamic.

    
    
    export const dynamic = 'auto';
    // 'auto' | 'force-dynamic' | 'error' | 'force-static'

> **Migration Note:** The new model in the `app` directory favors granular
> caching control at the `fetch` request level over the binary all-or-nothing
> model of `getServerSideProps` and `getStaticProps` at the page-level in the
> `pages` directory. The `dynamic` option is a way to opt back in to the
> previous model as a convenience and provides a simpler migration path.

  * **`'auto'`** (default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior.

  * **`'force-dynamic'`** : Force dynamic rendering and dynamic data fetching of a layout or page by disabling all caching of `fetch` requests and always revalidating. This option is equivalent to:

    * `getServerSideProps()` in the `pages` directory.
    * Setting the option of every `fetch()` request in a layout or page to `{ cache: 'no-store', next: { revalidate: 0 } }`.
    * Setting the segment config to `export const fetchCache = 'force-no-store'`
  * **`'error'`** : Force static rendering and static data fetching of a layout or page by causing an error if any components use dynamic functions or dynamic fetches. This option is equivalent to:

    * `getStaticProps()` in the `pages` directory.
    * Setting the option of every `fetch()` request in a layout or page to `{ cache: 'force-cache' }`.
    * Setting the segment config to `fetchCache = 'only-cache', dynamicParams = false`.
    * Note: `dynamic = 'error'` changes the default of `dynamicParams` from `true` to `false`. You can opt back into dynamically rendering pages for dynamic params not generated by `generateStaticParams` by manually setting `dynamicParams = true`.
  * **`'force-static'`** : Force static rendering and static data fetching of a layout or page by forcing `cookies()`, `headers()` and `useSearchParams()` to return empty values.

> **Good to know:**
>
>   * Instructions on how to migrate from `getServerSideProps` and
> `getStaticProps` to `dynamic: 'force-dynamic'` and `dynamic: 'error'` can be
> found in the upgrade guide.
>

Control what happens when a dynamic segment is visited that was not generated
with generateStaticParams.

    
    
    export const dynamicParams = true; // true | false,

  * **`true`** (default): Dynamic segments not included in `generateStaticParams` are generated on demand.
  * **`false`** : Dynamic segments not included in `generateStaticParams` will return a 404.

> **Good to know:**
>
>   * This option replaces the `fallback: true | false | blocking` option of
> `getStaticPaths` in the `pages` directory.
>   * When `dynamicParams = true`, the segment uses Streaming Server
> Rendering.
>   * If the `dynamic = 'error'` and `dynamic = 'force-static'` are used,
> it'll change the default of `dynamicParams` to `false`.
>

Set the default revalidation time for a layout or page. This option does not
override the `revalidate` value set by individual `fetch` requests.

    
    
    export const revalidate = false;
    // false | 'force-cache' | 0 | number

  * **`false`** : (default) The default heuristic to cache any `fetch` requests that set their `cache` option to `'force-cache'` or are discovered before a dynamic function is used. Semantically equivalent to `revalidate: Infinity` which effectively means the resource should be cached indefinitely. It is still possible for individual `fetch` requests to use `cache: 'no-store'` or `revalidate: 0` to avoid being cached and make the route dynamically rendered. Or set `revalidate` to a positive number lower than the route default to increase the revalidation frequency of a route.
  * **`0`** : Ensure a layout or page is always dynamically rendered even if no dynamic functions or dynamic data fetches are discovered. This option changes the default of `fetch` requests that do not set a `cache` option to `'no-store'` but leaves `fetch` requests that opt into `'force-cache'` or use a positive `revalidate` as is.
  * **`number`** : (in seconds) Set the default revalidation frequency of a layout or page to `n` seconds.

  * The lowest `revalidate` across each layout and page of a single route will determine the revalidation frequency of the _entire_ route. This ensures that child pages are revalidated as frequently as their parent layouts.
  * Individual `fetch` requests can set a lower `revalidate` than the route's default `revalidate` to increase the revalidation frequency of the entire route. This allows you to dynamically opt-in to more frequent revalidation for certain routes based on some criteria.

This is an advanced option that should only be used if you specifically need
to override the default behavior.

By default, Next.js **will cache** any `fetch()` requests that are reachable
**before** any dynamic functions are used and **will not cache** `fetch`
requests that are discovered **after** dynamic functions are used.

`fetchCache` allows you to override the default `cache` option of all `fetch`
requests in a layout or page.

    
    
    export const fetchCache = 'auto';
    // 'auto' | 'default-cache' | 'only-cache'
    // 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'

  * **`'auto'`** (default)- The default option to cache `fetch` requests before dynamic functions with the `cache` option they provide and not cache `fetch` requests after dynamic functions.
  * **`'default-cache'`** : Allow any `cache` option to be passed to `fetch` but if no option is provided then set the `cache` option to `'force-cache'`. This means that even `fetch` requests after dynamic functions are considered static.
  * **`'only-cache'`** : Ensure all `fetch` requests opt into caching by changing the default to `cache: 'force-cache'` if no option is provided and causing an error if any `fetch` requests use `cache: 'no-store'`.
  * **`'force-cache'`** : Ensure all `fetch` requests opt into caching by setting the `cache` option of all `fetch` requests to `'force-cache'`.
  * **`'default-no-store'`** : Allow any `cache` option to be passed to `fetch` but if no option is provided then set the `cache` option to `'no-store'`. This means that even `fetch` requests before dynamic functions are considered dynamic.
  * **`'only-no-store'`** : Ensure all `fetch` requests opt out of caching by changing the default to `cache: 'no-store'` if no option is provided and causing an error if any `fetch` requests use `cache: 'force-cache'`
  * **`'force-no-store'`** : Ensure all `fetch` requests opt out of caching by setting the `cache` option of all `fetch` requests to `'no-store'`. This forces all `fetch` requests to be re-fetched every request even if they provide a `'force-cache'` option.

  * Any options set across each layout and page of a single route need to be compatible with each other. 
    * If both the `'only-cache'` and `'force-cache'` are provided, then `'force-cache'` wins. If both `'only-no-store'` and `'force-no-store'` are provided, then `'force-no-store'` wins. The force option changes the behavior across the route so a single segment with `'force-*'` would prevent any errors caused by `'only-*'`.
    * The intention of the `'only-*'` and `force-*'` options is to guarantee the whole route is either fully static or fully dynamic. This means: 
      * A combination of `'only-cache'` and `'only-no-store'` in a single route is not allowed.
      * A combination of `'force-cache'` and `'force-no-store'` in a single route is not allowed.
    * A parent cannot provide `'default-no-store'` if a child provides `'auto'` or `'*-cache'` since that could make the same fetch have different behavior.
  * It is generally recommended to leave shared parent layouts as `'auto'` and customize the options where child segments diverge.

    
    
    export const runtime = 'nodejs';
    // 'edge' | 'nodejs'

Learn more about the Edge and Node.js runtimes.

    
    
    export const preferredRegion = 'auto';
    // 'all' | 'iad1' | ['iad1', 'sfo1']

Support for `preferredRegion`, and regions supported, is dependent on your
deployment platform.

> **Good to know:**
>
>   * If a `preferredRegion` is not specified, it will inherit the option of
> the nearest parent layout.
>   * The root layout defaults to `all` regions.
>

The `generateStaticParams` function can be used in combination with dynamic
route segments to define the list of route segment parameters that will be
statically generated at build time instead of on-demand at request time.

See the API reference for more details.





Using App Router

Features available in /app





Using App Router

Features available in /app





# favicon, apple-icon, and icon

The `favicon`, `apple-icon` or, `icon` file conventions allow you to set icons
for your application.

They are useful for adding app icons that appear in places like web browser
tabs, phone home screens, and search engine results.

There are two ways to set app icons:

Use an image file to set an app icon by placing a `favicon`, `icon`, or
`apple-icon` image file the root `/app` segment.

Next.js will evaluate the file and automatically add the appropriate tags to
your app's `<head>` element.

File convention| Supported file types  
---|---  
`favicon`| `.ico`  
`icon`| `.ico`, `.jpg`, `.jpeg`, `.png`, `.svg`  
`apple-icon`| `.jpg`, `.jpeg`, `.png`,  
  
Add a `favicon.ico` image file to the root `/app` route segment.

    
    
    <link rel="icon" href="/favicon.ico" sizes="any" />

Add an `icon.(ico|jpg|jpeg|png|svg)` image file to the root `/app` route
segment.

    
    
    <link
      rel="icon"
      href="/icon?<generated>"
      type="image/<generated>"
      sizes="<generated>"
    />

Add an `apple-icon.(jpg|jpeg|png)` image file to the root `/app` route
segment.

    
    
    <link
      rel="apple-touch-icon"
      href="/apple-icon?<generated>"
      type="image/<generated>"
      sizes="<generated>"
    />

> **Good to know**
>
>   * You can set multiple icons by adding a number suffix to the file name.
> For example, `icon1.png`, `icon2.png`, etc. Numbered files will sort
> lexically.
>   * App icons can only be set in the root `/app` segment.
>   * The appropriate `<link>` tags and attributes such as `rel`, `href`,
> `type`, and `sizes` are determined by the icon type and metadata of the
> evaluated file.
>     * For example, a 32 by 32px `.png` file will have `type="image/png"` and
> `sizes="32x32"` attributes.
>   * `sizes="any"` is added to `favicon.ico` output to avoid a browser bug
> where an `.ico` icon is favored over `.svg`.
>

In addition to using literal image files, you can programmatically
**generate** icons using code.

Generate an app icon by creating an `icon` or `apple-icon` route that default
exports a function.

File convention| Supported file types  
---|---  
`icon`| `.js`, `.ts`, `.tsx`  
`apple-icon`| `.js`, `.ts`, `.tsx`  
  
The easiest way to generate an icon is to use the `ImageResponse` API from
`next/server`.

    
    
    import { ImageResponse } from 'next/server';
     
    // Route segment config
    export const runtime = 'edge';
     
    // Image metadata
    export const size = {
      width: 32,
      height: 32,
    };
    export const contentType = 'image/png';
     
    // Image generation
    export default function Icon() {
      return new ImageResponse(
        (
          // ImageResponse JSX element
          <div
            style={{
              fontSize: 24,
              background: 'black',
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: 'white',
            }}
          >
            A
          </div>
        ),
        // ImageResponse options
        {
          // For convenience, we can re-use the exported icons size metadata
          // config to also set the ImageResponse's width and height.
          ...size,
        },
      );
    }
    
    
    <link rel="icon" href="/icon?<generated>" type="image/png" sizes="32x32" />

> **Good to know**

The default export function receives the following props:

An object containing the dynamic route parameters object from the root segment
down to the segment `icon` or `apple-icon` is colocated in.

    
    
    export default function Icon({ params }: { params: { slug: string } }) {
      // ...
    }

Route| URL| `params`  
---|---|---  
`app/shop/icon.js`| `/shop`| `undefined`  
`app/shop/[slug]/icon.js`| `/shop/1`| `{ slug: '1' }`  
`app/shop/[tag]/[item]/icon.js`| `/shop/1/2`| `{ tag: '1', item: '2' }`  
`app/shop/[...slug]/icon.js`| `/shop/1/2`| `{ slug: ['1', '2'] }`  
  
The default export function should return a `Blob` | `ArrayBuffer` |
`TypedArray` | `DataView` | `ReadableStream` | `Response`.

> **Note:** `ImageResponse` satisfies this return type.

You can optionally configure the icon's metadata by exporting `size` and
`contentType` variables from the `icon` or `apple-icon` route.

    
    
    export const size = { width: 32, height: 32 };
     
    export default function Icon() {}
    
    
    <link rel="icon" sizes="32x32" />
    
    
    export const contentType = 'image/png';
     
    export default function Icon() {}
    
    
    <link rel="icon" type="image/png" />

`icon` and `apple-icon` are specialized Route Handlers that can use the same
route segment configuration options as Pages and Layouts.

Option| Type| Default  
---|---|---  
`dynamic`| `'auto' | 'force-dynamic' | 'error' | 'force-static'`| `'auto'`  
`revalidate`| `false | 'force-cache' | 0 | number`| `false`  
`runtime`| `'nodejs' | 'edge'`| `'nodejs'`  
`preferredRegion`| `'auto' | 'global' | 'home' | string | string[]`| `'auto'`  
      
    
    export const runtime = 'edge';
     
    export default function Icon() {}





# opengraph-image and twitter-image

The `opengraph-image` and `twitter-image` file conventions allow you to set
Open Graph and Twitter images for a route segment.

They are useful for setting the images that appear on social networks and
messaging apps when a user shares a link to your site.

There are two ways to set Open Graph and Twitter images:

Use an image file to set a route segment's shared image by placing an
`opengraph-image` or `twitter-image` image file in the segment.

Next.js will evaluate the file and automatically add the appropriate tags to
your app's `<head>` element.

Add an `opengraph-image.(jpg|jpeg|png|gif)` image file to any route segment.

    
    
    <meta property="og:image" content="<generated>" />
    <meta property="og:image:type" content="<generated>" />
    <meta property="og:image:width" content="<generated>" />
    <meta property="og:image:height" content="<generated>" />

Add a `twitter-image.(jpg|jpeg|png|gif)` image file to any route segment.

    
    
    <meta name="twitter:image" content="<generated>" />
    <meta name="twitter:image:type" content="<generated>" />
    <meta name="twitter:image:width" content="<generated>" />
    <meta name="twitter:image:height" content="<generated>" />

Add an accompanying `opengraph-image.alt.txt` file in the same route segment
as the `opengraph-image.(jpg|jpeg|png|gif)` image it's alt text.

    
    
    <meta property="og:image:alt" content="About Acme" />

Add an accompanying `twitter-image.alt.txt` file in the same route segment as
the `twitter-image.(jpg|jpeg|png|gif)` image it's alt text.

    
    
    <meta property="og:image:alt" content="About Acme" />

In addition to using literal image files, you can programmatically
**generate** images using code.

Generate a route segment's shared image by creating an `opengraph-image` or
`twitter-image` route that default exports a function.

File convention| Supported file types  
---|---  
`opengraph-image`| `.js`, `.ts`, `.tsx`  
`twitter-image`| `.js`, `.ts`, `.tsx`  
  
> **Good to know**

The easiest way to generate an image is to use the ImageResponse API from
`next/server`.

    
    
    import { ImageResponse } from 'next/server';
     
    // Route segment config
    export const runtime = 'edge';
     
    // Image metadata
    export const alt = 'About Acme';
    export const size = {
      width: 1200,
      height: 630,
    };
     
    export const contentType = 'image/png';
     
    // Font
    const interSemiBold = fetch(
      new URL('./Inter-SemiBold.ttf', import.meta.url),
    ).then((res) => res.arrayBuffer());
     
    // Image generation
    export default function Image() {
      return new ImageResponse(
        (
          // ImageResponse JSX element
          <div
            style={{
              fontSize: 128,
              background: 'white',
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            About Acme
          </div>
        ),
        // ImageResponse options
        {
          // For convenience, we can re-use the exported opengraph-image
          // size config to also set the ImageResponse's width and height.
          ...size,
          fonts: [
            {
              name: 'Inter',
              data: await interSemiBold,
              style: 'normal',
              weight: 400,
            },
          ],
        },
      );
    }
    
    
    <meta property="og:image" content="<generated>" />
    <meta property="og:image:alt" content="About Acme" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

The default export function receives the following props:

An object containing the dynamic route parameters object from the root segment
down to the segment `opengraph-image` or `twitter-image` is colocated in.

    
    
    export default function Image({ params }: { params: { slug: string } }) {
      // ...
    }

Route| URL| `params`  
---|---|---  
`app/shop/opengraph-image.js`| `/shop`| `undefined`  
`app/shop/[slug]/opengraph-image.js`| `/shop/1`| `{ slug: '1' }`  
`app/shop/[tag]/[item]/opengraph-image.js`| `/shop/1/2`| `{ tag: '1', item:
'2' }`  
`app/shop/[...slug]/opengraph-image.js`| `/shop/1/2`| `{ slug: ['1', '2'] }`  
  
The default export function should return a `Blob` | `ArrayBuffer` |
`TypedArray` | `DataView` | `ReadableStream` | `Response`.

> **Note:** `ImageResponse` satisfies this return type.

You can optionally configure the image's metadata by exporting `alt`, `size`,
and `contentType` variables from `opengraph-image` or `twitter-image` route.

    
    
    export const alt = 'My images alt text';
     
    export default function Image() {}
    
    
    <meta property="og:image:alt" content="My images alt text" />
    
    
    export const size = { width: 1200, height: 630 };
     
    export default function Image() {}
    
    
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    
    
    export const contentType = 'image/png';
     
    export default function Image() {}
    
    
    <meta property="og:image:type" content="image/png" />

`opengraph-image` and `twitter-image` are specialized Route Handlers that can
use the same route segment configuration options as Pages and Layouts.

Option| Type| Default  
---|---|---  
`dynamic`| `'auto' | 'force-dynamic' | 'error' | 'force-static'`| `'auto'`  
`revalidate`| `false | 'force-cache' | 0 | number`| `false`  
`runtime`| `'nodejs' | 'edge'`| `'nodejs'`  
`preferredRegion`| `'auto' | 'global' | 'home' | string | string[]`| `'auto'`  
      
    
    export const runtime = 'edge';
     
    export default function Image() {}

This example uses the `params` object and external data to generate the image.

> **Good to know:** By default, this generated image will be statically
> optimized. You can configure the individual `fetch` `options` or route
> segments options to change this behavior.
    
    
    import { ImageResponse } from 'next/server';
     
    export const runtime = 'edge';
     
    export const alt = 'About Acme';
    export const size = {
      width: 1200,
      height: 630,
    };
    export const contentType = 'image/png';
     
    export default async function Image({ params }: { params: { slug: string } }) {
      const post = await fetch(`https://.../posts/${params.slug}`).then((res) =>
        res.json(),
      );
     
      return new ImageResponse(
        (
          <div
            style={{
              fontSize: 48,
              background: 'white',
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            {post.title}
          </div>
        ),
        {
          ...size,
        },
      );
    }





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# cookies

The `cookies` function allows you to read the HTTP incoming request cookies
from a Server Component or write outgoing request cookies in a Server Action
or Route Handler.

> **Good to know:**
>
>   * `cookies()` is a **Dynamic Function** whose returned values cannot be
> known ahead of time. Using it in a layout or page will opt a route into
> **dynamic rendering** at request time.
>

A method that takes a cookie name and returns an object with name and value.
If a cookie with `name` isn't found, it returns `undefined`. If multiple
cookies match, it will only return the first match.

    
    
    import { cookies } from 'next/headers';
     
    export default function Page() {
      const cookieStore = cookies();
      const theme = cookieStore.get('theme');
      return '...';
    }

A method that is similar to `get`, but returns a list of all the cookies with
a matching `name`. If `name` is unspecified, it returns all the available
cookies.

    
    
    import { cookies } from 'next/headers';
     
    export default function Page() {
      const cookieStore = cookies();
      return cookieStore.getAll().map((cookie) => (
        <div key={cookie.name}>
          <p>Name: {cookie.name}</p>
          <p>Value: {cookie.value}</p>
        </div>
      ));
    }

A method that takes a cookie name and returns a `boolean` based on if the
cookie exists (`true`) or not (`false`).

    
    
    import { cookies } from 'next/headers';
     
    export default function Page() {
      const cookiesList = cookies();
      const hasCookie = cookiesList.has('theme');
      return '...';
    }

A method that takes a cookie name, value, and options and sets the outgoing
request cookie. This method is only available in a Server Action or Route
Handler.

    
    
    import { cookies } from 'next/headers';
     
    async function create(data) {
      'use server';
      cookies().set('name', 'lee');
      // or
      cookies().set('name', 'lee', { secure: true });
      // or
      cookies().set({
        name: 'name',
        value: 'lee',
        httpOnly: true,
        path: '/',
      });
    }





Using App Router

Features available in /app





# fetch

Next.js extends the native Web `fetch()` API to allow each request on the
server to set its own persistent caching semantics.

In the browser, the `cache` option indicates how a fetch request will interact
with the _browser's_ HTTP cache. With this extension, `cache` indicates how a
_server-side_ fetch request will interact with the framework's persistent HTTP
cache.

You can call `fetch` with `async` and `await` directly within Server
Components.

    
    
    export default async function Page() {
      // This request should be cached until manually invalidated.
      // Similar to `getStaticProps`.
      // `force-cache` is the default and can be omitted.
      const staticData = await fetch(`https://...`, { cache: 'force-cache' });
     
      // This request should be refetched on every request.
      // Similar to `getServerSideProps`.
      const dynamicData = await fetch(`https://...`, { cache: 'no-store' });
     
      // This request should be cached with a lifetime of 10 seconds.
      // Similar to `getStaticProps` with the `revalidate` option.
      const revalidatedData = await fetch(`https://...`, {
        next: { revalidate: 10 },
      });
     
      return <div>...</div>;
    }

Since Next.js extends the Web `fetch()` API, you can use any of the native
options available.

Further, Next.js polyfills `fetch` on both the client and the server, so you
can use fetch in both Server and Client Components.

Configure how the request should interact with Next.js HTTP cache.

    
    
    fetch(`https://...`, { cache: 'force-cache' | 'no-store' });

  * **`force-cache`** (default) - Next.js looks for a matching request in its HTTP cache. 
    * If there is a match and it is fresh, it will be returned from the cache.
    * If there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the downloaded resource.
  * **`no-store`** \- Next.js fetches the resource from the remote server on every request without looking in the cache, and it will not update the cache with the downloaded resource.

> **Good to know:**
>
>   * If you don't provide a `cache` option, Next.js will default to `force-
> cache`, unless a dynamic function such as `cookies()` is used, in which case
> it will default to `no-store`.
>   * The `no-cache` option behaves the same way as `no-store` in Next.js.
>

    
    
    fetch(`https://...`, { next: { revalidate: false | 0 | number } });

Set the cache lifetime of a resource (in seconds).

  * **`false`** \- Cache the resource indefinitely. Semantically equivalent to `revalidate: Infinity`. The HTTP cache may evict older resources over time.
  * **`0`** \- Prevent the resource from being cached.
  * **`number`** \- (in seconds) Specify the resource should have a cache lifetime of at most `n` seconds.

> **Good to know:**
>
>   * If an individual `fetch()` request sets a `revalidate` number lower than
> the default `revalidate` of a route, the whole route revalidation interval
> will be decreased.
>   * If two fetch requests with the same URL in the same route have different
> `revalidate` values, the lower value will be used.
>   * As a convenience, it is not necessary to set the `cache` option if
> `revalidate` is set to a number since `0` implies `cache: 'no-store'` and a
> positive value implies `cache: 'force-cache'`.
>   * Conflicting options such as `{ revalidate: 0, cache: 'force-cache' }` or
> `{ revalidate: 10, cache: 'no-store' }` will cause an error.
>





# generateImageMetadata

You can use `generateImageMetadata` to generate different versions of one
image or return multiple images for one route segment. This is useful for when
you want to avoid hard-coding metadata values, such as for icons.

`generateMetadata` function accepts the following parameters:

An object containing the dynamic route parameters object from the root segment
down to the segment `generateImageMetadata` is called from.

    
    
    export function generateImageMetadata({
      params,
    }: {
      params: { slug: string };
    }) {
      // ...
    }

Route| URL| `params`  
---|---|---  
`app/shop/icon.js`| `/shop`| `undefined`  
`app/shop/[slug]/icon.js`| `/shop/1`| `{ slug: '1' }`  
`app/shop/[tag]/[item]/icon.js`| `/shop/1/2`| `{ tag: '1', item: '2' }`  
`app/shop/[...slug]/icon.js`| `/shop/1/2`| `{ slug: ['1', '2'] }`  
  
The `generateImageMetadata` function should return an `array` of objects
containing the image's metadata such as `alt` and `size`. In addition, each
item **must** include an `id` value will be passed to the props of the image
generating function.

Image Metadata Object| Type  
---|---  
`id`| `string` (required)  
`alt`| `string`  
`size`| `{ width: number; height: number }`  
`contentType`| `string`  
      
    
    import { ImageResponse } from 'next/server';
     
    export function generateImageMetadata() {
      return [
        {
          contentType: 'image/png',
          size: { width: 48, height: 48 },
          id: 'small',
        },
        {
          contentType: 'image/png',
          size: { width: 72, height: 72 },
          id: 'medium',
        },
      ];
    }
     
    export default function Icon({ id }: { id: string }) {
      return new ImageResponse(
        (
          <div
            style={{
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 88,
              background: '#000',
              color: '#fafafa',
            }}
          >
            Icon {id}
          </div>
        ),
      );
    }

This example uses the `params` object and external data to generate multiple
Open Graph images for a route segment.

    
    
    import { ImageResponse } from 'next/server';
    import { getCaptionForImage, getOGImages } from '@/app/utils/images';
     
    export async function generateImageMetadata({
      params,
    }: {
      params: { id: string };
    }) {
      const images = await getOGImages(params.id);
     
      return images.map((image, idx) => ({
        id: idx,
        size: { width: 1200, height: 600 },
        alt: image.text,
        contentType: 'image/png',
      }));
    }
     
    export default async function Image({
      params,
      id,
    }: {
      params: { id: string };
      id: number;
    }) {
      const productId = params.id;
      const imageId = id;
      const text = await getCaptionForImage(productId, imageId);
     
      return new ImageResponse(
        (
          <div
            style={
              {
                // ...
              }
            }
          >
            {text}
          </div>
        ),
      );
    }





# Metadata Object and generateMetadata Options

This page covers all **Config-based Metadata** options with `generateMetadata`
and the static metadata object.

    
    
    import { Metadata } from 'next';
     
    // either Static metadata
    export const metadata: Metadata = {
      title: '...',
    };
     
    // or Dynamic metadata
    export async function generateMetadata({ params }) {
      return {
        title: '...',
      };
    }

> **Good to know:**
>
>   * The `metadata` object and `generateMetadata` function exports are **only
> supported in Server Components**.
>   * You cannot export both the `metadata` object and `generateMetadata`
> function from the same route segment.
>

To define static metadata, export a `Metadata` object from a `layout.js` or
`page.js` file.

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: '...',
      description: '...',
    };
     
    export default function Page() {}

See the Metadata Fields for a complete list of supported options.

Dynamic metadata depends on **dynamic information** , such as the current
route parameters, external data, or `metadata` in parent segments, can be set
by exporting a `generateMetadata` function that returns a `Metadata` object.

    
    
    import { Metadata, ResolvingMetadata } from 'next';
     
    type Props = {
      params: { id: string };
      searchParams: { [key: string]: string | string[] | undefined };
    };
     
    export async function generateMetadata(
      { params, searchParams }: Props,
      parent: ResolvingMetadata,
    ): Promise<Metadata> {
      // read route params
      const id = params.id;
     
      // fetch data
      const product = await fetch(`https://.../${id}`).then((res) => res.json());
     
      // optionally access and extend (rather than replace) parent metadata
      const previousImages = (await parent).openGraph?.images || [];
     
      return {
        title: product.title,
        openGraph: {
          images: ['/some-specific-page-image.jpg', ...previousImages],
        },
      };
    }
     
    export default function Page({ params, searchParams }: Props) {}

`generateMetadata` function accepts the following parameters:

`generateMetadata` should return a `Metadata` object containing one or more
metadata fields.

> **Good to know:**
>
>   * If metadata doesn't depend on runtime information, it should be defined
> using the static `metadata` object rather than `generateMetadata`.
>   * When rendering a route, Next.js will automatically deduplicate `fetch`
> requests for the same data across `generateMetadata`,
> `generateStaticParams`, Layouts, Pages, and Server Components. React `cache`
> can be used if `fetch` is unavailable.
>   * `searchParams` are only available in `page.js` segments.
>   * The `redirect()` and `notFound()` Next.js methods can also be used
> inside `generateMetadata`.
>

The `title` attribute is used to set the title of the document. It can be
defined as a simple string or an optional template object.

    
    
    export const metadata = {
      title: 'Next.js',
    };
    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: {
        template: '...',
        default: '...',
        absolute: '...',
      },
    };

`title.default` can be used to provide a **fallback title** to child route
segments that don't define a `title`.

    
    
    export const metadata = {
      title: {
        default: 'Acme',
      },
    };
    
    
    export const metadata = {};
     
    // Output: <title>Acme</title>

`title.template` can be used to add a prefix or a suffix to `titles` defined
in **child** route segments.

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: {
        template: '%s | Acme',
      },
    };
    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'About',
    };
     
    // Output: <title>About | Acme</title>

> **Good to know:**

`title.absolute` can be used to provide a title that **ignores**
`title.template` set in parent segments.

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: {
        template: '%s | Acme',
      },
    };
    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: {
        absolute: 'About',
      },
    };
     
    // Output: <title>About</title>

> **Good to know:**
>
>   * `layout.js`
>
>     * `title` (string) and `title.default` define the default title for
> child segments (that do not define their own `title`). It will augment
> `title.template` from the closest parent segment if it exists.
>     * `title.absolute` defines the default title for child segments. It
> ignores `title.template` from parent segments.
>     * `title.template` defines a new title template for child segments.
>   * `page.js`
>
>     * If a page does not define its own title the closest parents resolved
> title will be used.
>     * `title` (string) defines the routes title. It will augment
> `title.template` from the closest parent segment if it exists.
>     * `title.absolute` defines the route title. It ignores `title.template`
> from parent segments.
>     * `title.template` has no effect in `page.js` because a page is always
> the terminating segment of a route.
>

    
    
    export const metadata = {
      description: 'The React Framework for the Web',
    };
    
    
    <meta name="description" content="The React Framework for the Web" />
    
    
    export const metadata = {
      generator: 'Next.js',
      applicationName: 'Next.js',
      referrer: 'origin-when-cross-origin',
      keywords: ['Next.js', 'React', 'JavaScript'],
      authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],
      colorScheme: 'dark',
      creator: 'Jiachi Liu',
      publisher: 'Sebastian Markbåge',
      formatDetection: {
        email: false,
        address: false,
        telephone: false,
      },
    };
    
    
    <meta name="application-name" content="Next.js" />
    <meta name="author" content="Seb" />
    <link rel="author" href="https://nextjs.org" />
    <meta name="author" content="Josh" />
    <meta name="generator" content="Next.js" />
    <meta name="keywords" content="Next.js,React,JavaScript" />
    <meta name="referrer" content="origin-when-cross-origin" />
    <meta name="color-scheme" content="dark" />
    <meta name="creator" content="Jiachi Liu" />
    <meta name="publisher" content="Sebastian Markbåge" />
    <meta name="format-detection" content="telephone=no, address=no, email=no" />

`metadataBase` is a convenience option to set a base URL prefix for `metadata`
fields that require a fully qualified URL.

  * `metadataBase` allows URL-based `metadata` fields defined in the **current route segment and below** to use a **relative path** instead of an otherwise required absolute URL.
  * The field's relative path will be composed with `metadataBase` to form a fully qualified URL.
  * If not configured, `metadataBase` is **automatically populated** with a default value.

    
    
    export const metadata = {
      metadataBase: new URL('https://acme.com'),
      alternates: {
        canonical: '/',
        languages: {
          'en-US': '/en-US',
          'de-DE': '/de-DE',
        },
      },
      openGraph: {
        images: '/og-image.png',
      },
    };
    
    
    <link rel="canonical" href="https://acme.com" />
    <link rel="alternate" hreflang="en-US" href="https://nextjs.org/en-US" />
    <link rel="alternate" hreflang="de-DE" href="https://nextjs.org/de-DE" />
    <meta property="og:image" content="https://acme.com/og-image.png" />

> **Good to know:**
>
>   * `metadataBase` is typically set in root `app/layout.js` to apply to URL-
> based `metadata` fields across all routes.
>   * All URL-based `metadata` fields that require absolute URLs can be
> configured with a `metadataBase` option.
>   * `metadataBase` can contain a subdomain e.g. `https://app.acme.com` or
> base path e.g. `https://acme.com/start/from/here`
>   * If a `metadata` field provides an absolute URL, `metadataBase` will be
> ignored.
>   * Using a relative path in a URL-based `metadata` field without
> configuring a `metadataBase` will cause a build error.
>   * Next.js will normalize duplicate slashes between `metadataBase` (e.g.
> `https://acme.com/`) and a relative field (e.g. `/path`) to a single slash
> (e.g. `https://acme.com/path`)
>

If not configured, `metadataBase` has a **default value**

  * When `VERCEL_URL` is detected: `https://${process.env.VERCEL_URL}` otherwise it falls back to `http://localhost:${process.env.PORT || 3000}`.
  * When overriding the default, we recommend using environment variables to compute the URL. This allows configuring a URL for local development, staging, and production environments.

URL composition favors developer intent over default directory traversal
semantics.

  * Trailing slashes between `metadataBase` and `metadata` fields are normalized.
  * An "absolute" path in a `metadata` field (that typically would replace the whole URL path) is treated as a "relative" path (starting from the end of `metadataBase`).

For example, given the following `metadataBase`:

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      metadataBase: new URL('https://acme.com/api'),
    };

Any `metadata` fields that inherit the above `metadataBase` and set their own
value will be resolved as follows:

`metadata` field| Resolved URL  
---|---  
`/`| `https://acme.com/api`  
`./`| `https://acme.com/api`  
`payments`| `https://acme.com/api/payments`  
`/payments`| `https://acme.com/api/payments`  
`./payments`| `https://acme.com/api/payments`  
`../payments`| `https://acme.com/payments`  
`https://beta.acme.com/api/payments`| `https://beta.acme.com/api/payments`  
      
    
    export const metadata = {
      openGraph: {
        title: 'Next.js',
        description: 'The React Framework for the Web',
        url: 'https://nextjs.org',
        siteName: 'Next.js',
        images: [
          {
            url: 'https://nextjs.org/og.png',
            width: 800,
            height: 600,
          },
          {
            url: 'https://nextjs.org/og-alt.png',
            width: 1800,
            height: 1600,
            alt: 'My custom alt',
          },
        ],
        locale: 'en_US',
        type: 'website',
      },
    };
    
    
    <meta property="og:title" content="Next.js" />
    <meta property="og:description" content="The React Framework for the Web" />
    <meta property="og:url" content="https://nextjs.org/" />
    <meta property="og:site_name" content="Next.js" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:image:url" content="https://nextjs.org/og.png" />
    <meta property="og:image:width" content="800" />
    <meta property="og:image:height" content="600" />
    <meta property="og:image:url" content="https://nextjs.org/og-alt.png" />
    <meta property="og:image:width" content="1800" />
    <meta property="og:image:height" content="1600" />
    <meta property="og:image:alt" content="My custom alt" />
    <meta property="og:type" content="website" />
    
    
    export const metadata = {
      openGraph: {
        title: 'Next.js',
        description: 'The React Framework for the Web',
        type: 'article',
        publishedTime: '2023-01-01T00:00:00.000Z',
        authors: ['Seb', 'Josh'],
      },
    };
    
    
    <meta property="og:title" content="Next.js" />
    <meta property="og:description" content="The React Framework for the Web" />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2023-01-01T00:00:00.000Z" />
    <meta property="article:author" content="Seb" />
    <meta property="article:author" content="Josh" />

> **Good to know:**
>
>   * It may be more convenient to use the file-based Metadata API for Open
> Graph images. Rather than having to sync the config export with actual
> files, the file-based API will automatically generate the correct metadata
> for you.
>

    
    
    export const metadata = {
      robots: {
        index: false,
        follow: true,
        nocache: true,
        googleBot: {
          index: true,
          follow: false,
          noimageindex: true,
          'max-video-preview': -1,
          'max-image-preview': 'large',
          'max-snippet': -1,
        },
      },
    };
    
    
    <meta name="robots" content="noindex, follow, nocache" />
    <meta
      name="googlebot"
      content="index, nofollow, noimageindex, max-video-preview:-1, max-image-preview:large, max-snippet:-1"
    />

Note: We recommend using the file-based Metadata API for icons where possible.
Rather than having to sync the config export with actual files, the file-based
API will automatically generate the correct metadata for you.

    
    
    export const metadata = {
      icons: {
        icon: '/icon.png',
        shortcut: '/shortcut-icon.png',
        apple: '/apple-icon.png',
        other: {
          rel: 'apple-touch-icon-precomposed',
          url: '/apple-touch-icon-precomposed.png',
        },
      },
    };
    
    
    <link rel="shortcut icon" href="/shortcut-icon.png" />
    <link rel="icon" href="/icon.png" />
    <link rel="apple-touch-icon" href="/apple-icon.png" />
    <link
      rel="apple-touch-icon-precomposed"
      href="/apple-touch-icon-precomposed.png"
    />
    
    
    export const metadata = {
      icons: {
        icon: [{ url: '/icon.png' }, new URL('/icon.png', 'https://example.com')],
        shortcut: ['/shortcut-icon.png'],
        apple: [
          { url: '/apple-icon.png' },
          { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },
        ],
        other: [
          {
            rel: 'apple-touch-icon-precomposed',
            url: '/apple-touch-icon-precomposed.png',
          },
        ],
      },
    };
    
    
    <link rel="shortcut icon" href="/shortcut-icon.png" />
    <link rel="icon" href="/icon.png" />
    <link rel="apple-touch-icon" href="/apple-icon.png" />
    <link
      rel="apple-touch-icon-precomposed"
      href="/apple-touch-icon-precomposed.png"
    />
    <link rel="icon" href="https://example.com/icon.png" />
    <link
      rel="apple-touch-icon"
      href="/apple-icon-x3.png"
      sizes="180x180"
      type="image/png"
    />

> **Note:** The `msapplication-*` meta tags are no longer supported in
> Chromium builds of Microsoft Edge, and thus no longer needed.

Learn more about theme-color.

**Simple theme color**

    
    
    export const metadata = {
      themeColor: 'black',
    };
    
    
    <meta name="theme-color" content="black" />

**With media attribute**

    
    
    export const metadata = {
      themeColor: [
        { media: '(prefers-color-scheme: light)', color: 'cyan' },
        { media: '(prefers-color-scheme: dark)', color: 'black' },
      ],
    };
    
    
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />

A web application manifest, as defined in the Web Application Manifest
specification.

    
    
    export const metadata = {
      manifest: 'https://nextjs.org/manifest.json',
    };
    
    
    <link rel="manifest" href="https://nextjs.org/manifest.json" />

Learn more about the Twitter Card markup reference.

    
    
    export const metadata = {
      twitter: {
        card: 'summary_large_image',
        title: 'Next.js',
        description: 'The React Framework for the Web',
        siteId: '1467726470533754880',
        creator: '@nextjs',
        creatorId: '1467726470533754880',
        images: ['https://nextjs.org/og.png'],
      },
    };
    
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site:id" content="1467726470533754880" />
    <meta name="twitter:creator" content="@nextjs" />
    <meta name="twitter:creator:id" content="1467726470533754880" />
    <meta name="twitter:title" content="Next.js" />
    <meta name="twitter:description" content="The React Framework for the Web" />
    <meta name="twitter:image" content="https://nextjs.org/og.png" />
    
    
    export const metadata = {
      twitter: {
        card: 'app',
        title: 'Next.js',
        description: 'The React Framework for the Web',
        siteId: '1467726470533754880',
        creator: '@nextjs',
        creatorId: '1467726470533754880',
        images: {
          url: 'https://nextjs.org/og.png',
          alt: 'Next.js Logo',
        },
        app: {
          name: 'twitter_app',
          id: {
            iphone: 'twitter_app://iphone',
            ipad: 'twitter_app://ipad',
            googleplay: 'twitter_app://googleplay',
          },
          url: {
            iphone: 'https://iphone_url',
            ipad: 'https://ipad_url',
          },
        },
      },
    };
    
    
    <meta name="twitter:site:id" content="1467726470533754880" />
    <meta name="twitter:creator" content="@nextjs" />
    <meta name="twitter:creator:id" content="1467726470533754880" />
    <meta name="twitter:title" content="Next.js" />
    <meta name="twitter:description" content="The React Framework for the Web" />
    <meta name="twitter:card" content="app" />
    <meta name="twitter:image" content="https://nextjs.org/og.png" />
    <meta name="twitter:image:alt" content="Next.js Logo" />
    <meta name="twitter:app:name:iphone" content="twitter_app" />
    <meta name="twitter:app:id:iphone" content="twitter_app://iphone" />
    <meta name="twitter:app:id:ipad" content="twitter_app://ipad" />
    <meta name="twitter:app:id:googleplay" content="twitter_app://googleplay" />
    <meta name="twitter:app:url:iphone" content="https://iphone_url" />
    <meta name="twitter:app:url:ipad" content="https://ipad_url" />
    <meta name="twitter:app:name:ipad" content="twitter_app" />
    <meta name="twitter:app:name:googleplay" content="twitter_app" />

> **Note** : The `viewport` meta tag is automatically set with the following
> default values. Usually, manual configuration is unnecessary as the default
> is sufficient. However, the information is provided for completeness.
    
    
    export const metadata = {
      viewport: {
        width: 'device-width',
        initialScale: 1,
        maximumScale: 1,
      },
    };
    
    
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    
    
    export const metadata = {
      verification: {
        google: 'google',
        yandex: 'yandex',
        yahoo: 'yahoo',
        other: {
          me: ['my-email', 'my-link'],
        },
      },
    };
    
    
    <meta name="google-site-verification" content="google" />
    <meta name="y_key" content="yahoo" />
    <meta name="yandex-verification" content="yandex" />
    <meta name="me" content="my-email" />
    <meta name="me" content="my-link" />
    
    
    export const metadata = {
      itunes: {
        appId: 'myAppStoreID',
        appArgument: 'myAppArgument',
      },
      appleWebApp: {
        title: 'Apple Web App',
        statusBarStyle: 'black-translucent',
        startupImage: [
          '/assets/startup/apple-touch-startup-image-768x1004.png',
          {
            url: '/assets/startup/apple-touch-startup-image-1536x2008.png',
            media: '(device-width: 768px) and (device-height: 1024px)',
          },
        ],
      },
    };
    
    
    <meta
      name="apple-itunes-app"
      content="app-id=myAppStoreID, app-argument=myAppArgument"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Apple Web App" />
    <link
      href="/assets/startup/apple-touch-startup-image-768x1004.png"
      rel="apple-touch-startup-image"
    />
    <link
      href="/assets/startup/apple-touch-startup-image-1536x2008.png"
      media="(device-width: 768px) and (device-height: 1024px)"
      rel="apple-touch-startup-image"
    />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    
    
    export const metadata = {
      alternates: {
        canonical: 'https://nextjs.org',
        languages: {
          'en-US': 'https://nextjs.org/en-US',
          'de-DE': 'https://nextjs.org/de-DE',
        },
        media: {
          'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',
        },
        types: {
          'application/rss+xml': 'https://nextjs.org/rss',
        },
      },
    };
    
    
    <link rel="canonical" href="https://nextjs.org" />
    <link rel="alternate" hreflang="en-US" href="https://nextjs.org/en-US" />
    <link rel="alternate" hreflang="de-DE" href="https://nextjs.org/de-DE" />
    <link
      rel="alternate"
      media="only screen and (max-width: 600px)"
      href="https://nextjs.org/mobile"
    />
    <link
      rel="alternate"
      type="application/rss+xml"
      href="https://nextjs.org/rss"
    />
    
    
    export const metadata = {
      appLinks: {
        ios: {
          url: 'https://nextjs.org/ios',
          app_store_id: 'app_store_id',
        },
        android: {
          package: 'com.example.android/package',
          app_name: 'app_name_android',
        },
        web: {
          url: 'https://nextjs.org/web',
          should_fallback: true,
        },
      },
    };
    
    
    <meta property="al:ios:url" content="https://nextjs.org/ios" />
    <meta property="al:ios:app_store_id" content="app_store_id" />
    <meta property="al:android:package" content="com.example.android/package" />
    <meta property="al:android:app_name" content="app_name_android" />
    <meta property="al:web:url" content="https://nextjs.org/web" />
    <meta property="al:web:should_fallback" content="true" />

Describes a collection of records, documents, or other materials of historical
interest (source).

    
    
    export const metadata = {
      archives: ['https://nextjs.org/13'],
    };
    
    
    <link rel="archives" href="https://nextjs.org/13" />
    
    
    export const metadata = {
      assets: ['https://nextjs.org/assets'],
    };
    
    
    <link rel="assets" href="https://nextjs.org/assets" />
    
    
    export const metadata = {
      bookmarks: ['https://nextjs.org/13'],
    };
    
    
    <link rel="bookmarks" href="https://nextjs.org/13" />
    
    
    export const metadata = {
      category: 'technology',
    };
    
    
    <meta name="category" content="technology" />

All metadata options should be covered using the built-in support. However,
there may be custom metadata tags specific to your site, or brand new metadata
tags just released. You can use the `other` option to render any custom
metadata tag.

    
    
    export const metadata = {
      other: {
        custom: 'meta',
      },
    };
    
    
    <meta name="custom" content="meta" />

The following metadata types do not currently have built-in support. However,
they can still be rendered in the layout or page itself.

The `<link>` element has a number of `rel` keywords that can be used to hint
to the browser that a external resource is likely to be needed. The browser
uses this information to apply preloading optimizations depending on the
keyword.

While the Metadata API doesn't directly support these hints, you can use new
`ReactDOM` methods to safely insert them into the `<head>` of the document.

    
    
    'use client';
     
    import ReactDOM from 'react-dom';
     
    export function PreloadResources() {
      ReactDOM.preload('...', { as: '...' });
      ReactDOM.preconnect('...', { crossOrigin: '...' });
      ReactDOM.prefetchDNS('...');
     
      return null;
    }

Start loading a resource early in the page rendering (browser) lifecycle. MDN
Docs.

    
    
    ReactDOM.preload(href: string, options: { as: string })
    
    
    <link rel="preload" href="..." as="..." />

Preemptively initiate a connection to an origin. MDN Docs.

    
    
    ReactDOM.preconnect(href: string, options?: { crossOrigin?: string })
    
    
    <link rel="preconnect" href="..." crossorigin />

Attempt to resolve a domain name before resources get requested. MDN Docs.

    
    
    ReactDOM.prefetchDNS(href: string)
    
    
    <link rel="dns-prefetch" href="..." />

> **Good to know:**
>
>   * These methods are currently only supported in Client Components.
>     * Note: Client Components are still Server Side Rendered on initial page
> load.
>   * Next.js in-built features such as `next/font`, `next/image` and
> `next/script` automatically handle relevant resource hints.
>   * React 18.3 does not yet include type definitions for `ReactDOM.preload`,
> `ReactDOM.preconnect`, and `ReactDOM.preconnectDNS`. You can use `// @ts-
> ignore` as a temporary solution to avoid type errors.
>

You can add type safety to your metadata by using the `Metadata` type. If you
are using the built-in TypeScript plugin in your IDE, you do not need to
manually add the type, but you can still explicitly add it if you want.

    
    
    import type { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'Next.js',
    };
    
    
    import type { Metadata } from 'next';
     
    export function generateMetadata(): Metadata {
      return {
        title: 'Next.js',
      };
    }
    
    
    import type { Metadata } from 'next';
     
    export async function generateMetadata(): Promise<Metadata> {
      return {
        title: 'Next.js',
      };
    }
    
    
    import type { Metadata } from 'next';
     
    type Props = {
      params: { id: string };
      searchParams: { [key: string]: string | string[] | undefined };
    };
     
    export function generateMetadata({ params, searchParams }: Props): Metadata {
      return {
        title: 'Next.js',
      };
    }
     
    export default function Page({ params, searchParams }: Props) {}
    
    
    import type { Metadata, ResolvingMetadata } from 'next';
     
    export async function generateMetadata(
      { params, searchParams }: Props,
      parent: ResolvingMetadata,
    ): Promise<Metadata> {
      return {
        title: 'Next.js',
      };
    }

For JavaScript projects, you can use JSDoc to add type safety.

    
    
    /** @type {import("next").Metadata} */
    export const metadata = {
      title: 'Next.js',
    };





# generateStaticParams

The `generateStaticParams` function can be used in combination with dynamic
route segments to **statically generate** routes at build time instead of on-
demand at request time.

    
    
    // Return a list of `params` to populate the [slug] dynamic segment
    export async function generateStaticParams() {
      const posts = await fetch('https://.../posts').then((res) => res.json());
     
      return posts.map((post) => ({
        slug: post.slug,
      }));
    }
     
    // Multiple versions of this page will be statically generated
    // using the `params` returned by `generateStaticParams`
    export default function Page({ params }) {
      const { slug } = params;
      // ...
    }

> **Good to know**
>
>   * You can use the `dynamicParams` segment config option to control what
> happens when a dynamic segment is visited that was not generated with
> `generateStaticParams`.
>   * During `next dev`, `generateStaticParams` will be called when you
> navigate to a route.
>   * During `next build`, `generateStaticParams` runs before the
> corresponding Layouts or Pages are generated.
>   * During revalidation (ISR), `generateStaticParams` will not be called
> again.
>   * `generateStaticParams` replaces the `getStaticPaths` function in the
> Pages Router.
>

`options.params` (optional)

If multiple dynamic segments in a route use `generateStaticParams`, the child
`generateStaticParams` function is executed once for each set of `params` the
parent generates.

The `params` object contains the populated `params` from the parent
`generateStaticParams`, which can be used to generate the `params` in a child
segment.

`generateStaticParams` should return an array of objects where each object
represents the populated dynamic segments of a single route.

  * Each property in the object is a dynamic segment to be filled in for the route.
  * The properties name is the segment's name, and the properties value is what that segment should be filled in with.

Example Route| `generateStaticParams` Return Type  
---|---  
`/product/[id]`| `{ id: string }[]`  
`/products/[category]/[product]`| `{ category: string, product: string }[]`  
`/products/[...slug]`| `{ slug: string[] }[]`  
      
    
    export function generateStaticParams() {
      return [{ id: '1' }, { id: '2' }, { id: '3' }];
    }
     
    // Three versions of this page will be statically generated
    // using the `params` returned by `generateStaticParams`
    // - /product/1
    // - /product/2
    // - /product/3
    export default function Page({ params }: { params: { id: string } }) {
      const { id } = params;
      // ...
    }
    
    
    export function generateStaticParams() {
      return [
        { category: 'a', product: '1' },
        { category: 'b', product: '2' },
        { category: 'c', product: '3' },
      ];
    }
     
    // Three versions of this page will be statically generated
    // using the `params` returned by `generateStaticParams`
    // - /product/a/1
    // - /product/b/2
    // - /product/c/3
    export default function Page({
      params,
    }: {
      params: { category: string; product: string };
    }) {
      const { category, product } = params;
      // ...
    }
    
    
    export function generateStaticParams() {
      return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }];
    }
     
    // Three versions of this page will be statically generated
    // using the `params` returned by `generateStaticParams`
    // - /product/a/1
    // - /product/b/2
    // - /product/c/3
    export default function Page({ params }: { params: { slug: string[] } }) {
      const { slug } = params;
      // ...
    }

You can generate params for dynamic segments above the current layout or page,
but **not below**. For example, given the `app/products/[category]/[product]`
route:

  * `app/products/[category]/[product]/page.js` can generate params for **both** `[category]` and `[product]`.
  * `app/products/[category]/layout.js` can **only** generate params for `[category]`.

There are two approaches to generating params for a route with multiple
dynamic segments:

Generate multiple dynamic segments from the child route segment.

    
    
    // Generate segments for both [category] and [product]
    export async function generateStaticParams() {
      const products = await fetch('https://.../products').then((res) =>
        res.json(),
      );
     
      return products.map((product) => ({
        category: product.category.slug,
        product: product.id,
      }));
    }
     
    export default function Page({
      params,
    }: {
      params: { category: string; product: string };
    }) {
      // ...
    }

Generate the parent segments first and use the result to generate the child
segments.

    
    
    // Generate segments for [category]
    export async function generateStaticParams() {
      const products = await fetch('https://.../products').then((res) =>
        res.json(),
      );
     
      return products.map((product) => ({
        category: product.category.slug,
      }));
    }
     
    export default function Layout({ params }: { params: { category: string } }) {
      // ...
    }

A child route segment's `generateStaticParams` function is executed once for
each segment a parent `generateStaticParams` generates.

The child `generateStaticParams` function can use the `params` returned from
the parent `generateStaticParams` function to dynamically generate its own
segments.

    
    
    // Generate segments for [product] using the `params` passed from
    // the parent segment's `generateStaticParams` function
    export async function generateStaticParams({
      params: { category },
    }: {
      params: { category: string };
    }) {
      const products = await fetch(
        `https://.../products?category=${category}`,
      ).then((res) => res.json());
     
      return products.map((product) => ({
        product: product.id,
      }));
    }
     
    export default function Page({
      params,
    }: {
      params: { category: string; product: string };
    }) {
      // ...
    }

> **Good to know** : When rendering a route, Next.js will automatically
> deduplicate `fetch` requests for the same data across `generateMetadata`,
> `generateStaticParams`, Layouts, Pages, and Server Components. React `cache`
> can be used if `fetch` is unavailable.





Using App Router

Features available in /app





Using App Router

Features available in /app





# NextRequest

NextRequest extends the Web Request API with additional convenience methods.

Read or mutate the `Set-Cookie` header of the request.

Given a name, set a cookie with the given value on the request.

    
    
    // Given incoming request /home
    // Set a cookie to hide the banner
    // request will have a `Set-Cookie:show-banner=false;path=/home` header
    request.cookies.set('show-banner', 'false');

Given a cookie name, return the value of the cookie. If the cookie is not
found, `undefined` is returned. If multiple cookies are found, the first one
is returned.

    
    
    // Given incoming request /home
    // { name: 'show-banner', value: 'false', Path: '/home' }
    request.cookies.get('show-banner');

Given a cookie name, return the values of the cookie. If no name is given,
return all cookies on the request.

    
    
    // Given incoming request /home
    // [
    //   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
    //   { name: 'experiments', value: 'winter-launch', Path: '/home' },
    // ]
    request.cookies.getAll('experiments');
    // Alternatively, get all cookies for the request
    request.cookies.getAll();

Given a cookie name, delete the cookie from the request.

    
    
    // Returns true for deleted, false is nothing is deleted
    request.cookies.delete('experiments');

Given a cookie name, return `true` if the cookie exists on the request.

    
    
    // Returns true if cookie exists, false if it does not
    request.cookies.has('experiments');

Remove the `Set-Cookie` header from the request.

Extends the native `URL` API with additional convenience methods, including
Next.js specific properties.

    
    
    // Given a request to /home, pathname is /home
    request.nextUrl.pathname;
    // Given a request to /home?name=lee, searchParams is { 'name': 'lee' }
    request.nextUrl.searchParams;





# NextResponse

NextResponse extends the Web Response API with additional convenience methods.

Read or mutate the `Set-Cookie` header of the response.

Given a name, set a cookie with the given value on the response.

    
    
    // Given incoming request /home
    let response = NextResponse.next();
    // Set a cookie to hide the banner
    response.cookies.set('show-banner', 'false');
    // Response will have a `Set-Cookie:show-banner=false;path=/home` header
    return response;

Given a cookie name, return the value of the cookie. If the cookie is not
found, `undefined` is returned. If multiple cookies are found, the first one
is returned.

    
    
    // Given incoming request /home
    let response = NextResponse.next();
    // { name: 'show-banner', value: 'false', Path: '/home' }
    response.cookies.get('show-banner');

Given a cookie name, return the values of the cookie. If no name is given,
return all cookies on the response.

    
    
    // Given incoming request /home
    let response = NextResponse.next();
    // [
    //   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
    //   { name: 'experiments', value: 'winter-launch', Path: '/home' },
    // ]
    response.cookies.getAll('experiments');
    // Alternatively, get all cookies for the response
    response.cookies.getAll();

Given a cookie name, delete the cookie from the response.

    
    
    // Given incoming request /home
    let response = NextResponse.next();
    // Returns true for deleted, false is nothing is deleted
    response.cookies.delete('experiments');

Produce a response with the given JSON body.

    
    
    import { NextResponse } from 'next/server';
     
    export async function GET(request: Request) {
      return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }

Produce a response that redirects to a URL.

    
    
    import { NextResponse } from 'next/server';
     
    return NextResponse.redirect(new URL('/new', request.url));

The URL can be created and modified before being used in the
`NextResponse.redirect()` method. For example, you can use the
`request.nextUrl` property to get the current URL, and then modify it to
redirect to a different URL.

    
    
    import { NextResponse } from 'next/server';
     
    // Given an incoming request...
    const loginUrl = new URL('/login', request.url);
    // Add ?from=/incoming-url to the /login URL
    loginUrl.searchParams.set('from', request.nextUrl.pathname);
    // And redirect to the new URL
    return NextResponse.redirect(loginUrl);

Produce a response that rewrites (proxies) the given URL while preserving
showing the original URL.

    
    
    import { NextResponse } from 'next/server';
     
    // Incoming request: /about, browser shows /about
    // Rewritten request: /proxy, browser shows /about
    return NextResponse.rewrite(new URL('/proxy', request.url));

The `next()` method is useful for Middleware, as it allows you to return early
and continue routing.

    
    
    import { NextResponse } from 'next/server';
     
    return NextResponse.next();

You can also forward `headers` when producing the response:

    
    
    import { NextResponse } from 'next/server';
     
    // Given an incoming request...
    const newHeaders = new Headers(request.headers);
    // Add a new header
    newHeaders.set('x-version', '123');
    // And produce a response with the new headers
    return NextResponse.next({
      request: {
        // New request headers
        headers: newHeaders,
      },
    });





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# useReportWebVitals

The `useReportWebVitals` hook allows you to report Core Web Vitals, and can be
used in combination with your analytics service.

    
    
    'use client';
     
    import { useReportWebVitals } from 'next/web-vitals';
     
    export function WebVitals() {
      useReportWebVitals((metric) => {
        console.log(metric);
      });
    }
    
    
    import { WebVitals } from './_components/web-vitals';
     
    export default function Layout({ children }) {
      return (
        <html>
          <body>
            <WebVitals />
            {children}
          </body>
        </html>
      );
    }

> Since the `useReportWebVitals` hook requires the `"use client"` directive,
> the most performant approach is to create a separate component that the root
> layout imports. This confines the client boundary exclusively to the
> `WebVitals` component.

The `metric` object passed as the hook's argument consists of a number of
properties:

  * `id`: Unique identifier for the metric in the context of the current page load
  * `name`: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.
  * `delta`: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.
  * `entries`: An array of Performance Entries associated with the metric. These entries provide detailed information about the performance events related to the metric.
  * `navigationType`: Indicates the type of navigation that triggered the metric collection. Possible values include `"navigate"`, `"reload"`, `"back_forward"`, and `"prerender"`.
  * `rating`: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are `"good"`, `"needs-improvement"`, and `"poor"`. The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.
  * `value`: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from various Performance APIs.

Web Vitals are a set of useful metrics that aim to capture the user experience
of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the `name` property.

    
    
    'use client';
     
    import { useReportWebVitals } from 'next/web-vitals';
     
    export function WebVitals() {
      useReportWebVitals((metric) => {
        switch (metric.name) {
          case 'FCP': {
            // handle FCP results
          }
          case 'LCP': {
            // handle LCP results
          }
          // ...
        }
      });
    }

Vercel Speed Insights are automatically configured on Vercel deployments, and
don't require the use of `useReportWebVitals`. This hook is useful in local
development, or if you're using a different analytics service.

You can send results to any endpoint to measure and track real user
performance on your site. For example:

    
    
    useReportWebVitals((metric) => {
      const body = JSON.stringify(metric);
      const url = 'https://example.com/analytics';
     
      // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url, body);
      } else {
        fetch(url, { body, method: 'POST', keepalive: true });
      }
    });

> **Note** : If you use Google Analytics, using the `id` value can allow you
> to construct metric distributions manually (to calculate percentiles, etc.)

>
>     useReportWebVitals(metric => {
>       // Use `window.gtag` if you initialized Google Analytics as this
> example:
>       // https://github.com/vercel/next.js/blob/canary/examples/with-google-
> analytics/pages/_app.js
>       window.gtag('event', metric.name, {
>         value: Math.round(metric.name === 'CLS' ? metric.value * 1000 :
> metric.value), // values must be integers
>         event_label: metric.id, // id unique to current page load
>         non_interaction: true, // avoids affecting bounce rate.
>       });
>     }
>
> Read more about sending results to Google Analytics.





Using App Router

Features available in /app





# useSearchParams

`useSearchParams` is a **Client Component** hook that lets you read the
current URL's **query string**.

`useSearchParams` returns a **read-only** version of the `URLSearchParams`
interface.

    
    
    'use client';
     
    import { useSearchParams } from 'next/navigation';
     
    export default function SearchBar() {
      const searchParams = useSearchParams();
     
      const search = searchParams.get('search');
     
      // URL -> `/dashboard?search=my-project`
      // `search` -> 'my-project'
      return <>Search: {search}</>;
    }
    
    
    const searchParams = useSearchParams();

`useSearchParams` does not take any parameters.

`useSearchParams` returns a **read-only** version of the `URLSearchParams`
interface, which includes utility methods for reading the URL's query string:

> **Good to know:**
>
>   * `useSearchParams` is a Client Component hook and is **not supported** in
> Server Components to prevent stale values during partial rendering.
>   * If an application includes the `/pages` directory, `useSearchParams`
> will return `ReadonlyURLSearchParams | null`. The `null` value is for
> compatibility during migration since search params cannot be known during
> pre-rendering of a page that doesn't use `getServerSideProps`
>

If a route is statically rendered, calling `useSearchParams()` will cause the
tree up to the closest `Suspense` boundary to be client-side rendered.

This allows a part of the page to be statically rendered while the dynamic
part that uses `searchParams` is client-side rendered.

You can reduce the portion of the route that is client-side rendered by
wrapping the component that uses `useSearchParams` in a `Suspense` boundary.
For example:

    
    
    'use client';
     
    import { useSearchParams } from 'next/navigation';
     
    export default function SearchBar() {
      const searchParams = useSearchParams();
     
      const search = searchParams.get('search');
     
      // This will not be logged on the server when using static rendering
      console.log(search);
     
      return <>Search: {search}</>;
    }
    
    
    import { Suspense } from 'react';
    import SearchBar from './search-bar';
     
    // This component passed as a fallback to the Suspense boundary
    // will be rendered in place of the search bar in the initial HTML.
    // When the value is available during React hydration the fallback
    // will be replaced with the `<SearchBar>` component.
    function SearchBarFallback() {
      return <>placeholder</>;
    }
     
    export default function Page() {
      return (
        <>
          <nav>
            <Suspense fallback={<SearchBarFallback />}>
              <SearchBar />
            </Suspense>
          </nav>
          <h1>Dashboard</h1>
        </>
      );
    }

If a route is dynamically rendered, `useSearchParams` will be available on the
server during the initial server render of the Client Component.

> **Note:** Setting the `dynamic` route segment config option to `force-
> dynamic` can be used to force dynamic rendering.

For example:

    
    
    'use client';
     
    import { useSearchParams } from 'next/navigation';
     
    export default function SearchBar() {
      const searchParams = useSearchParams();
     
      const search = searchParams.get('search');
     
      // This will be logged on the server during the initial render
      // and on the client on subsequent navigations.
      console.log(search);
     
      return <>Search: {search}</>;
    }
    
    
    import SearchBar from './search-bar';
     
    export const dynamic = 'force-dynamic';
     
    export default function Page() {
      return (
        <>
          <nav>
            <SearchBar />
          </nav>
          <h1>Dashboard</h1>
        </>
      );
    }

To access search params in Pages (Server Components), use the `searchParams`
prop.

Unlike Pages, Layouts (Server Components) **do not** receive the
`searchParams` prop. This is because a shared layout is not re-rendered during
navigation which could lead to stale `searchParams` between navigations. View
detailed explanation.

Instead, use the Page `searchParams` prop or the `useSearchParams` hook in a
Client Component, which is re-rendered on the client with the latest
`searchParams`.

You can use `useRouter` or `Link` to set new `searchParams`. After a
navigation is performed, the current `page.js` will receive an updated
`searchParams` prop.

    
    
    export default function ExampleClientComponent() {
      const router = useRouter();
      const pathname = usePathname();
      const searchParams = useSearchParams()!;
     
      // Get a new searchParams string by merging the current
      // searchParams with a provided key/value pair
      const createQueryString = useCallback(
        (name: string, value: string) => {
          const params = new URLSearchParams(searchParams);
          params.set(name, value);
     
          return params.toString();
        },
        [searchParams],
      );
     
      return (
        <>
          <p>Sort By</p>
     
          {/* using useRouter */}
          <button
            onClick={() => {
              // <pathname>?sort=asc
              router.push(pathname + '?' + createQueryString('sort', 'asc'));
            }}
          >
            ASC
          </button>
     
          {/* using <Link> */}
          <Link
            href={
              // <pathname>?sort=desc
              pathname + '?' + createQueryString('sort', 'desc')
            }
          >
            DESC
          </Link>
        </>
      );
    }





# useSelectedLayoutSegment

`useSelectedLayoutSegment` is a **Client Component** hook that lets you read
the active route segment **one level below** the Layout it is called from.

It is useful for navigation UI, such as tabs inside a parent layout that
change style depending on the active child segment.

    
    
    'use client';
     
    import { useSelectedLayoutSegment } from 'next/navigation';
     
    export default function ExampleClientComponent() {
      const segment = useSelectedLayoutSegment();
     
      return <>Active segment: {segment}</>;
    }

> **Good to know:**
>
>   * Since `useSelectedLayoutSegment` is a Client Component hook, and Layouts
> are Server Components by default, `useSelectedLayoutSegment` is usually
> called via a Client Component that is imported into a Layout.
>   * `useSelectedLayoutSegment` only returns the segment one level down. To
> return all active segments, see `useSelectedLayoutSegments`
>

    
    
    const segment = useSelectedLayoutSegment();

`useSelectedLayoutSegment` does not take any parameters.

`useSelectedLayoutSegment` returns a string of the active segment or `null` if
one doesn't exist.

For example, given the Layouts and URLs below, the returned segment would be:

Layout| Visited URL| Returned Segment  
---|---|---  
`app/layout.js`| `/`| `null`  
`app/layout.js`| `/dashboard`| `'dashboard'`  
`app/dashboard/layout.js`| `/dashboard`| `null`  
`app/dashboard/layout.js`| `/dashboard/settings`| `'settings'`  
`app/dashboard/layout.js`| `/dashboard/analytics`| `'analytics'`  
`app/dashboard/layout.js`| `/dashboard/analytics/monthly`| `'analytics'`  
  
You can use `useSelectedLayoutSegment` to create an active link component that
changes style depending on the active segment. For example, a featured posts
list in the sidebar of a blog:

    
    
    'use client';
     
    import Link from 'next/link';
    import { useSelectedLayoutSegment } from 'next/navigation';
     
    // This *client* component will be imported into a blog layout
    export default function BlogNavLink({
      slug,
      children,
    }: {
      slug: string;
      children: React.ReactNode;
    }) {
      // Navigating to `/blog/hello-world` will return 'hello-world'
      // for the selected layout segment
      const segment = useSelectedLayoutSegment();
      const isActive = slug === segment;
     
      return (
        <Link
          href={`/blog/${slug}`}
          // Change style depending on whether the link is active
          style={{ fontWeight: isActive ? 'bold' : 'normal' }}
        >
          {children}
        </Link>
      );
    }
    
    
    // Import the Client Component into a parent Layout (Server Component)
    import { BlogNavLink } from './blog-nav-link';
    import getFeaturedPosts from './get-featured-posts';
     
    export default async function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const featuredPosts = await getFeaturedPosts();
      return (
        <div>
          {featuredPosts.map((post) => (
            <div key={post.id}>
              <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>
            </div>
          ))}
          <div>{children}</div>
        </div>
      );
    }





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# assetPrefix

> **Attention** : Deploying to Vercel automatically configures a global CDN
> for your Next.js project. You do not need to manually setup an Asset Prefix.

> **Note** : Next.js 9.5+ added support for a customizable Base Path, which is
> better suited for hosting your application on a sub-path like `/docs`. We do
> not suggest you use a custom Asset Prefix for this use case.

To set up a CDN, you can set up an asset prefix and configure your CDN's
origin to resolve to the domain that Next.js is hosted on.

Open `next.config.js` and add the `assetPrefix` config:

    
    
    const isProd = process.env.NODE_ENV === 'production';
     
    module.exports = {
      // Use the CDN in production and localhost for development.
      assetPrefix: isProd ? 'https://cdn.mydomain.com' : undefined,
    };

Next.js will automatically use your asset prefix for the JavaScript and CSS
files it loads from the `/_next/` path (`.next/static/` folder). For example,
with the above configuration, the following request for a JS chunk:

    
    
    /_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
    

Would instead become:

    
    
    https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
    

The exact configuration for uploading your files to a given CDN will depend on
your CDN of choice. The only folder you need to host on your CDN is the
contents of `.next/static/`, which should be uploaded as `_next/static/` as
the above URL request indicates. **Do not upload the rest of your`.next/`
folder**, as you should not expose your server code and other configuration to
the public.

While `assetPrefix` covers requests to `_next/static`, it does not influence
the following paths:

  * Files in the public folder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself
  * `/_next/data/` requests for `getServerSideProps` pages. These requests will always be made against the main domain since they're not static.
  * `/_next/data/` requests for `getStaticProps` pages. These requests will always be made against the main domain to support Incremental Static Generation, even if you're not using it (for consistency).





# basePath

To deploy a Next.js application under a sub-path of a domain you can use the
`basePath` config option.

`basePath` allows you to set a path prefix for the application. For example,
to use `/docs` instead of `''` (an empty string, the default), open
`next.config.js` and add the `basePath` config:

    
    
    module.exports = {
      basePath: '/docs',
    };

> **Note** : This value must be set at build time and cannot be changed
> without re-building as the value is inlined in the client-side bundles.

When linking to other pages using `next/link` and `next/router` the `basePath`
will be automatically applied.

For example, using `/about` will automatically become `/docs/about` when
`basePath` is set to `/docs`.

    
    
    export default function HomePage() {
      return (
        <>
          <Link href="/about">About Page</Link>
        </>
      );
    }

Output html:

    
    
    <a href="/docs/about">About Page</a>

This makes sure that you don't have to change all links in your application
when changing the `basePath` value.

When using the `next/image` component, you will need to add the `basePath` in
front of `src`.

For example, using `/docs/me.png` will properly serve your image when
`basePath` is set to `/docs`.

    
    
    import Image from 'next/image';
     
    function Home() {
      return (
        <>
          <h1>My Homepage</h1>
          <Image
            src="/docs/me.png"
            alt="Picture of the author"
            width={500}
            height={500}
          />
          <p>Welcome to my homepage!</p>
        </>
      );
    }
     
    export default Home;





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app



  
  
Using App Router

Features available in /app





Using App Router

Features available in /app





# exportPathMap (Deprecated)

> This feature is exclusive to `next export` and currently **deprecated** in
> favor of `getStaticPaths` with `pages` or `generateStaticParams` with `app`.

**Examples**

`exportPathMap` allows you to specify a mapping of request paths to page
destinations, to be used during export. Paths defined in `exportPathMap` will
also be available when using `next dev`.

Let's start with an example, to create a custom `exportPathMap` for an app
with the following pages:

  * `pages/index.js`
  * `pages/about.js`
  * `pages/post.js`

Open `next.config.js` and add the following `exportPathMap` config:

    
    
    module.exports = {
      exportPathMap: async function (
        defaultPathMap,
        { dev, dir, outDir, distDir, buildId },
      ) {
        return {
          '/': { page: '/' },
          '/about': { page: '/about' },
          '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },
          '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },
          '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },
        };
      },
    };

> **Note** : the `query` field in `exportPathMap` cannot be used with
> automatically statically optimized pages or `getStaticProps` pages as they
> are rendered to HTML files at build-time and additional query information
> cannot be provided during `next export`.

The pages will then be exported as HTML files, for example, `/about` will
become `/about.html`.

`exportPathMap` is an `async` function that receives 2 arguments: the first
one is `defaultPathMap`, which is the default map used by Next.js. The second
argument is an object with:

  * `dev` \- `true` when `exportPathMap` is being called in development. `false` when running `next export`. In development `exportPathMap` is used to define routes.
  * `dir` \- Absolute path to the project directory
  * `outDir` \- Absolute path to the `out/` directory (configurable with `-o`). When `dev` is `true` the value of `outDir` will be `null`.
  * `distDir` \- Absolute path to the `.next/` directory (configurable with the `distDir` config)
  * `buildId` \- The generated build id

The returned object is a map of pages where the `key` is the `pathname` and
the `value` is an object that accepts the following fields:

  * `page`: `String` \- the page inside the `pages` directory to render
  * `query`: `Object` \- the `query` object passed to `getInitialProps` when prerendering. Defaults to `{}`

> The exported `pathname` can also be a filename (for example, `/readme.md`),
> but you may need to set the `Content-Type` header to `text/html` when
> serving its content if it is different than `.html`.

It is possible to configure Next.js to export pages as `index.html` files and
require trailing slashes, `/about` becomes `/about/index.html` and is routable
via `/about/`. This was the default behavior prior to Next.js 9.

To switch back and add a trailing slash, open `next.config.js` and enable the
`trailingSlash` config:

    
    
    module.exports = {
      trailingSlash: true,
    };

`next export` will use `out` as the default output directory, you can
customize this using the `-o` argument, like so:

> **Warning** : Using `exportPathMap` is deprecated and is overridden by
> `getStaticPaths` inside `pages`. We don't recommend using them together.





Using App Router

Features available in /app





Using App Router

Features available in /app





# headers

Headers allow you to set custom HTTP headers on the response to an incoming
request on a given path.

To set custom HTTP headers you can use the `headers` key in `next.config.js`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/about',
            headers: [
              {
                key: 'x-custom-header',
                value: 'my custom header value',
              },
              {
                key: 'x-another-custom-header',
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

`headers` is an async function that expects an array to be returned holding
objects with `source` and `headers` properties:

  * `source` is the incoming request path pattern.
  * `headers` is an array of response header objects, with `key` and `value` properties.
  * `basePath`: `false` or `undefined` \- if false the basePath won't be included when matching, can be used for external rewrites only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

Headers are checked before the filesystem which includes pages and `/public`
files.

If two headers match the same path and set the same header key, the last
header key will override the first. Using the below headers, the path `/hello`
will result in the header `x-hello` being `world` due to the last header value
set being `world`.

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/:path*',
            headers: [
              {
                key: 'x-hello',
                value: 'there',
              },
            ],
          },
          {
            source: '/hello',
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
        ];
      },
    };

Path matches are allowed, for example `/blog/:slug` will match `/blog/hello-
world` (no nested paths):

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:slug',
            headers: [
              {
                key: 'x-slug',
                value: ':slug', // Matched parameters can be used in the value
              },
              {
                key: 'x-slug-:slug', // Matched parameters can be used in the key
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:slug*',
            headers: [
              {
                key: 'x-slug',
                value: ':slug*', // Matched parameters can be used in the value
              },
              {
                key: 'x-slug-:slug*', // Matched parameters can be used in the key
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parenthesis after a parameter,
for example `/blog/:slug(\\d{1,})` will match `/blog/123` but not `/blog/abc`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:post(\\d{1,})',
            headers: [
              {
                key: 'x-post',
                value: ':post',
              },
            ],
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async headers() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            headers: [
              {
                key: 'x-header',
                value: 'value',
              },
            ],
          },
        ];
      },
    };

To only apply a header when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
header to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async headers() {
        return [
          // if the header `x-add-header` is present,
          // the `x-another-header` header will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-add-header',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: 'hello',
              },
            ],
          },
          // if the header `x-no-header` is not present,
          // the `x-another-header` header will be applied
          {
            source: '/:path*',
            missing: [
              {
                type: 'header',
                key: 'x-no-header',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: 'hello',
              },
            ],
          },
          // if the source, query, and cookie are matched,
          // the `x-authorized` header will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // header key/values since value is provided and
                // doesn't use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            headers: [
              {
                key: 'x-authorized',
                value: ':authorized',
              },
            ],
          },
          // if the header `x-authorized` is present and
          // contains a matching value, the `x-another-header` will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: ':authorized',
              },
            ],
          },
          // if the host is `example.com`,
          // this header will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: ':authorized',
              },
            ],
          },
        ];
      },
    };

When leveraging `basePath` support with headers each `source` is automatically
prefixed with the `basePath` unless you add `basePath: false` to the header:

    
    
    module.exports = {
      basePath: '/docs',
     
      async headers() {
        return [
          {
            source: '/with-basePath', // becomes /docs/with-basePath
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            source: '/without-basePath', // is not modified since basePath: false is set
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
            basePath: false,
          },
        ];
      },
    };

When leveraging `i18n` support with headers each `source` is automatically
prefixed to handle the configured `locales` unless you add `locale: false` to
the header. If `locale: false` is used you must prefix the `source` with a
locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async headers() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            locale: false,
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            locale: false,
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
        ];
      },
    };

You can set the `Cache-Control` header in your Next.js API Routes by using the
`res.setHeader` method:

    
    
    export default function handler(req, res) {
      res.setHeader('Cache-Control', 's-maxage=86400');
      res.status(200).json({ name: 'John Doe' });
    }

You cannot set `Cache-Control` headers in `next.config.js` file as these will
be overwritten in production to ensure that API Routes and static assets are
cached effectively.

If you need to revalidate the cache of a page that has been statically
generated, you can do so by setting the `revalidate` prop in the page's
`getStaticProps` function.

This header controls DNS prefetching, allowing browsers to proactively perform
domain name resolution on external links, images, CSS, JavaScript, and more.
This prefetching is performed in the background, so the DNS is more likely to
be resolved by the time the referenced items are needed. This reduces latency
when the user clicks a link.

    
    
    {
      key: 'X-DNS-Prefetch-Control',
      value: 'on'
    }

This header informs browsers it should only be accessed using HTTPS, instead
of using HTTP. Using the configuration below, all present and future
subdomains will use HTTPS for a `max-age` of 2 years. This blocks access to
pages or subdomains that can only be served over HTTP.

If you're deploying to Vercel, this header is not necessary as it's
automatically added to all deployments unless you declare `headers` in your
`next.config.js`.

    
    
    {
      key: 'Strict-Transport-Security',
      value: 'max-age=63072000; includeSubDomains; preload'
    }

This header stops pages from loading when they detect reflected cross-site
scripting (XSS) attacks. Although this protection is not necessary when sites
implement a strong `Content-Security-Policy` disabling the use of inline
JavaScript (`'unsafe-inline'`), it can still provide protection for older web
browsers that don't support CSP.

    
    
    {
      key: 'X-XSS-Protection',
      value: '1; mode=block'
    }

This header indicates whether the site should be allowed to be displayed
within an `iframe`. This can prevent against clickjacking attacks. This header
has been superseded by CSP's `frame-ancestors` option, which has better
support in modern browsers.

    
    
    {
      key: 'X-Frame-Options',
      value: 'SAMEORIGIN'
    }

This header allows you to control which features and APIs can be used in the
browser. It was previously named `Feature-Policy`. You can view the full list
of permission options here.

    
    
    {
      key: 'Permissions-Policy',
      value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'
    }

This header prevents the browser from attempting to guess the type of content
if the `Content-Type` header is not explicitly set. This can prevent XSS
exploits for websites that allow users to upload and share files. For example,
a user trying to download an image, but having it treated as a different
`Content-Type` like an executable, which could be malicious. This header also
applies to downloading browser extensions. The only valid value for this
header is `nosniff`.

    
    
    {
      key: 'X-Content-Type-Options',
      value: 'nosniff'
    }

This header controls how much information the browser includes when navigating
from the current website (origin) to another. You can read about the different
options here.

    
    
    {
      key: 'Referrer-Policy',
      value: 'origin-when-cross-origin'
    }

This header helps prevent cross-site scripting (XSS), clickjacking and other
code injection attacks. Content Security Policy (CSP) can specify allowed
origins for content including scripts, stylesheets, images, fonts, objects,
media (audio, video), iframes, and more.

You can read about the many different CSP options here.

You can add Content Security Policy directives using a template string.

    
    
    // Before defining your Security Headers
    // add Content Security Policy directives using a template string.
     
    const ContentSecurityPolicy = `
      default-src 'self';
      script-src 'self';
      child-src example.com;
      style-src 'self' example.com;
      font-src 'self';
    `;

When a directive uses a keyword such as `self`, wrap it in single quotes `''`.

In the header's value, replace the new line with a space.

    
    
    {
      key: 'Content-Security-Policy',
      value: ContentSecurityPolicy.replace(/\s{2,}/g, ' ').trim()
    }

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| Headers added.





Using App Router

Features available in /app





# images

If you want to use a cloud provider to optimize images instead of using the
Next.js built-in Image Optimization API, you can configure `next.config.js`
with the following:

    
    
    module.exports = {
      images: {
        loader: 'custom',
        loaderFile: './my/image/loader.js',
      },
    };

This `loaderFile` must point to a file relative to the root of your Next.js
application. The file must export a default function that returns a string,
for example:

    
    
    export default function myImageLoader({ src, width, quality }) {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    }

Alternatively, you can use the `loader` prop to pass the function to each
instance of `next/image`.

    
    
    // Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand
    export default function akamaiLoader({ src, width, quality }) {
      return `https://example.com/${src}?imwidth=${width}`;
    }
    
    
    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg
    export default function cloudinaryLoader({ src, width, quality }) {
      const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
      return `https://example.com/${params.join(',')}${src}`;
    }
    
    
    // Docs: https://developers.cloudflare.com/images/url-format
    export default function cloudflareLoader({ src, width, quality }) {
      const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto'];
      return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`;
    }
    
    
    // Docs: https://www.contentful.com/developers/docs/references/images-api/
    export default function contentfulLoader({ src, quality, width }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('fm', 'webp');
      url.searchParams.set('w', width.toString());
      url.searchParams.set('q', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://developer.fastly.com/reference/io/
    export default function fastlyLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('auto', 'webp');
      url.searchParams.set('width', width.toString());
      url.searchParams.set('quality', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://docs.gumlet.com/reference/image-transform-size
    export default function gumletLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('format', 'auto');
      url.searchParams.set('w', width.toString());
      url.searchParams.set('q', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives
    export default function imageengineLoader({ src, width, quality }) {
      const compression = 100 - (quality || 50)
      const params = [`w_${width}`, `cmpr_${compression}`)]
      return `https://example.com${src}?imgeng=/${params.join('/')`
    }
    
    
    // Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300
    export default function imgixLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      const params = url.searchParams;
      params.set('auto', params.getAll('auto').join(',') || 'format');
      params.set('fit', params.get('fit') || 'max');
      params.set('w', params.get('w') || width.toString());
      params.set('q', quality.toString() || '50');
      return url.href;
    }
    
    
    // Docs: https://thumbor.readthedocs.io/en/latest/
    export default function thumborLoader({ src, width, quality }) {
      const params = [`${width}x0`, `filters:quality(${quality || 75})`];
      return `https://example.com${params.join('/')}${src}`;
    }





Using App Router

Features available in /app





Using App Router

Features available in /app



  
  
# output

During a build, Next.js will automatically trace each page and its
dependencies to determine all of the files that are needed for deploying a
production version of your application.

This feature helps reduce the size of deployments drastically. Previously,
when deploying with Docker you would need to have all files from your
package's `dependencies` installed to run `next start`. Starting with Next.js
12, you can leverage Output File Tracing in the `.next/` directory to only
include the necessary files.

Furthermore, this removes the need for the deprecated `serverless` target
which can cause various issues and also creates unnecessary duplication.

During `next build`, Next.js will use `@vercel/nft` to statically analyze
`import`, `require`, and `fs` usage to determine all files that a page might
load.

Next.js' production server is also traced for its needed files and output at
`.next/next-server.js.nft.json` which can be leveraged in production.

To leverage the `.nft.json` files emitted to the `.next` output directory, you
can read the list of files in each trace that are relative to the `.nft.json`
file and then copy them to your deployment location.

Next.js can automatically create a `standalone` folder that copies only the
necessary files for a production deployment including select files in
`node_modules`.

To leverage this automatic copying you can enable it in your `next.config.js`:

    
    
    module.exports = {
      output: 'standalone',
    };

This will create a folder at `.next/standalone` which can then be deployed on
its own without installing `node_modules`.

Additionally, a minimal `server.js` file is also output which can be used
instead of `next start`. This minimal server does not copy the `public` or
`.next/static` folders by default as these should ideally be handled by a CDN
instead, although these folders can be copied to the `standalone/public` and
`standalone/.next/static` folders manually, after which `server.js` file will
serve these automatically.

> **Note** : `next.config.js` is read during `next build` and serialized into
> the `server.js` output file. If the legacy `serverRuntimeConfig` or
> `publicRuntimeConfig` options are being used, the values will be specific to
> values at build time.

> **Note** : If your project uses Image Optimization with the default
> `loader`, you must install `sharp` as a dependency:

  * While tracing in monorepo setups, the project directory is used for tracing by default. For `next build packages/web-app`, `packages/web-app` would be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can set `experimental.outputFileTracingRoot` in your `next.config.js`.

    
    
    module.exports = {
      experimental: {
        // this includes files from the monorepo base two directories up
        outputFileTracingRoot: path.join(__dirname, '../../'),
      },
    };

  * There are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverage `experimental.outputFileTracingExcludes` and `experimental.outputFileTracingIncludes` respectively in `next.config.js`. Each config accepts an object with minimatch globs for the key to match specific pages and a value of an array with globs relative to the project's root to either include or exclude in the trace.

    
    
    module.exports = {
      experimental: {
        outputFileTracingExcludes: {
          '/api/hello': ['./un-necessary-folder/**/*'],
        },
        outputFileTracingIncludes: {
          '/api/another': ['./necessary-folder/**/*'],
        },
      },
    };

  * Currently, Next.js does not do anything with the emitted `.nft.json` files. The files must be read by your deployment platform, for example Vercel, to create a minimal deployment. In a future release, a new command is planned to utilize these `.nft.json` files.

Tracing dependencies can be slow because it requires very complex computations
and analysis. We created `turbotrace` in Rust as a faster and smarter
alternative to the JavaScript implementation.

To enable it, you can add the following configuration to your
`next.config.js`:

    
    
    module.exports = {
      experimental: {
        turbotrace: {
          // control the log level of the turbotrace, default is `error`
          logLevel?:
          | 'bug'
          | 'fatal'
          | 'error'
          | 'warning'
          | 'hint'
          | 'note'
          | 'suggestions'
          | 'info',
          // control if the log of turbotrace should contain the details of the analysis, default is `false`
          logDetail?: boolean
          // show all log messages without limit
          // turbotrace only show 1 log message for each categories by default
          logAll?: boolean
          // control the context directory of the turbotrace
          // files outside of the context directory will not be traced
          // set the `experimental.outputFileTracingRoot` has the same effect
          // if the `experimental.outputFileTracingRoot` and this option are both set, the `experimental.turbotrace.contextDirectory` will be used
          contextDirectory?: string
          // if there is `process.cwd()` expression in your code, you can set this option to tell `turbotrace` the value of `process.cwd()` while tracing.
          // for example the require(process.cwd() + '/package.json') will be traced as require('/path/to/cwd/package.json')
          processCwd?: string
          // control the maximum memory usage of the `turbotrace`, in `MB`, default is `6000`.
          memoryLimit?: number
        },
      },
    }





# pageExtensions

By default, Next.js accepts files with the following extensions: `.tsx`,
`.ts`, `.jsx`, `.js`. This can be modified to allow other extensions like
markdown (`.md`, `.mdx`).

    
    
    const withMDX = require('@next/mdx')();
     
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      pageExtensions: ['ts', 'tsx', 'mdx'],
      experimental: {
        mdxRs: true,
      },
    };
     
    module.exports = withMDX(nextConfig);

For custom advanced configuration of Next.js, you can create a
`next.config.js` or `next.config.mjs` file in the root of your project
directory (next to `package.json`).

`next.config.js` is a regular Node.js module, not a JSON file. It gets used by
the Next.js server and build phases, and it's not included in the browser
build.

Take a look at the following `next.config.js` example:

    
    
    /**
     * @type {import('next').NextConfig}
     */
    const nextConfig = {
      /* config options here */
    };
     
    module.exports = nextConfig;

If you need ECMAScript modules, you can use `next.config.mjs`:

    
    
    /**
     * @type {import('next').NextConfig}
     */
    const nextConfig = {
      /* config options here */
    };
     
    export default nextConfig;

You can also use a function:

    
    
    module.exports = (phase, { defaultConfig }) => {
      /**
       * @type {import('next').NextConfig}
       */
      const nextConfig = {
        /* config options here */
      };
      return nextConfig;
    };

Since Next.js 12.1.0, you can use an async function:

    
    
    module.exports = async (phase, { defaultConfig }) => {
      /**
       * @type {import('next').NextConfig}
       */
      const nextConfig = {
        /* config options here */
      };
      return nextConfig;
    };

`phase` is the current context in which the configuration is loaded. You can
see the available phases. Phases can be imported from `next/constants`:

    
    
    const { PHASE_DEVELOPMENT_SERVER } = require('next/constants');
     
    module.exports = (phase, { defaultConfig }) => {
      if (phase === PHASE_DEVELOPMENT_SERVER) {
        return {
          /* development only config options here */
        };
      }
     
      return {
        /* config options for all phases except development here */
      };
    };

The commented lines are the place where you can put the configs allowed by
`next.config.js`, which are defined in this file.

However, none of the configs are required, and it's not necessary to
understand what each config does. Instead, search for the features you need to
enable or modify in this section and they will show you what to do.

> Avoid using new JavaScript features not available in your target Node.js
> version. `next.config.js` will not be parsed by Webpack, Babel or
> TypeScript.





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# redirects

Redirects allow you to redirect an incoming request path to a different
destination path.

To use redirects you can use the `redirects` key in `next.config.js`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/about',
            destination: '/',
            permanent: true,
          },
        ];
      },
    };

`redirects` is an async function that expects an array to be returned holding
objects with `source`, `destination`, and `permanent` properties:

  * `source` is the incoming request path pattern.
  * `destination` is the path you want to route to.
  * `permanent` `true` or `false` \- if `true` will use the 308 status code which instructs clients/search engines to cache the redirect forever, if `false` will use the 307 status code which is temporary and is not cached.

> **Why does Next.js use 307 and 308?** Traditionally a 302 was used for a
> temporary redirect, and a 301 for a permanent redirect, but many browsers
> changed the request method of the redirect to `GET`, regardless of the
> original method. For example, if the browser made a request to `POST
> /v1/users` which returned status code `302` with location `/v2/users`, the
> subsequent request might be `GET /v2/users` instead of the expected `POST
> /v2/users`. Next.js uses the 307 temporary redirect, and 308 permanent
> redirect status codes to explicitly preserve the request method used.

  * `basePath`: `false` or `undefined` \- if false the `basePath` won't be included when matching, can be used for external redirects only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

Redirects are checked before the filesystem which includes pages and `/public`
files.

Redirects are not applied to client-side routing (`Link`, `router.push`),
unless Middleware is present and matches the path.

When a redirect is applied, any query values provided in the request will be
passed through to the redirect destination. For example, see the following
redirect configuration:

    
    
    {
      source: '/old-blog/:path*',
      destination: '/blog/:path*',
      permanent: false
    }

When `/old-blog/post-1?hello=world` is requested, the client will be
redirected to `/blog/post-1?hello=world`.

Path matches are allowed, for example `/old-blog/:slug` will match `/old-
blog/hello-world` (no nested paths):

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/old-blog/:slug',
            destination: '/news/:slug', // Matched parameters can be used in the destination
            permanent: true,
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/blog/:slug*',
            destination: '/news/:slug*', // Matched parameters can be used in the destination
            permanent: true,
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parentheses after a parameter,
for example `/post/:slug(\\d{1,})` will match `/post/123` but not `/post/abc`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/post/:slug(\\d{1,})',
            destination: '/news/:slug', // Matched parameters can be used in the destination
            permanent: false,
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            destination: '/en-us/:slug',
            permanent: false,
          },
        ];
      },
    };

To only match a redirect when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
redirect to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async redirects() {
        return [
          // if the header `x-redirect-me` is present,
          // this redirect will be applied
          {
            source: '/:path((?!another-page$).*)',
            has: [
              {
                type: 'header',
                key: 'x-redirect-me',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
          // if the header `x-dont-redirect` is present,
          // this redirect will NOT be applied
          {
            source: '/:path((?!another-page$).*)',
            missing: [
              {
                type: 'header',
                key: 'x-do-not-redirect',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
          // if the source, query, and cookie are matched,
          // this redirect will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // destination since value is provided and doesn't
                // use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            permanent: false,
            destination: '/another/:path*',
          },
          // if the header `x-authorized` is present and
          // contains a matching value, this redirect will be applied
          {
            source: '/',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            permanent: false,
            destination: '/home?authorized=:authorized',
          },
          // if the host is `example.com`,
          // this redirect will be applied
          {
            source: '/:path((?!another-page$).*)',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
        ];
      },
    };

When leveraging `basePath` support with redirects each `source` and
`destination` is automatically prefixed with the `basePath` unless you add
`basePath: false` to the redirect:

    
    
    module.exports = {
      basePath: '/docs',
     
      async redirects() {
        return [
          {
            source: '/with-basePath', // automatically becomes /docs/with-basePath
            destination: '/another', // automatically becomes /docs/another
            permanent: false,
          },
          {
            // does not add /docs since basePath: false is set
            source: '/without-basePath',
            destination: 'https://example.com',
            basePath: false,
            permanent: false,
          },
        ];
      },
    };

When leveraging `i18n` support with redirects each `source` and `destination`
is automatically prefixed to handle the configured `locales` unless you add
`locale: false` to the redirect. If `locale: false` is used you must prefix
the `source` and `destination` with a locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async redirects() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            destination: '/another', // automatically passes the locale on
            permanent: false,
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            destination: '/nl/another',
            locale: false,
            permanent: false,
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            destination: '/en/another',
            locale: false,
            permanent: false,
          },
          // it's possible to match all locales even when locale: false is set
          {
            source: '/:locale/page',
            destination: '/en/newpage',
            permanent: false,
            locale: false,
          }
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            destination: '/another',
            permanent: false,
          },
        ]
      },
    }

In some rare cases, you might need to assign a custom status code for older
HTTP Clients to properly redirect. In these cases, you can use the
`statusCode` property instead of the `permanent` property, but not both. To to
ensure IE11 compatibility, a `Refresh` header is automatically added for the
308 status code.

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| `redirects` added.





# rewrites

Rewrites allow you to map an incoming request path to a different destination
path.

Rewrites act as a URL proxy and mask the destination path, making it appear
the user hasn't changed their location on the site. In contrast, redirects
will reroute to a new page and show the URL changes.

To use rewrites you can use the `rewrites` key in `next.config.js`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/about',
            destination: '/',
          },
        ];
      },
    };

Rewrites are applied to client-side routing, a `<Link href="/about">` will
have the rewrite applied in the above example.

`rewrites` is an async function that expects to return either an array or an
object of arrays (see below) holding objects with `source` and `destination`
properties:

  * `source`: `String` \- is the incoming request path pattern.
  * `destination`: `String` is the path you want to route to.
  * `basePath`: `false` or `undefined` \- if false the basePath won't be included when matching, can be used for external rewrites only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

When the `rewrites` function returns an array, rewrites are applied after
checking the filesystem (pages and `/public` files) and before dynamic routes.
When the `rewrites` function returns an object of arrays with a specific
shape, this behavior can be changed and more finely controlled, as of `v10.1`
of Next.js:

    
    
    module.exports = {
      async rewrites() {
        return {
          beforeFiles: [
            // These rewrites are checked after headers/redirects
            // and before all files including _next/public files which
            // allows overriding page files
            {
              source: '/some-page',
              destination: '/somewhere-else',
              has: [{ type: 'query', key: 'overrideMe' }],
            },
          ],
          afterFiles: [
            // These rewrites are checked after pages/public files
            // are checked but before dynamic routes
            {
              source: '/non-existent',
              destination: '/somewhere-else',
            },
          ],
          fallback: [
            // These rewrites are checked after both pages/public files
            // and dynamic routes are checked
            {
              source: '/:path*',
              destination: `https://my-old-site.com/:path*`,
            },
          ],
        };
      },
    };

> **Note** : rewrites in `beforeFiles` do not check the filesystem/dynamic
> routes immediately after matching a source, they continue until all
> `beforeFiles` have been checked.

The order Next.js routes are checked is:

  1. headers are checked/applied
  2. redirects are checked/applied
  3. `beforeFiles` rewrites are checked/applied
  4. static files from the public directory, `_next/static` files, and non-dynamic pages are checked/served
  5. `afterFiles` rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match
  6. `fallback` rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in `getStaticPaths`, the fallback `rewrites` defined in your `next.config.js` will _not_ be run.

When using parameters in a rewrite the parameters will be passed in the query
by default when none of the parameters are used in the `destination`.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/old-about/:path*',
            destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query
          },
        ];
      },
    };

If a parameter is used in the destination none of the parameters will be
automatically passed in the query.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/docs/:path*',
            destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query
          },
        ];
      },
    };

You can still pass the parameters manually in the query if one is already used
in the destination by specifying the query in the `destination`.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/:first/:second',
            destination: '/:first?second=:second',
            // Since the :first parameter is used in the destination the :second parameter
            // will not automatically be added in the query although we can manually add it
            // as shown above
          },
        ];
      },
    };

> **Note** : Static pages from Automatic Static Optimization or prerendering
> params from rewrites will be parsed on the client after hydration and
> provided in the query.

Path matches are allowed, for example `/blog/:slug` will match `/blog/hello-
world` (no nested paths):

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog/:slug',
            destination: '/news/:slug', // Matched parameters can be used in the destination
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog/:slug*',
            destination: '/news/:slug*', // Matched parameters can be used in the destination
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parenthesis after a parameter,
for example `/blog/:slug(\\d{1,})` will match `/blog/123` but not `/blog/abc`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/old-blog/:post(\\d{1,})',
            destination: '/blog/:post', // Matched parameters can be used in the destination
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            destination: '/en-us/:slug',
          },
        ];
      },
    };

To only match a rewrite when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
rewrite to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async rewrites() {
        return [
          // if the header `x-rewrite-me` is present,
          // this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-rewrite-me',
              },
            ],
            destination: '/another-page',
          },
          // if the header `x-rewrite-me` is not present,
          // this rewrite will be applied
          {
            source: '/:path*',
            missing: [
              {
                type: 'header',
                key: 'x-rewrite-me',
              },
            ],
            destination: '/another-page',
          },
          // if the source, query, and cookie are matched,
          // this rewrite will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // destination since value is provided and doesn't
                // use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            destination: '/:path*/home',
          },
          // if the header `x-authorized` is present and
          // contains a matching value, this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            destination: '/home?authorized=:authorized',
          },
          // if the host is `example.com`,
          // this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            destination: '/another-page',
          },
        ];
      },
    };

**Examples**

Rewrites allow you to rewrite to an external url. This is especially useful
for incrementally adopting Next.js. The following is an example rewrite for
redirecting the `/blog` route of your main app to an external site.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog',
            destination: 'https://example.com/blog',
          },
          {
            source: '/blog/:slug',
            destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination
          },
        ];
      },
    };

If you're using `trailingSlash: true`, you also need to insert a trailing
slash in the `source` parameter. If the destination server is also expecting a
trailing slash it should be included in the `destination` parameter as well.

    
    
    module.exports = {
      trailingSlash: true,
      async rewrites() {
        return [
          {
            source: '/blog/',
            destination: 'https://example.com/blog/',
          },
          {
            source: '/blog/:path*/',
            destination: 'https://example.com/blog/:path*/',
          },
        ];
      },
    };

You can also have Next.js fall back to proxying to an existing website after
checking all Next.js routes.

This way you don't have to change the rewrites configuration when migrating
more pages to Next.js

    
    
    module.exports = {
      async rewrites() {
        return {
          fallback: [
            {
              source: '/:path*',
              destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,
            },
          ],
        };
      },
    };

When leveraging `basePath` support with rewrites each `source` and
`destination` is automatically prefixed with the `basePath` unless you add
`basePath: false` to the rewrite:

    
    
    module.exports = {
      basePath: '/docs',
     
      async rewrites() {
        return [
          {
            source: '/with-basePath', // automatically becomes /docs/with-basePath
            destination: '/another', // automatically becomes /docs/another
          },
          {
            // does not add /docs to /without-basePath since basePath: false is set
            // Note: this can not be used for internal rewrites e.g. `destination: '/another'`
            source: '/without-basePath',
            destination: 'https://example.com',
            basePath: false,
          },
        ];
      },
    };

When leveraging `i18n` support with rewrites each `source` and `destination`
is automatically prefixed to handle the configured `locales` unless you add
`locale: false` to the rewrite. If `locale: false` is used you must prefix the
`source` and `destination` with a locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async rewrites() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            destination: '/another', // automatically passes the locale on
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            destination: '/nl/another',
            locale: false,
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            destination: '/en/another',
            locale: false,
          },
          {
            // it's possible to match all locales even when locale: false is set
            source: '/:locale/api-alias/:path*',
            destination: '/api/:path*',
            locale: false,
          },
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            destination: '/another',
          },
        ];
      },
    };

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| Headers added.



  
  
Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





Using App Router

Features available in /app





# turbo (Experimental)

> **Warning** : These features are experimental and will only work with `next
> --turbo`.

Currently, Turbopack supports a subset of webpack's loader API, allowing you
to use some webpack loaders to transform code in Turbopack.

To configure loaders, add the names of the loaders you've installed and any
options in `next.config.js`, mapping file extensions to a list of loaders:

    
    
    module.exports = {
      experimental: {
        turbo: {
          loaders: {
            // Option format
            '.md': [
              {
                loader: '@mdx-js/loader',
                options: {
                  format: 'md',
                },
              },
            ],
            // Option-less format
            '.mdx': ['@mdx-js/loader'],
          },
        },
      },
    };

Then, given the above configuration, you can use transformed code from your
app:

    
    
    import MyDoc from './my-doc.mdx';
     
    export default function Home() {
      return <MyDoc />;
    }

Through `next.config.js`, Turbopack can be configured to modify module
resolution through aliases, similar to webpack's `resolve.alias`
configuration.

To configure resolve aliases, map imported patterns to their new destination
in `next.config.js`:

    
    
    module.exports = {
      experimental: {
        turbo: {
          resolveAlias: {
            underscore: 'lodash',
            mocha: { browser: 'mocha/browser-entry.js' },
          },
        },
      },
    };

This aliases imports of the `underscore` package to the `lodash` package. In
other words, `import underscore from 'underscore'` will load the `lodash`
module instead of `underscore`.

Turbopack also supports conditional aliasing through this field, similar to
Node.js's conditional exports. At the moment only the `browser` condition is
supported. In the case above, imports of the `mocha` module will be aliased to
`mocha/browser-entry.js` when Turbopack targets browser environments.

For more information and guidance for how to migrate your app to Turbopack
from webpack, see Turbopack's documentation on webpack compatibility.





Using App Router

Features available in /app





Using App Router

Features available in /app





# urlImports

URL imports are an experimental feature that allows you to import modules
directly from external servers (instead of from the local disk).

> **Warning** : This feature is experimental. Only use domains that you trust
> to download and execute on your machine. Please exercise discretion, and
> caution until the feature is flagged as stable.

To opt-in, add the allowed URL prefixes inside `next.config.js`:

    
    
    module.exports = {
      experimental: {
        urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],
      },
    };

Then, you can import modules directly from URLs:

    
    
    import { a, b, c } from 'https://example.com/assets/some/module.js';

URL Imports can be used everywhere normal package imports can be used.

This feature is being designed with **security as the top priority**. To
start, we added an experimental flag forcing you to explicitly allow the
domains you accept URL imports from. We're working to take this further by
limiting URL imports to execute in the browser sandbox using the Edge Runtime.

When using URL imports, Next.js will create a `next.lock` directory containing
a lockfile and fetched assets. This directory **must be committed to Git** ,
not ignored by `.gitignore`.

  * When running `next dev`, Next.js will download and add all newly discovered URL Imports to your lockfile
  * When running `next build`, Next.js will use only the lockfile to build the application for production

Typically, no network requests are needed and any outdated lockfile will cause
the build to fail. One exception is resources that respond with `Cache-
Control: no-cache`. These resources will have a `no-cache` entry in the
lockfile and will always be fetched from the network on each build.

    
    
    import confetti from 'https://cdn.skypack.dev/canvas-confetti';
    import { useEffect } from 'react';
     
    export default () => {
      useEffect(() => {
        confetti();
      });
      return <p>Hello</p>;
    };
    
    
    import Image from 'next/image';
    import logo from 'https://example.com/assets/logo.png';
     
    export default () => (
      <div>
        <Image src={logo} placeholder="blur" />
      </div>
    );
    
    
    .className {
      background: url('https://example.com/assets/hero.jpg');
    }
    
    
    const logo = new URL('https://example.com/assets/file.txt', import.meta.url);
     
    console.log(logo.pathname);
     
    // prints "/_next/static/media/file.a9727b5d.txt"





# Custom Webpack Config

> **Note** : changes to webpack config are not covered by semver so proceed at
> your own risk

Before continuing to add custom webpack configuration to your application make
sure Next.js doesn't already support your use-case:

Some commonly asked for features are available as plugins:

In order to extend our usage of `webpack`, you can define a function that
extends its config inside `next.config.js`, like so:

    
    
    module.exports = {
      webpack: (
        config,
        { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack },
      ) => {
        // Important: return the modified config
        return config;
      },
    };

> The `webpack` function is executed twice, once for the server and once for
> the client. This allows you to distinguish between client and server
> configuration using the `isServer` property.

The second argument to the `webpack` function is an object with the following
properties:

  * `buildId`: `String` \- The build id, used as a unique identifier between builds
  * `dev`: `Boolean` \- Indicates if the compilation will be done in development
  * `isServer`: `Boolean` \- It's `true` for server-side compilation, and `false` for client-side compilation
  * `nextRuntime`: `String | undefined` \- The target runtime for server-side compilation; either `"edge"` or `"nodejs"`, it's `undefined` for client-side compilation.
  * `defaultLoaders`: `Object` \- Default loaders used internally by Next.js: 
    * `babel`: `Object` \- Default `babel-loader` configuration

Example usage of `defaultLoaders.babel`:

    
    
    // Example config for adding a loader that depends on babel-loader
    // This source was taken from the @next/mdx plugin source:
    // https://github.com/vercel/next.js/tree/canary/packages/next-mdx
    module.exports = {
      webpack: (config, options) => {
        config.module.rules.push({
          test: /\.mdx/,
          use: [
            options.defaultLoaders.babel,
            {
              loader: '@mdx-js/loader',
              options: pluginOptions.options,
            },
          ],
        });
     
        return config;
      },
    };

Notice that `isServer` is `true` when `nextRuntime` is `"edge"` or `"nodejs"`,
nextRuntime "`edge`" is currently for middleware and Server Components in edge
runtime only.





Using App Router

Features available in /app





# create-next-app

The easiest way to get started with Next.js is by using `create-next-app`.
This CLI tool enables you to quickly start building a new Next.js application,
with everything set up for you. You can create a new app using the default
Next.js template, or by using one of the official Next.js examples. To get
started, use the following command:

You can create a new project interactively by running:

    
    
    npx create-next-app@latest
     
    yarn create next-app
     
    pnpm create next-app

You will then be asked the following prompts:

    
    
    What is your project named?  my-app
    Would you like to add TypeScript with this project?  Y/N
    Would you like to use ESLint with this project?  Y/N
    Would you like to use Tailwind CSS with this project? Y/N
    Would you like to use the `src/ directory` with this project? Y/N
    What import alias would you like configured? `@/*`

Once you've answered the prompts, a new project will be created with the
correct configuration depending on your answers.

You can also pass command line arguments to set up a new project non-
interactively.

Further, you can negate default options by prefixing them with `--no-` (e.g.
`--no-eslint`).

See `create-next-app --help`:

    
    
    Usage: create-next-app <project-directory> [options]
     
    Options:
      -V, --version                        output the version number
      --ts, --typescript
     
        Initialize as a TypeScript project. (default)
     
      --js, --javascript
     
        Initialize as a JavaScript project.
     
      --tailwind
     
        Initialize with Tailwind CSS config. (default)
     
      --eslint
     
        Initialize with ESLint config.
     
      --src-dir
     
        Initialize inside a `src/` directory.
     
      --import-alias <alias-to-configure>
     
        Specify import alias to use (default "@/*").
     
      --use-npm
     
        Explicitly tell the CLI to bootstrap the app using npm
     
      --use-pnpm
     
        Explicitly tell the CLI to bootstrap the app using pnpm
     
      -e, --example [name]|[github-url]
     
        An example to bootstrap the app with. You can use an example name
        from the official Next.js repo or a GitHub URL. The URL can use
        any branch and/or subdirectory
     
      --example-path <path-to-example>
     
        In a rare case, your GitHub URL might contain a branch name with
        a slash (e.g. bug/fix-1) and the path to the example (e.g. foo/bar).
        In this case, you must specify the path to the example separately:
        --example-path foo/bar
     
      --reset-preferences
     
        Explicitly tell the CLI to reset any stored preferences
     
      -h, --help                           output usage information

`create-next-app` allows you to create a new Next.js app within seconds. It is
officially maintained by the creators of Next.js, and includes a number of
benefits:

  * **Interactive Experience** : Running `npx create-next-app@latest` (with no arguments) launches an interactive experience that guides you through setting up a project.
  * **Zero Dependencies** : Initializing a project is as quick as one second. Create Next App has zero dependencies.
  * **Offline Support** : Create Next App will automatically detect if you're offline and bootstrap your project using your local package cache.
  * **Support for Examples** : Create Next App can bootstrap your application using an example from the Next.js examples collection (e.g. `npx create-next-app --example api-routes`).
  * **Tested** : The package is part of the Next.js monorepo and tested using the same integration test suite as Next.js itself, ensuring it works as expected with every release.





`AbortController`| Allows you to abort one or more DOM requests as and when
desired  
`DOMException`| Represents an error that occurs in the DOM  
`structuredClone`| Creates a deep copy of a value  
`URLPattern`| Represents a URL pattern  
`Array`| Represents an array of values  
`ArrayBuffer`| Represents a generic, fixed-length raw binary data buffer  
`Atomics`| Provides atomic operations as static methods  
`BigInt`| Represents a whole number with arbitrary precision  
`BigInt64Array`| Represents a typed array of 64-bit signed integers  
`BigUint64Array`| Represents a typed array of 64-bit unsigned integers  
`Boolean`| Represents a logical entity and can have two values: `true` and
`false`  
`clearInterval`| Cancels a timed, repeating action which was previously
established by a call to `setInterval()`  
`clearTimeout`| Cancels a timed, repeating action which was previously
established by a call to `setTimeout()`  
`console`| Provides access to the browser's debugging console  
`DataView`| Represents a generic view of an `ArrayBuffer`  
`Date`| Represents a single moment in time in a platform-independent format  
`decodeURI`| Decodes a Uniform Resource Identifier (URI) previously created by
`encodeURI` or by a similar routine  
`decodeURIComponent`| Decodes a Uniform Resource Identifier (URI) component
previously created by `encodeURIComponent` or by a similar routine  
`encodeURI`| Encodes a Uniform Resource Identifier (URI) by replacing each
instance of certain characters by one, two, three, or four escape sequences
representing the UTF-8 encoding of the character  
`encodeURIComponent`| Encodes a Uniform Resource Identifier (URI) component by
replacing each instance of certain characters by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character  
`Error`| Represents an error when trying to execute a statement or accessing a
property  
`EvalError`| Represents an error that occurs regarding the global function
`eval()`  
`Float32Array`| Represents a typed array of 32-bit floating point numbers  
`Float64Array`| Represents a typed array of 64-bit floating point numbers  
`Function`| Represents a function  
`Infinity`| Represents the mathematical Infinity value  
`Int8Array`| Represents a typed array of 8-bit signed integers  
`Int16Array`| Represents a typed array of 16-bit signed integers  
`Int32Array`| Represents a typed array of 32-bit signed integers  
`Intl`| Provides access to internationalization and localization functionality  
`isFinite`| Determines whether a value is a finite number  
`isNaN`| Determines whether a value is `NaN` or not  
`JSON`| Provides functionality to convert JavaScript values to and from the
JSON format  
`Map`| Represents a collection of values, where each value may occur only once  
`Math`| Provides access to mathematical functions and constants  
`Number`| Represents a numeric value  
`Object`| Represents the object that is the base of all JavaScript objects  
`parseFloat`| Parses a string argument and returns a floating point number  
`parseInt`| Parses a string argument and returns an integer of the specified
radix  
`Promise`| Represents the eventual completion (or failure) of an asynchronous
operation, and its resulting value  
`Proxy`| Represents an object that is used to define custom behavior for
fundamental operations (e.g. property lookup, assignment, enumeration,
function invocation, etc)  
`RangeError`| Represents an error when a value is not in the set or range of
allowed values  
`ReferenceError`| Represents an error when a non-existent variable is
referenced  
`Reflect`| Provides methods for interceptable JavaScript operations  
`RegExp`| Represents a regular expression, allowing you to match combinations
of characters  
`Set`| Represents a collection of values, where each value may occur only once  
`setInterval`| Repeatedly calls a function, with a fixed time delay between
each call  
`setTimeout`| Calls a function or evaluates an expression after a specified
number of milliseconds  
`SharedArrayBuffer`| Represents a generic, fixed-length raw binary data buffer  
`String`| Represents a sequence of characters  
`Symbol`| Represents a unique and immutable data type that is used as the key
of an object property  
`SyntaxError`| Represents an error when trying to interpret syntactically
invalid code  
`TypeError`| Represents an error when a value is not of the expected type  
`Uint8Array`| Represents a typed array of 8-bit unsigned integers  
`Uint8ClampedArray`| Represents a typed array of 8-bit unsigned integers
clamped to 0-255  
`Uint32Array`| Represents a typed array of 32-bit unsigned integers  
`URIError`| Represents an error when a global URI handling function was used
in a wrong way  
`URL`| Represents an object providing static methods used for creating object
URLs  
`URLSearchParams`| Represents a collection of key/value pairs  
`WeakMap`| Represents a collection of key/value pairs in which the keys are
weakly referenced  
`WeakSet`| Represents a collection of objects in which each object may occur
only once  
`WebAssembly`| Provides access to WebAssembly





# Next.js CLI

The Next.js CLI allows you to start, build, and export your application.

To get a list of the available CLI commands, run the following command inside
your project directory:

_(npx comes with npm 5.2+ and higher)_

The output should look like this:

    
    
    Usage
      $ next <command>
     
    Available commands
      build, start, export, dev, lint, telemetry, info
     
    Options
      --version, -v   Version number
      --help, -h      Displays this message
     
    For more information run a command with the --help flag
      $ next build --help

You can pass any node arguments to `next` commands:

    
    
    NODE_OPTIONS='--throw-deprecation' next
    NODE_OPTIONS='-r esm' next
    NODE_OPTIONS='--inspect' next

> **Note** : Running `next` without a command is the same as running `next
> dev`

`next build` creates an optimized production build of your application. The
output displays information about each route.

  * **Size** – The number of assets downloaded when navigating to the page client-side. The size for each route only includes its dependencies.
  * **First Load JS** – The number of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown as a separate metric.

Both of these values are **compressed with gzip**. The first load is indicated
by green, yellow, or red. Aim for green for performant applications.

You can enable production profiling for React with the `--profile` flag in
`next build`. This requires Next.js 9.5:

After that, you can use the profiler in the same way as you would in
development.

You can enable more verbose build output with the `--debug` flag in `next
build`. This requires Next.js 9.5.3:

With this flag enabled additional build output like rewrites, redirects, and
headers will be shown.

`next dev` starts the application in development mode with hot-code reloading,
error reporting, and more:

The application will start at `http://localhost:3000` by default. The default
port can be changed with `-p`, like so:

Or using the `PORT` environment variable:

> **Note** : `PORT` cannot be set in `.env` as booting up the HTTP server
> happens before any other code is initialized.

You can also set the hostname to be different from the default of `0.0.0.0`,
this can be useful for making the application available for other devices on
the network. The default hostname can be changed with `-H`, like so:

    
    
    npx next dev -H 192.168.1.2

`next start` starts the application in production mode. The application should
be compiled with `next build` first.

The application will start at `http://localhost:3000` by default. The default
port can be changed with `-p`, like so:

Or using the `PORT` environment variable:

> **Note** : `PORT` cannot be set in `.env` as booting up the HTTP server
> happens before any other code is initialized.

> **Note** : `next start` cannot be used with `output: 'standalone'` or
> `output: 'export'`.

When deploying Next.js behind a downstream proxy (e.g. a load-balancer like
AWS ELB/ALB) it's important to configure Next's underlying HTTP server with
keep-alive timeouts that are _larger_ than the downstream proxy's timeouts.
Otherwise, once a keep-alive timeout is reached for a given TCP connection,
Node.js will immediately terminate that connection without notifying the
downstream proxy. This results in a proxy error whenever it attempts to reuse
a connection that Node.js has already terminated.

To configure the timeout values for the production Next.js server, pass
`--keepAliveTimeout` (in milliseconds) to `next start`, like so:

    
    
    npx next start --keepAliveTimeout 70000

`next lint` runs ESLint for all files in the `pages/`, `app` (only if the
experimental `appDir` feature is enabled), `components/`, `lib/`, and `src/`
directories. It also provides a guided setup to install any required
dependencies if ESLint is not already configured in your application.

If you have other directories that you would like to lint, you can specify
them using the `--dir` flag:

Next.js collects **completely anonymous** telemetry data about general usage.
Participation in this anonymous program is optional, and you may opt-out if
you'd not like to share any information.

To learn more about Telemetry, please read this document.

`next info` prints relevant details about the current system which can be used
to report Next.js bugs. This information includes Operating System
platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm) and npm package
versions (`next`, `react`, `react-dom`).

Running the following in your project's root directory:

will give you information like this example:

    
    
     
        Operating System:
          Platform: linux
          Arch: x64
          Version: #22-Ubuntu SMP Fri Nov 5 13:21:36 UTC 2021
        Binaries:
          Node: 16.13.0
          npm: 8.1.0
          Yarn: 1.22.17
          pnpm: 6.24.2
        Relevant packages:
          next: 12.0.8
          react: 17.0.2
          react-dom: 17.0.2
     

This information should then be pasted into GitHub Issues.





Using Pages Router

Features available in /pages



  
  
# Pages and Layouts

The Pages Router has a file-system based router built on the concept of pages.

When a file is added to the `pages` directory, it's automatically available as
a route.

In Next.js, a **page** is a React Component exported from a `.js`, `.jsx`,
`.ts`, or `.tsx` file in the `pages` directory. Each page is associated with a
route based on its file name.

**Example** : If you create `pages/about.js` that exports a React component
like below, it will be accessible at `/about`.

    
    
    export default function About() {
      return <div>About</div>;
    }

The router will automatically route files named `index` to the root of the
directory.

  * `pages/index.js` → `/`
  * `pages/blog/index.js` → `/blog`

The router supports nested files. If you create a nested folder structure,
files will automatically be routed in the same way still.

  * `pages/blog/first-post.js` → `/blog/first-post`
  * `pages/dashboard/settings/username.js` → `/dashboard/settings/username`

Next.js supports pages with dynamic routes. For example, if you create a file
called `pages/posts/[id].js`, then it will be accessible at `posts/1`,
`posts/2`, etc.

> To learn more about dynamic routing, check the Dynamic Routing
> documentation.

The React model allows us to deconstruct a page into a series of components.
Many of these components are often reused between pages. For example, you
might have the same navigation bar and footer on every page.

    
    
    import Navbar from './navbar';
    import Footer from './footer';
     
    export default function Layout({ children }) {
      return (
        <>
          <Navbar />
          <main>{children}</main>
          <Footer />
        </>
      );
    }

If you only have one layout for your entire application, you can create a
Custom App and wrap your application with the layout. Since the `<Layout />`
component is re-used when changing pages, its component state will be
preserved (e.g. input values).

    
    
    import Layout from '../components/layout';
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <Layout>
          <Component {...pageProps} />
        </Layout>
      );
    }

If you need multiple layouts, you can add a property `getLayout` to your page,
allowing you to return a React component for the layout. This allows you to
define the layout on a _per-page basis_. Since we're returning a function, we
can have complex nested layouts if desired.

    
    
     
    import Layout from '../components/layout'
    import NestedLayout from '../components/nested-layout'
     
    export default function Page() {
      return (
        /** Your content */
      )
    }
     
    Page.getLayout = function getLayout(page) {
      return (
        <Layout>
          <NestedLayout>{page}</NestedLayout>
        </Layout>
      )
    }
    
    
    export default function MyApp({ Component, pageProps }) {
      // Use the layout defined at the page level, if available
      const getLayout = Component.getLayout || ((page) => page);
     
      return getLayout(<Component {...pageProps} />);
    }

When navigating between pages, we want to _persist_ page state (input values,
scroll position, etc.) for a Single-Page Application (SPA) experience.

This layout pattern enables state persistence because the React component tree
is maintained between page transitions. With the component tree, React can
understand which elements have changed to preserve state.

> **Note** : This process is called reconciliation, which is how React
> understands which elements have changed.

When using TypeScript, you must first create a new type for your pages which
includes a `getLayout` function. Then, you must create a new type for your
`AppProps` which overrides the `Component` property to use the previously
created type.

    
    
    import type { ReactElement } from 'react';
    import Layout from '../components/layout';
    import NestedLayout from '../components/nested-layout';
    import type { NextPageWithLayout } from './_app';
     
    const Page: NextPageWithLayout = () => {
      return <p>hello world</p>;
    };
     
    Page.getLayout = function getLayout(page: ReactElement) {
      return (
        <Layout>
          <NestedLayout>{page}</NestedLayout>
        </Layout>
      );
    };
     
    export default Page;
    
    
    import type { ReactElement, ReactNode } from 'react';
    import type { NextPage } from 'next';
    import type { AppProps } from 'next/app';
     
    export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {
      getLayout?: (page: ReactElement) => ReactNode;
    };
     
    type AppPropsWithLayout = AppProps & {
      Component: NextPageWithLayout;
    };
     
    export default function MyApp({ Component, pageProps }: AppPropsWithLayout) {
      // Use the layout defined at the page level, if available
      const getLayout = Component.getLayout ?? ((page) => page);
     
      return getLayout(<Component {...pageProps} />);
    }

Inside your layout, you can fetch data on the client-side using `useEffect` or
a library like SWR. Because this file is not a Page, you cannot use
`getStaticProps` or `getServerSideProps` currently.

    
    
    import useSWR from 'swr';
    import Navbar from './navbar';
    import Footer from './footer';
     
    export default function Layout({ children }) {
      const { data, error } = useSWR('/api/navigation', fetcher);
     
      if (error) return <div>Failed to load</div>;
      if (!data) return <div>Loading...</div>;
     
      return (
        <>
          <Navbar links={data.links} />
          <main>{children}</main>
          <Footer />
        </>
      );
    }





# Dynamic Routes

When you don't know the exact segment names ahead of time and want to create
routes from dynamic data, you can use Dynamic Segments that are filled in at
request time or prerendered at build time.

A Dynamic Segment can be created by wrapping a folder's name in square
brackets: `[folderName]`. For example, `[id]` or `[slug]`.

Dynamic Segments can be access from `useRouter`.

For example, a blog could include the following route `pages/blog/[slug].js`
where `[slug]` is the Dynamic Segment for blog posts.

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
      return <p>Post: {router.query.slug}</p>;
    }

Route| Example URL| `params`  
---|---|---  
`pages/blog/[slug].js`| `/blog/a`| `{ slug: 'a' }`  
`pages/blog/[slug].js`| `/blog/b`| `{ slug: 'b' }`  
`pages/blog/[slug].js`| `/blog/c`| `{ slug: 'c' }`  
  
Dynamic Segments can be extended to **catch-all** subsequent segments by
adding an ellipsis inside the brackets `[...folderName]`.

For example, `pages/shop/[...slug].js` will match `/shop/clothes`, but also
`/shop/clothes/tops`, `/shop/clothes/tops/t-shirts`, and so on.

Route| Example URL| `params`  
---|---|---  
`pages/shop/[...slug].js`| `/shop/a`| `{ slug: ['a'] }`  
`pages/shop/[...slug].js`| `/shop/a/b`| `{ slug: ['a', 'b'] }`  
`pages/shop/[...slug].js`| `/shop/a/b/c`| `{ slug: ['a', 'b', 'c'] }`  
  
Catch-all Segments can be made **optional** by including the parameter in
double square brackets: `[[...folderName]]`.

For example, `pages/shop/[[...slug]].js` will **also** match `/shop`, in
addition to `/shop/clothes`, `/shop/clothes/tops`,
`/shop/clothes/tops/t-shirts`.

The difference between **catch-all** and **optional catch-all** segments is
that with optional, the route without the parameter is also matched (`/shop`
in the example above).

Route| Example URL| `params`  
---|---|---  
`pages/shop/[[...slug]].js`| `/shop`| `{}`  
`pages/shop/[[...slug]].js`| `/shop/a`| `{ slug: ['a'] }`  
`pages/shop/[[...slug]].js`| `/shop/a/b`| `{ slug: ['a', 'b'] }`  
`pages/shop/[[...slug]].js`| `/shop/a/b/c`| `{ slug: ['a', 'b', 'c'] }`





# Linking and Navigating

The Next.js router allows you to do client-side route transitions between
pages, similar to a single-page application.

A React component called `Link` is provided to do this client-side route
transition.

    
    
    import Link from 'next/link';
     
    function Home() {
      return (
        <ul>
          <li>
            <Link href="/">Home</Link>
          </li>
          <li>
            <Link href="/about">About Us</Link>
          </li>
          <li>
            <Link href="/blog/hello-world">Blog Post</Link>
          </li>
        </ul>
      );
    }
     
    export default Home;

The example above uses multiple links. Each one maps a path (`href`) to a
known page:

  * `/` → `pages/index.js`
  * `/about` → `pages/about.js`
  * `/blog/hello-world` → `pages/blog/[slug].js`

Any `<Link />` in the viewport (initially or through scroll) will be
prefetched by default (including the corresponding data) for pages using
Static Generation. The corresponding data for server-rendered routes is
fetched _only when_ the `<Link />` is clicked.

You can also use interpolation to create the path, which comes in handy for
dynamic route segments. For example, to show a list of posts which have been
passed to the component as a prop:

    
    
    import Link from 'next/link';
     
    function Posts({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/blog/${encodeURIComponent(post.slug)}`}>
                {post.title}
              </Link>
            </li>
          ))}
        </ul>
      );
    }
     
    export default Posts;

> `encodeURIComponent` is used in the example to keep the path utf-8
> compatible.

Alternatively, using a URL Object:

    
    
    import Link from 'next/link';
     
    function Posts({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link
                href={{
                  pathname: '/blog/[slug]',
                  query: { slug: post.slug },
                }}
              >
                {post.title}
              </Link>
            </li>
          ))}
        </ul>
      );
    }
     
    export default Posts;

Now, instead of using interpolation to create the path, we use a URL object in
`href` where:

  * `pathname` is the name of the page in the `pages` directory. `/blog/[slug]` in this case.
  * `query` is an object with the dynamic segment. `slug` in this case.

**Examples**

To access the `router` object in a React component you can use `useRouter` or
`withRouter`.

In general we recommend using `useRouter`.

**Examples**

`next/link` should be able to cover most of your routing needs, but you can
also do client-side navigations without it, take a look at the documentation
for `next/router`.

The following example shows how to do basic page navigations with `useRouter`:

    
    
    import { useRouter } from 'next/router';
     
    export default function ReadMore() {
      const router = useRouter();
     
      return (
        <button onClick={() => router.push('/about')}>
          Click here to read more
        </button>
      );
    }

**Examples**

Shallow routing allows you to change the URL without running data fetching
methods again, that includes `getServerSideProps`, `getStaticProps`, and
`getInitialProps`.

You'll receive the updated `pathname` and the `query` via the `router` object
(added by `useRouter` or `withRouter`), without losing state.

To enable shallow routing, set the `shallow` option to `true`. Consider the
following example:

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    // Current URL is '/'
    function Page() {
      const router = useRouter();
     
      useEffect(() => {
        // Always do navigations after the first render
        router.push('/?counter=10', undefined, { shallow: true });
      }, []);
     
      useEffect(() => {
        // The counter changed!
      }, [router.query.counter]);
    }
     
    export default Page;

The URL will get updated to `/?counter=10`. and the page won't get replaced,
only the state of the route is changed.

You can also watch for URL changes via `componentDidUpdate` as shown below:

    
    
    componentDidUpdate(prevProps) {
      const { pathname, query } = this.props.router
      // verify props have changed to avoid an infinite loop
      if (query.counter !== prevProps.router.query.counter) {
        // fetch data based on the new query
      }
    }

Shallow routing **only** works for URL changes in the current page. For
example, let's assume we have another page called `pages/about.js`, and you
run this:

    
    
    router.push('/?counter=10', '/about?counter=10', { shallow: true });

Since that's a new page, it'll unload the current page, load the new one and
wait for data fetching even though we asked to do shallow routing.

When shallow routing is used with middleware it will not ensure the new page
matches the current page like previously done without middleware. This is due
to middleware being able to rewrite dynamically and can't be verified client-
side without a data fetch which is skipped with shallow, so a shallow route
change must always be treated as shallow.



  
  
Using Pages Router

Features available in /pages





# Custom Document

A custom `Document` can update the `<html>` and `<body>` tags used to render a
Page. This file is only rendered on the server, so event handlers like
`onClick` cannot be used in `_document`.

To override the default `Document`, create the file `pages/_document.js` as
shown below:

    
    
    import { Html, Head, Main, NextScript } from 'next/document';
     
    export default function Document() {
      return (
        <Html>
          <Head />
          <body>
            <Main />
            <NextScript />
          </body>
        </Html>
      );
    }

The code above is the default `Document` added by Next.js. Custom attributes
are allowed as props. For example, we might want to add `lang="en"` to the
`<html>` tag:

Or add a `className` to the `body` tag:

    
    
    <body className="bg-white">

`<Html>`, `<Head />`, `<Main />` and `<NextScript />` are required for the
page to be properly rendered.

  * The `<Head />` component used in `_document` is not the same as `next/head`. The `<Head />` component used here should only be used for any `<head>` code that is common for all pages. For all other cases, such as `<title>` tags, we recommend using `next/head` in your pages or components.
  * React components outside of `<Main />` will not be initialized by the browser. Do _not_ add application logic here or custom CSS (like `styled-jsx`). If you need shared components in all your pages (like a menu or a toolbar), read Layouts instead.
  * `Document` currently does not support Next.js Data Fetching methods like `getStaticProps` or `getServerSideProps`.

> **Note** : This is advanced and only needed for libraries like CSS-in-JS to
> support server-side rendering. This is not needed for built-in `styled-jsx`
> support.

For React 18 support, we recommend avoiding customizing `getInitialProps` and
`renderPage`, if possible.

The `ctx` object shown below is equivalent to the one received in
`getInitialProps`, with the addition of `renderPage`.

    
    
    import Document, { Html, Head, Main, NextScript } from 'next/document';
     
    class MyDocument extends Document {
      static async getInitialProps(ctx) {
        const originalRenderPage = ctx.renderPage;
     
        // Run the React rendering logic synchronously
        ctx.renderPage = () =>
          originalRenderPage({
            // Useful for wrapping the whole react tree
            enhanceApp: (App) => App,
            // Useful for wrapping in a per-page basis
            enhanceComponent: (Component) => Component,
          });
     
        // Run the parent `getInitialProps`, it now includes the custom `renderPage`
        const initialProps = await Document.getInitialProps(ctx);
     
        return initialProps;
      }
     
      render() {
        return (
          <Html>
            <Head />
            <body>
              <Main />
              <NextScript />
            </body>
          </Html>
        );
      }
    }
     
    export default MyDocument;

> **Note** : `getInitialProps` in `_document` is not called during client-side
> transitions.

You can use the built-in `DocumentContext` type and change the file name to
`./pages/_document.tsx` like so:

    
    
    import Document, { DocumentContext, DocumentInitialProps } from 'next/document';
     
    class MyDocument extends Document {
      static async getInitialProps(
        ctx: DocumentContext,
      ): Promise<DocumentInitialProps> {
        const initialProps = await Document.getInitialProps(ctx);
     
        return initialProps;
      }
    }
     
    export default MyDocument;





# Custom Errors

A 404 page may be accessed very often. Server-rendering an error page for
every visit increases the load of the Next.js server. This can result in
increased costs and slow experiences.

To avoid the above pitfalls, Next.js provides a static 404 page by default
without having to add any additional files.

To create a custom 404 page you can create a `pages/404.js` file. This file is
statically generated at build time.

    
    
    export default function Custom404() {
      return <h1>404 - Page Not Found</h1>;
    }

> **Note** : You can use `getStaticProps` inside this page if you need to
> fetch data at build time.

Server-rendering an error page for every visit adds complexity to responding
to errors. To help users get responses to errors as fast as possible, Next.js
provides a static 500 page by default without having to add any additional
files.

To customize the 500 page you can create a `pages/500.js` file. This file is
statically generated at build time.

    
    
    export default function Custom500() {
      return <h1>500 - Server-side error occurred</h1>;
    }

> **Note** : You can use `getStaticProps` inside this page if you need to
> fetch data at build time.

500 errors are handled both client-side and server-side by the `Error`
component. If you wish to override it, define the file `pages/_error.js` and
add the following code:

    
    
    function Error({ statusCode }) {
      return (
        <p>
          {statusCode
            ? `An error ${statusCode} occurred on server`
            : 'An error occurred on client'}
        </p>
      );
    }
     
    Error.getInitialProps = ({ res, err }) => {
      const statusCode = res ? res.statusCode : err ? err.statusCode : 404;
      return { statusCode };
    };
     
    export default Error;

> `pages/_error.js` is only used in production. In development you’ll get an
> error with the call stack to know where the error originated from.

If you want to render the built-in error page you can by importing the `Error`
component:

    
    
    import Error from 'next/error';
     
    export async function getServerSideProps() {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const errorCode = res.ok ? false : res.status;
      const json = await res.json();
     
      return {
        props: { errorCode, stars: json.stargazers_count },
      };
    }
     
    export default function Page({ errorCode, stars }) {
      if (errorCode) {
        return <Error statusCode={errorCode} />;
      }
     
      return <div>Next stars: {stars}</div>;
    }

The `Error` component also takes `title` as a property if you want to pass in
a text message along with a `statusCode`.

If you have a custom `Error` component be sure to import that one instead.
`next/error` exports the default component used by Next.js.





# API Routes

 **Examples**

> **Note** : If you are using the App Router, you can use Server Components or
> Route Handlers instead of API Routes.

API routes provide a solution to build your **API** with Next.js.

Any file inside the folder `pages/api` is mapped to `/api/*` and will be
treated as an API endpoint instead of a `page`. They are server-side only
bundles and won't increase your client-side bundle size.

For example, the following API route `pages/api/user.js` returns a `json`
response with a status code of `200`:

    
    
    export default function handler(req, res) {
      res.status(200).json({ name: 'John Doe' });
    }

> **Note** : API Routes will be affected by `pageExtensions` configuration in
> `next.config.js`.

For an API route to work, you need to export a function as default (a.k.a
**request handler** ), which then receives the following parameters:

To handle different HTTP methods in an API route, you can use `req.method` in
your request handler, like so:

    
    
    export default function handler(req, res) {
      if (req.method === 'POST') {
        // Process a POST request
      } else {
        // Handle any other HTTP method
      }
    }

To fetch API endpoints, take a look into any of the examples at the start of
this section.

For new projects, you can build your entire API with API Routes. If you have
an existing API, you do not need to forward calls to the API through an API
Route. Some other use cases for API Routes are:

  * Masking the URL of an external service (e.g. `/api/secret` instead of `https://company.com/secret-url`)
  * Using Environment Variables on the server to securely access external services.

API Routes provide built-in request helpers which parse the incoming request
(`req`):

  * `req.cookies` \- An object containing the cookies sent by the request. Defaults to `{}`
  * `req.query` \- An object containing the query string. Defaults to `{}`
  * `req.body` \- An object containing the body parsed by `content-type`, or `null` if no body was sent

Every API Route can export a `config` object to change the default
configuration, which is the following:

    
    
    export const config = {
      api: {
        bodyParser: {
          sizeLimit: '1mb',
        },
      },
    };

The `api` object includes all config options available for API Routes.

`bodyParser` is automatically enabled. If you want to consume the body as a
`Stream` or with `raw-body`, you can set this to `false`.

One use case for disabling the automatic `bodyParsing` is to allow you to
verify the raw body of a **webhook** request, for example from GitHub.

    
    
    export const config = {
      api: {
        bodyParser: false,
      },
    };

`bodyParser.sizeLimit` is the maximum size allowed for the parsed body, in any
format supported by bytes, like so:

    
    
    export const config = {
      api: {
        bodyParser: {
          sizeLimit: '500kb',
        },
      },
    };

`externalResolver` is an explicit flag that tells the server that this route
is being handled by an external resolver like _express_ or _connect_. Enabling
this option disables warnings for unresolved requests.

    
    
    export const config = {
      api: {
        externalResolver: true,
      },
    };

`responseLimit` is automatically enabled, warning when an API Routes' response
body is over 4MB.

If you are not using Next.js in a serverless environment, and understand the
performance implications of not using a CDN or dedicated media host, you can
set this limit to `false`.

    
    
    export const config = {
      api: {
        responseLimit: false,
      },
    };

`responseLimit` can also take the number of bytes or any string format
supported by `bytes`, for example `1000`, `'500kb'` or `'3mb'`. This value
will be the maximum response size before a warning is displayed. Default is
4MB. (see above)

    
    
    export const config = {
      api: {
        responseLimit: '8mb',
      },
    };

For better type-safety, it is not recommended to extend the `req` and `res`
objects. Instead, use functions to work with them:

    
    
    import { serialize, CookieSerializeOptions } from 'cookie';
    import { NextApiResponse } from 'next';
     
    /**
     * This sets `cookie` using the `res` object
     */
    export const setCookie = (
      res: NextApiResponse,
      name: string,
      value: unknown,
      options: CookieSerializeOptions = {},
    ) => {
      const stringValue =
        typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
     
      if (typeof options.maxAge === 'number') {
        options.expires = new Date(Date.now() + options.maxAge * 1000);
      }
     
      res.setHeader('Set-Cookie', serialize(name, stringValue, options));
    };
    
    
    import { NextApiRequest, NextApiResponse } from 'next';
    import { setCookie } from '../../utils/cookies';
     
    const handler = (req: NextApiRequest, res: NextApiResponse) => {
      // Calling our pure function using the `res` object, it will add the `set-cookie` header
      // Add the `set-cookie` header on the main domain and expire after 30 days
      setCookie(res, 'Next.js', 'api-middleware!', { path: '/', maxAge: 2592000 });
      // Return the `set-cookie` header so we can display it in the browser and show that it works!
      res.end(res.getHeader('Set-Cookie'));
    };
     
    export default handler;

If you can't avoid these objects from being extended, you have to create your
own type to include the extra properties:

    
    
    import { NextApiRequest, NextApiResponse } from 'next';
    import { withFoo } from 'external-lib-foo';
     
    type NextApiRequestWithFoo = NextApiRequest & {
      foo: (bar: string) => void;
    };
     
    const handler = (req: NextApiRequestWithFoo, res: NextApiResponse) => {
      req.foo('bar'); // we can now use `req.foo` without type errors
      res.end('ok');
    };
     
    export default withFoo(handler);

Keep in mind this is not safe since the code will still compile even if you
remove `withFoo()` from the export.

The Server Response object, (often abbreviated as `res`) includes a set of
Express.js-like helper methods to improve the developer experience and
increase the speed of creating new API endpoints.

The included helpers are:

  * `res.status(code)` \- A function to set the status code. `code` must be a valid HTTP status code
  * `res.json(body)` \- Sends a JSON response. `body` must be a serializable object
  * `res.send(body)` \- Sends the HTTP response. `body` can be a `string`, an `object` or a `Buffer`
  * `res.redirect([status,] path)` \- Redirects to a specified path or URL. `status` must be a valid HTTP status code. If not specified, `status` defaults to "307" "Temporary redirect".
  * `res.revalidate(urlPath)` \- Revalidate a page on demand using `getStaticProps`. `urlPath` must be a `string`.

When sending a response back to the client, you can set the status code of the
response.

The following example sets the status code of the response to `200` (`OK`) and
returns a `message` property with the value of `Hello from Next.js!` as a JSON
response:

    
    
    export default function handler(req, res) {
      res.status(200).json({ message: 'Hello from Next.js!' });
    }

When sending a response back to the client you can send a JSON response, this
must be a serializable object. In a real world application you might want to
let the client know the status of the request depending on the result of the
requested endpoint.

The following example sends a JSON response with the status code `200` (`OK`)
and the result of the async operation. It's contained in a try catch block to
handle any errors that may occur, with the appropriate status code and error
message caught and sent back to the client:

    
    
    export default async function handler(req, res) {
      try {
        const result = await someAsyncOperation();
        res.status(200).json({ result });
      } catch (err) {
        res.status(500).json({ error: 'failed to load data' });
      }
    }

Sending an HTTP response works the same way as when sending a JSON response.
The only difference is that the response body can be a `string`, an `object`
or a `Buffer`.

The following example sends a HTTP response with the status code `200` (`OK`)
and the result of the async operation.

    
    
    export default async function handler(req, res) {
      try {
        const result = await someAsyncOperation();
        res.status(200).send({ result });
      } catch (err) {
        res.status(500).send({ error: 'failed to fetch data' });
      }
    }

Taking a form as an example, you may want to redirect your client to a
specified path or URL once they have submitted the form.

The following example redirects the client to the `/` path if the form is
successfully submitted:

    
    
    export default async function handler(req, res) {
      const { name, message } = req.body;
      try {
        await handleFormInputAsync({ name, message });
        res.redirect(307, '/');
      } catch (err) {
        res.status(500).send({ error: 'failed to fetch data' });
      }
    }

You can make your response handlers more type-safe by importing the
`NextApiRequest` and `NextApiResponse` types from `next`, in addition to
those, you can also type your response data:

    
    
    import type { NextApiRequest, NextApiResponse } from 'next';
     
    type ResponseData = {
      message: string;
    };
     
    export default function handler(
      req: NextApiRequest,
      res: NextApiResponse<ResponseData>,
    ) {
      res.status(200).json({ message: 'Hello from Next.js!' });
    }

> **Note** : The body of `NextApiRequest` is `any` because the client may
> include any payload. You should validate the type/shape of the body at
> runtime before using it.

API routes support dynamic routes, and follow the same file naming rules used
for `pages`.

For example, the API route `pages/api/post/[pid].js` has the following code:

    
    
    export default function handler(req, res) {
      const { pid } = req.query;
      res.end(`Post: ${pid}`);
    }

Now, a request to `/api/post/abc` will respond with the text: `Post: abc`.

A very common RESTful pattern is to set up routes like this:

  * `GET api/posts` \- gets a list of posts, probably paginated
  * `GET api/posts/12345` \- gets post id 12345

We can model this in two ways:

  * Option 1: 
    * `/api/posts.js`
    * `/api/posts/[postId].js`
  * Option 2: 
    * `/api/posts/index.js`
    * `/api/posts/[postId].js`

Both are equivalent. A third option of only using `/api/posts/[postId].js` is
not valid because Dynamic Routes (including Catch-all routes - see below) do
not have an `undefined` state and `GET api/posts` will not match
`/api/posts/[postId].js` under any circumstances.

API Routes can be extended to catch all paths by adding three dots (`...`)
inside the brackets. For example:

  * `pages/api/post/[...slug].js` matches `/api/post/a`, but also `/api/post/a/b`, `/api/post/a/b/c` and so on.

> **Note** : You can use names other than `slug`, such as: `[...param]`

Matched parameters will be sent as a query parameter (`slug` in the example)
to the page, and it will always be an array, so, the path `/api/post/a` will
have the following `query` object:

And in the case of `/api/post/a/b`, and any other matching path, new
parameters will be added to the array, like so:

An API route for `pages/api/post/[...slug].js` could look like this:

    
    
    export default function handler(req, res) {
      const { slug } = req.query;
      res.end(`Post: ${slug.join(', ')}`);
    }

Now, a request to `/api/post/a/b/c` will respond with the text: `Post: a, b,
c`.

Catch all routes can be made optional by including the parameter in double
brackets (`[[...slug]]`).

For example, `pages/api/post/[[...slug]].js` will match `/api/post`,
`/api/post/a`, `/api/post/a/b`, and so on.

The main difference between catch all and optional catch all routes is that
with optional, the route without the parameter is also matched (`/api/post` in
the example above).

The `query` objects are as follows:

    
    
    { } // GET `/api/post` (empty object)
    { "slug": ["a"] } // `GET /api/post/a` (single-element array)
    { "slug": ["a", "b"] } // `GET /api/post/a/b` (multi-element array)

  * Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples: 
    * `pages/api/post/create.js` \- Will match `/api/post/create`
    * `pages/api/post/[pid].js` \- Will match `/api/post/1`, `/api/post/abc`, etc. But not `/api/post/create`
    * `pages/api/post/[...slug].js` \- Will match `/api/post/1/2`, `/api/post/a/b/c`, etc. But not `/api/post/create`, `/api/post/abc`

Edge API Routes enable you to build high performance APIs with Next.js. Using
the Edge Runtime, they are often faster than Node.js-based API Routes. This
performance improvement does come with constraints, like not having access to
native Node.js APIs. Instead, Edge API Routes are built on standard Web APIs.

Any file inside the folder `pages/api` is mapped to `/api/*` and will be
treated as an API endpoint instead of a page. They are server-side only
bundles and won't increase your client-side bundle size.

    
    
    export const config = {
      runtime: 'edge',
    };
     
    export default (req) => new Response('Hello world!');
    
    
    import type { NextRequest } from 'next/server';
     
    export const config = {
      runtime: 'edge',
    };
     
    export default async function handler(req: NextRequest) {
      return new Response(
        JSON.stringify({
          name: 'Jim Halpert',
        }),
        {
          status: 200,
          headers: {
            'content-type': 'application/json',
          },
        },
      );
    }
    
    
    import type { NextRequest } from 'next/server';
     
    export const config = {
      runtime: 'edge',
    };
     
    export default async function handler(req: NextRequest) {
      return new Response(
        JSON.stringify({
          name: 'Jim Halpert',
        }),
        {
          status: 200,
          headers: {
            'content-type': 'application/json',
            'cache-control': 'public, s-maxage=1200, stale-while-revalidate=600',
          },
        },
      );
    }
    
    
    import type { NextRequest } from 'next/server';
     
    export const config = {
      runtime: 'edge',
    };
     
    export default async function handler(req: NextRequest) {
      const { searchParams } = new URL(req.url);
      const email = searchParams.get('email');
      return new Response(email);
    }
    
    
    import { type NextRequest } from 'next/server';
     
    export const config = {
      runtime: 'edge',
    };
     
    export default async function handler(req: NextRequest) {
      const authorization = req.cookies.get('authorization')?.value;
      return fetch('https://backend-api.com/api/protected', {
        method: req.method,
        headers: {
          authorization,
        },
        redirect: 'manual',
      });
    }

You may want to restrict your edge function to specific regions when deploying
so that you can colocate near your data sources ensuring lower response times
which can be achieved as shown.

> **Note** : This configuration is available in `v12.3.2` of Next.js and up.
    
    
    import { NextResponse } from 'next/server';
     
    export const config = {
      regions: ['sfo1', 'iad1'], // defaults to 'all'
    };
     
    export default async function handler(req: NextRequest) {
      const myData = await getNearbyData();
      return NextResponse.json(myData);
    }

Edge API Routes use the Edge Runtime, whereas API Routes use the Node.js
runtime.

Edge API Routes can stream responses from the server and run _after_ cached
files (e.g. HTML, CSS, JavaScript) have been accessed. Server-side streaming
can help improve performance with faster Time To First Byte (TTFB).

> **Note** : Using Edge Runtime with `getServerSideProps` does not give you
> access to the response object. If you need access to `res`, you should use
> the Node.js runtime by setting `runtime: 'nodejs'`.

View the supported APIs and unsupported APIs for the Edge Runtime.





# Internationalization (i18n) Routing

 **Examples**

Next.js has built-in support for internationalized (i18n) routing since
`v10.0.0`. You can provide a list of locales, the default locale, and domain-
specific locales and Next.js will automatically handle the routing.

The i18n routing support is currently meant to complement existing i18n
library solutions like `react-intl`, `react-i18next`, `lingui`, `rosetta`,
`next-intl`, `next-translate`, `next-multilingual`, `typesafe-i18n`, and
others by streamlining the routes and locale parsing.

To get started, add the `i18n` config to your `next.config.js` file.

Locales are UTS Locale Identifiers, a standardized format for defining
locales.

Generally a Locale Identifier is made up of a language, region, and script
separated by a dash: `language-region-script`. The region and script are
optional. An example:

  * `en-US` \- English as spoken in the United States
  * `nl-NL` \- Dutch as spoken in the Netherlands
  * `nl` \- Dutch, no specific region

If user locale is `nl-BE` and it is not listed in your configuration, they
will be redirected to `nl` if available, or to the default locale otherwise.
If you don't plan to support all regions of a country, it is therefore a good
practice to include country locales that will act as fallbacks.

    
    
    module.exports = {
      i18n: {
        // These are all the locales you want to support in
        // your application
        locales: ['en-US', 'fr', 'nl-NL'],
        // This is the default locale you want to be used when visiting
        // a non-locale prefixed path e.g. `/hello`
        defaultLocale: 'en-US',
        // This is a list of locale domains and the default locale they
        // should handle (these are only required when setting up domain routing)
        // Note: subdomains must be included in the domain value to be matched e.g. "fr.example.com".
        domains: [
          {
            domain: 'example.com',
            defaultLocale: 'en-US',
          },
          {
            domain: 'example.nl',
            defaultLocale: 'nl-NL',
          },
          {
            domain: 'example.fr',
            defaultLocale: 'fr',
            // an optional http field can also be used to test
            // locale domains locally with http instead of https
            http: true,
          },
        ],
      },
    };

There are two locale handling strategies: Sub-path Routing and Domain Routing.

Sub-path Routing puts the locale in the url path.

    
    
    module.exports = {
      i18n: {
        locales: ['en-US', 'fr', 'nl-NL'],
        defaultLocale: 'en-US',
      },
    };

With the above configuration `en-US`, `fr`, and `nl-NL` will be available to
be routed to, and `en-US` is the default locale. If you have a `pages/blog.js`
the following urls would be available:

  * `/blog`
  * `/fr/blog`
  * `/nl-nl/blog`

The default locale does not have a prefix.

By using domain routing you can configure locales to be served from different
domains:

    
    
    module.exports = {
      i18n: {
        locales: ['en-US', 'fr', 'nl-NL', 'nl-BE'],
        defaultLocale: 'en-US',
     
        domains: [
          {
            // Note: subdomains must be included in the domain value to be matched
            // e.g. www.example.com should be used if that is the expected hostname
            domain: 'example.com',
            defaultLocale: 'en-US',
          },
          {
            domain: 'example.fr',
            defaultLocale: 'fr',
          },
          {
            domain: 'example.nl',
            defaultLocale: 'nl-NL',
            // specify other locales that should be redirected
            // to this domain
            locales: ['nl-BE'],
          },
        ],
      },
    };

For example if you have `pages/blog.js` the following urls will be available:

  * `example.com/blog`
  * `www.example.com/blog`
  * `example.fr/blog`
  * `example.nl/blog`
  * `example.nl/nl-BE/blog`

When a user visits the application root (generally `/`), Next.js will try to
automatically detect which locale the user prefers based on the `Accept-
Language` header and the current domain.

If a locale other than the default locale is detected, the user will be
redirected to either:

  * **When using Sub-path Routing:** The locale prefixed path
  * **When using Domain Routing:** The domain with that locale specified as the default

When using Domain Routing, if a user with the `Accept-Language` header
`fr;q=0.9` visits `example.com`, they will be redirected to `example.fr` since
that domain handles the `fr` locale by default.

When using Sub-path Routing, the user would be redirected to `/fr`.

With Next.js 12 and Middleware, we can add a prefix to the default locale with
a workaround.

For example, here's a `next.config.js` file with support for a few languages.
Note the `"default"` locale has been added intentionally.

    
    
    module.exports = {
      i18n: {
        locales: ['default', 'en', 'de', 'fr'],
        defaultLocale: 'default',
        localeDetection: false,
      },
      trailingSlash: true,
    };

Next, we can use Middleware to add custom routing rules:

    
    
    import { NextRequest, NextResponse } from 'next/server';
     
    const PUBLIC_FILE = /\.(.*)$/;
     
    export async function middleware(req: NextRequest) {
      if (
        req.nextUrl.pathname.startsWith('/_next') ||
        req.nextUrl.pathname.includes('/api/') ||
        PUBLIC_FILE.test(req.nextUrl.pathname)
      ) {
        return;
      }
     
      if (req.nextUrl.locale === 'default') {
        const locale = req.cookies.get('NEXT_LOCALE')?.value || 'en';
     
        return NextResponse.redirect(
          new URL(
            `/${locale}${req.nextUrl.pathname}${req.nextUrl.search}`,
            req.url,
          ),
        );
      }
    }

This Middleware skips adding the default prefix to API Routes and public files
like fonts or images. If a request is made to the default locale, we redirect
to our prefix `/en`.

The automatic locale detection can be disabled with:

    
    
    module.exports = {
      i18n: {
        localeDetection: false,
      },
    };

When `localeDetection` is set to `false` Next.js will no longer automatically
redirect based on the user's preferred locale and will only provide locale
information detected from either the locale based domain or locale path as
described above.

You can access the locale information via the Next.js router. For example,
using the `useRouter()` hook the following properties are available:

  * `locale` contains the currently active locale.
  * `locales` contains all configured locales.
  * `defaultLocale` contains the configured default locale.

When pre-rendering pages with `getStaticProps` or `getServerSideProps`, the
locale information is provided in the context provided to the function.

When leveraging `getStaticPaths`, the configured locales are provided in the
context parameter of the function under `locales` and the configured
defaultLocale under `defaultLocale`.

You can use `next/link` or `next/router` to transition between locales.

For `next/link`, a `locale` prop can be provided to transition to a different
locale from the currently active one. If no `locale` prop is provided, the
currently active `locale` is used during client-transitions. For example:

    
    
    import Link from 'next/link';
     
    export default function IndexPage(props) {
      return (
        <Link href="/another" locale="fr">
          To /fr/another
        </Link>
      );
    }

When using the `next/router` methods directly, you can specify the `locale`
that should be used via the transition options. For example:

    
    
    import { useRouter } from 'next/router';
     
    export default function IndexPage(props) {
      const router = useRouter();
     
      return (
        <div
          onClick={() => {
            router.push('/another', '/another', { locale: 'fr' });
          }}
        >
          to /fr/another
        </div>
      );
    }

Note that to handle switching only the `locale` while preserving all routing
information such as dynamic route query values or hidden href query values,
you can provide the `href` parameter as an object:

    
    
    import { useRouter } from 'next/router';
    const router = useRouter();
    const { pathname, asPath, query } = router;
    // change just the locale and maintain all other route information including href's query
    router.push({ pathname, query }, asPath, { locale: nextLocale });

See here for more information on the object structure for `router.push`.

If you have a `href` that already includes the locale you can opt-out of
automatically handling the locale prefixing:

    
    
    import Link from 'next/link';
     
    export default function IndexPage(props) {
      return (
        <Link href="/fr/another" locale={false}>
          To /fr/another
        </Link>
      );
    }

Next.js supports overriding the accept-language header with a
`NEXT_LOCALE=the-locale` cookie. This cookie can be set using a language
switcher and then when a user comes back to the site it will leverage the
locale specified in the cookie when redirecting from `/` to the correct locale
location.

For example, if a user prefers the locale `fr` in their accept-language header
but a `NEXT_LOCALE=en` cookie is set the `en` locale when visiting `/` the
user will be redirected to the `en` locale location until the cookie is
removed or expired.

Since Next.js knows what language the user is visiting it will automatically
add the `lang` attribute to the `<html>` tag.

Next.js doesn't know about variants of a page so it's up to you to add the
`hreflang` meta tags using `next/head`. You can learn more about `hreflang` in
the Google Webmasters documentation.

> Note that Internationalized Routing does not integrate with `output:
> 'export'` as it does not leverage the Next.js routing layer. Hybrid Next.js
> applications that do not use `output: 'export'` are fully supported.

For pages using `getStaticProps` with Dynamic Routes, all locale variants of
the page desired to be prerendered need to be returned from `getStaticPaths`.
Along with the `params` object returned for `paths`, you can also return a
`locale` field specifying which locale you want to render. For example:

    
    
    export const getStaticPaths = ({ locales }) => {
      return {
        paths: [
          // if no `locale` is provided only the defaultLocale will be generated
          { params: { slug: 'post-1' }, locale: 'en-US' },
          { params: { slug: 'post-1' }, locale: 'fr' },
        ],
        fallback: true,
      };
    };

For Automatically Statically Optimized and non-dynamic `getStaticProps` pages,
**a version of the page will be generated for each locale**. This is important
to consider because it can increase build times depending on how many locales
are configured inside `getStaticProps`.

For example, if you have 50 locales configured with 10 non-dynamic pages using
`getStaticProps`, this means `getStaticProps` will be called 500 times. 50
versions of the 10 pages will be generated during each build.

To decrease the build time of dynamic pages with `getStaticProps`, use a
`fallback` mode. This allows you to return only the most popular paths and
locales from `getStaticPaths` for prerendering during the build. Then, Next.js
will build the remaining pages at runtime as they are requested.

For pages that are automatically statically optimized, a version of the page
will be generated for each locale.

For non-dynamic `getStaticProps` pages, a version is generated for each locale
like above. `getStaticProps` is called with each `locale` that is being
rendered. If you would like to opt-out of a certain locale from being pre-
rendered, you can return `notFound: true` from `getStaticProps` and this
variant of the page will not be generated.

    
    
    export async function getStaticProps({ locale }) {
      // Call an external API endpoint to get posts.
      // You can use any data fetching library
      const res = await fetch(`https://.../posts?locale=${locale}`);
      const posts = await res.json();
     
      if (posts.length === 0) {
        return {
          notFound: true,
        };
      }
     
      // By returning { props: posts }, the Blog component
      // will receive `posts` as a prop at build time
      return {
        props: {
          posts,
        },
      };
    }

  * `locales`: 100 total locales
  * `domains`: 100 total locale domain items

> **Note** : These limits have been added initially to prevent potential
> performance issues at build time. You can workaround these limits with
> custom routing using Middleware in Next.js 12.





# Authenticating

Authentication verifies who a user is, while authorization controls what a
user can access. Next.js supports multiple authentication patterns, each
designed for different use cases. This page will go through each case so that
you can choose based on your constraints.

The first step to identifying which authentication pattern you need is
understanding the data-fetching strategy you want. We can then determine which
authentication providers support this strategy. There are two main patterns:

  * Use static generation to server-render a loading state, followed by fetching user data client-side.
  * Fetch user data server-side to eliminate a flash of unauthenticated content.

Next.js automatically determines that a page is static if there are no
blocking data requirements. This means the absence of `getServerSideProps` and
`getInitialProps` in the page. Instead, your page can render a loading state
from the server, followed by fetching the user client-side.

One advantage of this pattern is it allows pages to be served from a global
CDN and preloaded using `next/link`. In practice, this results in a faster TTI
(Time to Interactive).

Let's look at an example for a profile page. This will initially render a
loading skeleton. Once the request for a user has finished, it will show the
user's name:

    
    
    import useUser from '../lib/useUser';
    import Layout from '../components/Layout';
     
    const Profile = () => {
      // Fetch the user client-side
      const { user } = useUser({ redirectTo: '/login' });
     
      // Server-render loading state
      if (!user || user.isLoggedIn === false) {
        return <Layout>Loading...</Layout>;
      }
     
      // Once the user request finishes, show the user
      return (
        <Layout>
          <h1>Your Profile</h1>
          <pre>{JSON.stringify(user, null, 2)}</pre>
        </Layout>
      );
    };
     
    export default Profile;

You can view this example in action. Check out the `with-iron-session` example
to see how it works.

If you export an `async` function called `getServerSideProps` from a page,
Next.js will pre-render this page on each request using the data returned by
`getServerSideProps`.

    
    
    export async function getServerSideProps(context) {
      return {
        props: {}, // Will be passed to the page component as props
      };
    }

Let's transform the profile example to use server-side rendering. If there's a
session, return `user` as a prop to the `Profile` component in the page.
Notice there is not a loading skeleton in this example.

    
    
    import withSession from '../lib/session';
    import Layout from '../components/Layout';
     
    export const getServerSideProps = withSession(async function ({ req, res }) {
      const { user } = req.session;
     
      if (!user) {
        return {
          redirect: {
            destination: '/login',
            permanent: false,
          },
        };
      }
     
      return {
        props: { user },
      };
    });
     
    const Profile = ({ user }) => {
      // Show the user. No loading state is required
      return (
        <Layout>
          <h1>Your Profile</h1>
          <pre>{JSON.stringify(user, null, 2)}</pre>
        </Layout>
      );
    };
     
    export default Profile;

An advantage of this pattern is preventing a flash of unauthenticated content
before redirecting. It's important to note fetching user data in
`getServerSideProps` will block rendering until the request to your
authentication provider resolves. To prevent creating a bottleneck and
increasing your TTFB (Time to First Byte), you should ensure your
authentication lookup is fast. Otherwise, consider static generation.

Now that we've discussed authentication patterns, let's look at specific
providers and explore how they're used with Next.js.

**Examples**

If you have an existing database with user data, you'll likely want to utilize
an open-source solution that's provider agnostic.

  * If you want a low-level, encrypted, and stateless session utility use `iron-session`.
  * If you want a full-featured authentication system with built-in providers (Google, Facebook, GitHub…), JWT, JWE, email/password, magic links and more… use `next-auth`.

Both of these libraries support either authentication pattern. If you're
interested in Passport, we also have examples for it using secure and
encrypted cookies:

To see examples with other authentication providers, check out the examples
folder.

**Examples**



  
  
# Middleware

Middleware allows you to run code before a request is completed. Then, based
on the incoming request, you can modify the response by rewriting,
redirecting, modifying the request or response headers, or responding
directly.

Middleware runs before cached content and routes are matched. See Matching
Paths for more details.

Use the file `middleware.ts` (or `.js`) in the root of your project to define
Middleware. For example, at the same level as `pages` or `app`, or inside
`src` if applicable.

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    // This function can be marked `async` if using `await` inside
    export function middleware(request: NextRequest) {
      return NextResponse.redirect(new URL('/home', request.url));
    }
     
    // See "Matching Paths" below to learn more
    export const config = {
      matcher: '/about/:path*',
    };

Middleware will be invoked for **every route in your project**. The following
is the execution order:

  1. `headers` from `next.config.js`
  2. `redirects` from `next.config.js`
  3. Middleware (`rewrites`, `redirects`, etc.)
  4. `beforeFiles` (`rewrites`) from `next.config.js`
  5. Filesystem routes (`public/`, `_next/static/`, `pages/`, `app/`, etc.)
  6. `afterFiles` (`rewrites`) from `next.config.js`
  7. Dynamic Routes (`/blog/[slug]`)
  8. `fallback` (`rewrites`) from `next.config.js`

There are two ways to define which paths Middleware will run on:

  1. Custom matcher config
  2. Conditional statements

`matcher` allows you to filter Middleware to run on specific paths.

    
    
    export const config = {
      matcher: '/about/:path*',
    };

You can match a single path or multiple paths with an array syntax:

    
    
    export const config = {
      matcher: ['/about/:path*', '/dashboard/:path*'],
    };

The `matcher` config allows full regex so matching like negative lookaheads or
character matching is supported. An example of a negative lookahead to match
all except specific paths can be seen here:

    
    
    export const config = {
      matcher: [
        /*
         * Match all request paths except for the ones starting with:
         * - api (API routes)
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         */
        '/((?!api|_next/static|_next/image|favicon.ico).*)',
      ],
    };

> **Note** : The `matcher` values need to be constants so they can be
> statically analyzed at build-time. Dynamic values such as variables will be
> ignored.

Configured matchers:

  1. MUST start with `/`
  2. Can include named parameters: `/about/:path` matches `/about/a` and `/about/b` but not `/about/a/c`
  3. Can have modifiers on named parameters (starting with `:`): `/about/:path*` matches `/about/a/b/c` because `*` is _zero or more_. `?` is _zero or one_ and `+` _one or more_
  4. Can use regular expression enclosed in parenthesis: `/about/(.*)` is the same as `/about/:path*`

Read more details on path-to-regexp documentation.

> **Note** : For backward compatibility, Next.js always considers `/public` as
> `/public/index`. Therefore, a matcher of `/public/:path` will match.
    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      if (request.nextUrl.pathname.startsWith('/about')) {
        return NextResponse.rewrite(new URL('/about-2', request.url));
      }
     
      if (request.nextUrl.pathname.startsWith('/dashboard')) {
        return NextResponse.rewrite(new URL('/dashboard/user', request.url));
      }
    }

The `NextResponse` API allows you to:

  * `redirect` the incoming request to a different URL
  * `rewrite` the response by displaying a given URL
  * Set request headers for API Routes, `getServerSideProps`, and `rewrite` destinations
  * Set response cookies
  * Set response headers

To produce a response from Middleware, you can:

  1. `rewrite` to a route (Page or Edge API Route) that produces a response
  2. return a `NextResponse` directly. See Producing a Response

Cookies are regular headers. On a `Request`, they are stored in the `Cookie`
header. On a `Response` they are in the `Set-Cookie` header. Next.js provides
a convenient way to access and manipulate these cookies through the `cookies`
extension on `NextRequest` and `NextResponse`.

  1. For incoming requests, `cookies` comes with the following methods: `get`, `getAll`, `set`, and `delete` cookies. You can check for the existence of a cookie with `has` or remove all cookies with `clear`.
  2. For outgoing responses, `cookies` have the following methods `get`, `getAll`, `set`, and `delete`.

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      // Assume a "Cookie:nextjs=fast" header to be present on the incoming request
      // Getting cookies from the request using the `RequestCookies` API
      let cookie = request.cookies.get('nextjs')?.value;
      console.log(cookie); // => 'fast'
      const allCookies = request.cookies.getAll();
      console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]
     
      request.cookies.has('nextjs'); // => true
      request.cookies.delete('nextjs');
      request.cookies.has('nextjs'); // => false
     
      // Setting cookies on the response using the `ResponseCookies` API
      const response = NextResponse.next();
      response.cookies.set('vercel', 'fast');
      response.cookies.set({
        name: 'vercel',
        value: 'fast',
        path: '/test',
      });
      cookie = response.cookies.get('vercel');
      console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/test' }
      // The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.
     
      return response;
    }

You can set request and response headers using the `NextResponse` API (setting
_request_ headers is available since Next.js v13.0.0).

    
    
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';
     
    export function middleware(request: NextRequest) {
      // Clone the request headers and set a new header `x-hello-from-middleware1`
      const requestHeaders = new Headers(request.headers);
      requestHeaders.set('x-hello-from-middleware1', 'hello');
     
      // You can also set request headers in NextResponse.rewrite
      const response = NextResponse.next({
        request: {
          // New request headers
          headers: requestHeaders,
        },
      });
     
      // Set a new response header `x-hello-from-middleware2`
      response.headers.set('x-hello-from-middleware2', 'hello');
      return response;
    }

> **Note** : Avoid setting large headers as it might cause 431 Request Header
> Fields Too Large error depending on your backend web server configuration.

You can respond from Middleware directly by returning a `Response` or
`NextResponse` instance. (This is available since Next.js v13.1.0)

    
    
    import { NextRequest, NextResponse } from 'next/server';
    import { isAuthenticated } from '@lib/auth';
     
    // Limit the middleware to paths starting with `/api/`
    export const config = {
      matcher: '/api/:function*',
    };
     
    export function middleware(request: NextRequest) {
      // Call our authentication function to check the request
      if (!isAuthenticated(request)) {
        // Respond with JSON indicating an error message
        return new NextResponse(
          JSON.stringify({ success: false, message: 'authentication failed' }),
          { status: 401, headers: { 'content-type': 'application/json' } },
        );
      }
    }

In `v13.1` of Next.js two additional flags were introduced for middleware,
`skipMiddlewareUrlNormalize` and `skipTrailingSlashRedirect` to handle
advanced use cases.

`skipTrailingSlashRedirect` allows disabling Next.js default redirects for
adding or removing trailing slashes allowing custom handling inside middleware
which can allow maintaining the trailing slash for some paths but not others
allowing easier incremental migrations.

    
    
    module.exports = {
      skipTrailingSlashRedirect: true,
    };
    
    
    const legacyPrefixes = ['/docs', '/blog'];
     
    export default async function middleware(req) {
      const { pathname } = req.nextUrl;
     
      if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
        return NextResponse.next();
      }
     
      // apply trailing slash handling
      if (
        !pathname.endsWith('/') &&
        !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
      ) {
        req.nextUrl.pathname += '/';
        return NextResponse.redirect(req.nextUrl);
      }
    }

`skipMiddlewareUrlNormalize` allows disabling the URL normalizing Next.js does
to make handling direct visits and client-transitions the same. There are some
advanced cases where you need full control using the original URL which this
unlocks.

    
    
    module.exports = {
      skipMiddlewareUrlNormalize: true,
    };
    
    
    export default async function middleware(req) {
      const { pathname } = req.nextUrl;
     
      // GET /_next/data/build-id/hello.json
     
      console.log(pathname);
      // with the flag this now /_next/data/build-id/hello.json
      // without the flag this would be normalized to /hello
    }

Version| Changes  
---|---  
`v13.1.0`| Advanced Middleware flags added  
`v13.0.0`| Middleware can modify request headers, response headers, and send
responses  
`v12.2.0`| Middleware is stable, please see the upgrade guide  
`v12.0.9`| Enforce absolute URLs in Edge Runtime (PR)  
`v12.0.0`| Middleware (Beta) added





# Rendering

By default, Next.js **pre-renders** every page. This means that Next.js
generates HTML for each page in advance, instead of having it all done by
client-side JavaScript. Pre-rendering can result in better performance and
SEO.

Each generated HTML is associated with minimal JavaScript code necessary for
that page. When a page is loaded by the browser, its JavaScript code runs and
makes the page fully interactive (this process is called hydration in React).

Next.js has two forms of pre-rendering: **Static Generation** and **Server-
side Rendering**. The difference is in **when** it generates the HTML for a
page.

  * Static Generation: The HTML is generated at **build time** and will be reused on each request.
  * Server-side Rendering: The HTML is generated on **each request**.

Importantly, Next.js lets you choose which pre-rendering form you'd like to
use for each page. You can create a "hybrid" Next.js app by using Static
Generation for most pages and using Server-side Rendering for others.

We recommend using Static Generation over Server-side Rendering for
performance reasons. Statically generated pages can be cached by CDN with no
extra configuration to boost performance. However, in some cases, Server-side
Rendering might be the only option.

You can also use client-side data fetching along with Static Generation or
Server-side Rendering. That means some parts of a page can be rendered
entirely by clientside JavaScript. To learn more, take a look at the Data
Fetching documentation.





Using Pages Router

Features available in /pages





# Static Site Generation (SSG)

 **Examples**

If a page uses **Static Generation** , the page HTML is generated at **build
time**. That means in production, the page HTML is generated when you run
`next build`. This HTML will then be reused on each request. It can be cached
by a CDN.

In Next.js, you can statically generate pages **with or without data**. Let's
take a look at each case.

By default, Next.js pre-renders pages using Static Generation without fetching
data. Here's an example:

    
    
    function About() {
      return <div>About</div>;
    }
     
    export default About;

Note that this page does not need to fetch any external data to be pre-
rendered. In cases like this, Next.js generates a single HTML file per page
during build time.

Some pages require fetching external data for pre-rendering. There are two
scenarios, and one or both might apply. In each case, you can use these
functions that Next.js provides:

  1. Your page **content** depends on external data: Use `getStaticProps`.
  2. Your page **paths** depend on external data: Use `getStaticPaths` (usually in addition to `getStaticProps`).

**Example** : Your blog page might need to fetch the list of blog posts from a
CMS (content management system).

    
    
    // TODO: Need to fetch `posts` (by calling some API endpoint)
    //       before this page can be pre-rendered.
    export default function Blog({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li>{post.title}</li>
          ))}
        </ul>
      );
    }

To fetch this data on pre-render, Next.js allows you to `export` an `async`
function called `getStaticProps` from the same file. This function gets called
at build time and lets you pass fetched data to the page's `props` on pre-
render.

    
    
    export default function Blog({ posts }) {
      // Render posts...
    }
     
    // This function gets called at build time
    export async function getStaticProps() {
      // Call an external API endpoint to get posts
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // By returning { props: { posts } }, the Blog component
      // will receive `posts` as a prop at build time
      return {
        props: {
          posts,
        },
      };
    }

To learn more about how `getStaticProps` works, check out the Data Fetching
documentation.

Next.js allows you to create pages with **dynamic routes**. For example, you
can create a file called `pages/posts/[id].js` to show a single blog post
based on `id`. This will allow you to show a blog post with `id: 1` when you
access `posts/1`.

> To learn more about dynamic routing, check the Dynamic Routing
> documentation.

However, which `id` you want to pre-render at build time might depend on
external data.

**Example** : suppose that you've only added one blog post (with `id: 1`) to
the database. In this case, you'd only want to pre-render `posts/1` at build
time.

Later, you might add the second post with `id: 2`. Then you'd want to pre-
render `posts/2` as well.

So your page **paths** that are pre-rendered depend on external data**.** To
handle this, Next.js lets you `export` an `async` function called
`getStaticPaths` from a dynamic page (`pages/posts/[id].js` in this case).
This function gets called at build time and lets you specify which paths you
want to pre-render.

    
    
    // This function gets called at build time
    export async function getStaticPaths() {
      // Call an external API endpoint to get posts
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // Get the paths we want to pre-render based on posts
      const paths = posts.map((post) => ({
        params: { id: post.id },
      }));
     
      // We'll pre-render only these paths at build time.
      // { fallback: false } means other routes should 404.
      return { paths, fallback: false };
    }

Also in `pages/posts/[id].js`, you need to export `getStaticProps` so that you
can fetch the data about the post with this `id` and use it to pre-render the
page:

    
    
    export default function Post({ post }) {
      // Render post...
    }
     
    export async function getStaticPaths() {
      // ...
    }
     
    // This also gets called at build time
    export async function getStaticProps({ params }) {
      // params contains the post `id`.
      // If the route is like /posts/1, then params.id is 1
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      // Pass post data to the page via props
      return { props: { post } };
    }

To learn more about how `getStaticPaths` works, check out the Data Fetching
documentation.

We recommend using **Static Generation** (with and without data) whenever
possible because your page can be built once and served by CDN, which makes it
much faster than having a server render the page on every request.

You can use Static Generation for many types of pages, including:

  * Marketing pages
  * Blog posts and portfolios
  * E-commerce product listings
  * Help and documentation

You should ask yourself: "Can I pre-render this page **ahead** of a user's
request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is **not** a good idea if you cannot pre-
render a page ahead of a user's request. Maybe your page shows frequently
updated data, and the page content changes on every request.

In cases like this, you can do one of the following:

  * Use Static Generation with **Client-side data fetching:** You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.
  * Use **Server-Side Rendering:** Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.





# Incremental Static Regeneration (ISR)

 **Examples**

Next.js allows you to create or update static pages _after_ you’ve built your
site. Incremental Static Regeneration (ISR) enables you to use static-
generation on a per-page basis, **without needing to rebuild the entire
site**. With ISR, you can retain the benefits of static while scaling to
millions of pages.

> **Note** : The `edge` runtime is currently not compatible with ISR, although
> you can leverage `stale-while-revalidate` by setting the `cache-control`
> header manually.

To use ISR, add the `revalidate` prop to `getStaticProps`:

    
    
    function Blog({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      );
    }
     
    // This function gets called at build time on server-side.
    // It may be called again, on a serverless function, if
    // revalidation is enabled and a new request comes in
    export async function getStaticProps() {
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      return {
        props: {
          posts,
        },
        // Next.js will attempt to re-generate the page:
        // - When a request comes in
        // - At most once every 10 seconds
        revalidate: 10, // In seconds
      };
    }
     
    // This function gets called at build time on server-side.
    // It may be called again, on a serverless function, if
    // the path has not been generated.
    export async function getStaticPaths() {
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // Get the paths we want to pre-render based on posts
      const paths = posts.map((post) => ({
        params: { id: post.id },
      }));
     
      // We'll pre-render only these paths at build time.
      // { fallback: 'blocking' } will server-render pages
      // on-demand if the path doesn't exist.
      return { paths, fallback: 'blocking' };
    }
     
    export default Blog;

When a request is made to a page that was pre-rendered at build time, it will
initially show the cached page.

  * Any requests to the page after the initial request and before 10 seconds are also cached and instantaneous.
  * After the 10-second window, the next request will still show the cached (stale) page
  * Next.js triggers a regeneration of the page in the background.
  * Once the page generates successfully, Next.js will invalidate the cache and show the updated page. If the background regeneration fails, the old page would still be unaltered.

When a request is made to a path that hasn’t been generated, Next.js will
server-render the page on the first request. Future requests will serve the
static file from the cache. ISR on Vercel persists the cache globally and
handles rollbacks.

> **Note** : Check if your upstream data provider has caching enabled by
> default. You might need to disable (e.g. `useCdn: false`), otherwise a
> revalidation won't be able to pull fresh data to update the ISR cache.
> Caching can occur at a CDN (for an endpoint being requested) when it returns
> the `Cache-Control` header.

If you set a `revalidate` time of `60`, all visitors will see the same
generated version of your site for one minute. The only way to invalidate the
cache is from someone visiting that page after the minute has passed.

Starting with `v12.2.0`, Next.js supports On-Demand Incremental Static
Regeneration to manually purge the Next.js cache for a specific page. This
makes it easier to update your site when:

  * Content from your headless CMS is created or updated
  * Ecommerce metadata changes (price, description, category, reviews, etc.)

Inside `getStaticProps`, you do not need to specify `revalidate` to use on-
demand revalidation. If `revalidate` is omitted, Next.js will use the default
value of `false` (no revalidation) and only revalidate the page on-demand when
`revalidate()` is called.

> **Note** : Middleware won't be executed for On-Demand ISR requests. Instead,
> call `revalidate()` on the _exact_ path that you want revalidated. For
> example, if you have `pages/blog/[slug].js` and a rewrite from `/post-1` ->
> `/blog/post-1`, you would need to call `res.revalidate('/blog/post-1')`.

First, create a secret token only known by your Next.js app. This secret will
be used to prevent unauthorized access to the revalidation API Route. You can
access the route (either manually or with a webhook) with the following URL
structure:

    
    
    https://<your-site.com>/api/revalidate?secret=<token>

Next, add the secret as an Environment Variable to your application. Finally,
create the revalidation API Route:

    
    
    export default async function handler(req, res) {
      // Check for secret to confirm this is a valid request
      if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
        return res.status(401).json({ message: 'Invalid token' });
      }
     
      try {
        // this should be the actual path not a rewritten path
        // e.g. for "/blog/[slug]" this should be "/blog/post-1"
        await res.revalidate('/path-to-revalidate');
        return res.json({ revalidated: true });
      } catch (err) {
        // If there was an error, Next.js will continue
        // to show the last successfully generated page
        return res.status(500).send('Error revalidating');
      }
    }

View our demo to see on-demand revalidation in action and provide feedback.

When running locally with `next dev`, `getStaticProps` is invoked on every
request. To verify your on-demand ISR configuration is correct, you will need
to create a production build and start the production server:

    
    
    $ next build
    $ next start

Then, you can confirm that static pages have successfully revalidated.

If there is an error inside `getStaticProps` when handling background
regeneration, or you manually throw an error, the last successfully generated
page will continue to show. On the next subsequent request, Next.js will retry
calling `getStaticProps`.

    
    
    export async function getStaticProps() {
      // If this request throws an uncaught error, Next.js will
      // not invalidate the currently shown page and
      // retry getStaticProps on the next request.
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      if (!res.ok) {
        // If there is a server error, you might want to
        // throw an error instead of returning so that the cache is not updated
        // until the next successful request.
        throw new Error(`Failed to fetch posts, received status ${res.status}`);
      }
     
      // If the request was successful, return the posts
      // and revalidate every 10 seconds.
      return {
        props: {
          posts,
        },
        revalidate: 10,
      };
    }

Incremental Static Regeneration (ISR) works on self-hosted Next.js sites out
of the box when you use `next start`.

You can use this approach when deploying to container orchestrators such as
Kubernetes or HashiCorp Nomad. By default, generated assets will be stored in-
memory on each pod. This means that each pod will have its own copy of the
static files. Stale data may be shown until that specific pod is hit by a
request.

To ensure consistency across all pods, you can disable in-memory caching. This
will inform the Next.js server to only leverage assets generated by ISR in the
file system.

You can use a shared network mount in your Kubernetes pods (or similar setup)
to reuse the same file-system cache between different containers. By sharing
the same mount, the `.next` folder which contains the `next/image` cache will
also be shared and re-used.

To disable in-memory caching, set `isrMemoryCacheSize` to `0` in your
`next.config.js` file:

    
    
    module.exports = {
      experimental: {
        // Defaults to 50MB
        isrMemoryCacheSize: 0,
      },
    };

> **Note** : You might need to consider a race condition between multiple pods
> trying to update the cache at the same time, depending on how your shared
> mount is configured.

Version| Changes  
---|---  
`v12.2.0`| On-Demand ISR is stable  
`v12.1.0`| On-Demand ISR added (beta).  
`v12.0.0`| Bot-aware ISR fallback added.  
`v9.5.0`| Base Path added.



  
  
# Automatic Static Optimization

Next.js automatically determines that a page is static (can be prerendered) if
it has no blocking data requirements. This determination is made by the
absence of `getServerSideProps` and `getInitialProps` in the page.

This feature allows Next.js to emit hybrid applications that contain **both
server-rendered and statically generated pages**.

> Statically generated pages are still reactive: Next.js will hydrate your
> application client-side to give it full interactivity.

One of the main benefits of this feature is that optimized pages require no
server-side computation, and can be instantly streamed to the end-user from
multiple CDN locations. The result is an _ultra fast_ loading experience for
your users.

If `getServerSideProps` or `getInitialProps` is present in a page, Next.js
will switch to render the page on-demand, per-request (meaning Server-Side
Rendering).

If the above is not the case, Next.js will **statically optimize** your page
automatically by prerendering the page to static HTML.

During prerendering, the router's `query` object will be empty since we do not
have `query` information to provide during this phase. After hydration,
Next.js will trigger an update to your application to provide the route
parameters in the `query` object.

The cases where the query will be updated after hydration triggering another
render are:

  * The page is a dynamic-route.
  * The page has query values in the URL.
  * Rewrites are configured in your `next.config.js` since these can have parameters that may need to be parsed and provided in the `query`.

To be able to distinguish if the query is fully updated and ready for use, you
can leverage the `isReady` field on `next/router`.

> **Note** : Parameters added with dynamic routes to a page that's using
> `getStaticProps` will always be available inside the `query` object.

`next build` will emit `.html` files for statically optimized pages. For
example, the result for the page `pages/about.js` would be:

    
    
    .next/server/pages/about.html

And if you add `getServerSideProps` to the page, it will then be JavaScript,
like so:

    
    
    .next/server/pages/about.js

  * If you have a custom `App` with `getInitialProps` then this optimization will be turned off in pages without Static Generation.
  * If you have a custom `Document` with `getInitialProps` be sure you check if `ctx.req` is defined before assuming the page is server-side rendered. `ctx.req` will be `undefined` for pages that are prerendered.
  * Avoid using the `asPath` value on `next/router` in the rendering tree until the router's `isReady` field is `true`. Statically optimized pages only know `asPath` on the client and not the server, so using it as a prop may lead to mismatch errors. The `active-class-name` example demonstrates one way to use `asPath` as a prop.





Using Pages Router

Features available in /pages





# Edge and Node.js Runtimes

In the context of Next.js, "runtime" refers to the set of libraries, APIs, and
general functionality available to your code during execution.

Next.js has two server runtimes where you can render parts of your application
code:

Each runtime has its own set of APIs. Please refer to the Node.js Docs and
Edge Docs for the full list of available APIs. Both runtimes can also support
streaming depending on your deployment infrastructure.

By default, the `app` directory uses the Node.js runtime. However, you can opt
into different runtimes (e.g. Edge) on a per-route basis.

There are many considerations to make when choosing a runtime. This table
shows the major differences at a glance. If you want a more in-depth analysis
of the differences, check out the sections below.

| Node| Serverless| Edge  
---|---|---|---  
Cold Boot| /| ~250ms| Instant  
HTTP Streaming| Yes| Yes| Yes  
IO| All| All| `fetch`  
Scalability| /| High| Highest  
Security| Normal| High| High  
Latency| Normal| Low| Lowest  
npm Packages| All| All| A smaller subset  
  
In Next.js, the lightweight Edge Runtime is a subset of available Node.js
APIs.

The Edge Runtime is ideal if you need to deliver dynamic, personalized content
at low latency with small, simple functions. The Edge Runtime's speed comes
from its minimal use of resources, but that can be limiting in many scenarios.

For example, code executed in the Edge Runtime on Vercel cannot exceed between
1 MB and 4 MB, this limit includes imported packages, fonts and files, and
will vary depending on your deployment infrastructure.

Using the Node.js runtime gives you access to all Node.js APIs, and all npm
packages that rely on them. However, it's not as fast to start up as routes
using the Edge runtime.

Deploying your Next.js application to a Node.js server will require managing,
scaling, and configuring your infrastructure. Alternatively, you can consider
deploying your Next.js application to a serverless platform like Vercel, which
will handle this for you.

Serverless is ideal if you need a scalable solution that can handle more
complex computational loads than the Edge Runtime. With Serverless Functions
on Vercel, for example, your overall code size is 50MB including imported
packages, fonts, and files.

The downside compared to routes using the Edge is that it can take hundreds of
milliseconds for Serverless Functions to boot up before they begin processing
requests. Depending on the amount of traffic your site receives, this could be
a frequent occurrence as the functions are not frequently "warm".





Using Pages Router

Features available in /pages





# getStaticProps

If you export a function called `getStaticProps` (Static Site Generation) from
a page, Next.js will pre-render this page at build time using the props
returned by `getStaticProps`.

    
    
    import type { InferGetStaticPropsType, GetStaticProps } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getStaticProps: GetStaticProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetStaticPropsType<typeof getStaticProps>) {
      return repo.stargazers_count;
    }

> Note that irrespective of rendering type, any `props` will be passed to the
> page component and can be viewed on the client-side in the initial HTML.
> This is to allow the page to be hydrated correctly. Make sure that you don't
> pass any sensitive information that shouldn't be available on the client in
> `props`.

You should use `getStaticProps` if:

  * The data required to render the page is available at build time ahead of a user’s request
  * The data comes from a headless CMS
  * The page must be pre-rendered (for SEO) and be very fast — `getStaticProps` generates `HTML` and `JSON` files, both of which can be cached by a CDN for performance
  * The data can be publicly cached (not user-specific). This condition can be bypassed in certain specific situation by using a Middleware to rewrite the path.

`getStaticProps` always runs on the server and never on the client. You can
validate code written inside `getStaticProps` is removed from the client-side
bundle with this tool.

  * `getStaticProps` always runs during `next build`
  * `getStaticProps` runs in the background when using `fallback: true`
  * `getStaticProps` is called before initial render when using `fallback: blocking`
  * `getStaticProps` runs in the background when using `revalidate`
  * `getStaticProps` runs on-demand in the background when using `revalidate()`

When combined with Incremental Static Regeneration, `getStaticProps` will run
in the background while the stale page is being revalidated, and the fresh
page served to the browser.

`getStaticProps` does not have access to the incoming request (such as query
parameters or HTTP headers) as it generates static HTML. If you need access to
the request for your page, consider using Middleware in addition to
`getStaticProps`.

The following example shows how you can fetch a list of blog posts from a CMS.

    
    
    // posts will be populated at build time by getStaticProps()
    export default function Blog({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li>{post.title}</li>
          ))}
        </ul>
      );
    }
     
    // This function gets called at build time on server-side.
    // It won't be called on client-side, so you can even do
    // direct database queries.
    export async function getStaticProps() {
      // Call an external API endpoint to get posts.
      // You can use any data fetching library
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // By returning { props: { posts } }, the Blog component
      // will receive `posts` as a prop at build time
      return {
        props: {
          posts,
        },
      };
    }

The `getStaticProps` API reference covers all parameters and props that can be
used with `getStaticProps`.

As `getStaticProps` runs only on the server-side, it will never run on the
client-side. It won’t even be included in the JS bundle for the browser, so
you can write direct database queries without them being sent to browsers.

This means that instead of fetching an **API route** from `getStaticProps`
(that itself fetches data from an external source), you can write the server-
side code directly in `getStaticProps`.

Take the following example. An API route is used to fetch some data from a
CMS. That API route is then called directly from `getStaticProps`. This
produces an additional call, reducing performance. Instead, the logic for
fetching the data from the CMS can be shared by using a `lib/` directory. Then
it can be shared with `getStaticProps`.

    
    
    // The following function is shared
    // with getStaticProps and API routes
    // from a `lib/` directory
    export async function loadPosts() {
      // Call an external API endpoint to get posts
      const res = await fetch('https://.../posts/');
      const data = await res.json();
     
      return data;
    }
     
    // pages/blog.js
    import { loadPosts } from '../lib/load-posts';
     
    // This function runs only on the server side
    export async function getStaticProps() {
      // Instead of fetching your `/api` route you can call the same
      // function directly in `getStaticProps`
      const posts = await loadPosts();
     
      // Props returned will be passed to the page component
      return { props: { posts } };
    }

Alternatively, if you are **not** using API routes to fetch data, then the
`fetch()` API _can_ be used directly in `getStaticProps` to fetch data.

To verify what Next.js eliminates from the client-side bundle, you can use the
next-code-elimination tool.

When a page with `getStaticProps` is pre-rendered at build time, in addition
to the page HTML file, Next.js generates a JSON file holding the result of
running `getStaticProps`.

This JSON file will be used in client-side routing through `next/link` or
`next/router`. When you navigate to a page that’s pre-rendered using
`getStaticProps`, Next.js fetches this JSON file (pre-computed at build time)
and uses it as the props for the page component. This means that client-side
page transitions will **not** call `getStaticProps` as only the exported JSON
is used.

When using Incremental Static Generation, `getStaticProps` will be executed in
the background to generate the JSON needed for client-side navigation. You may
see this in the form of multiple requests being made for the same page,
however, this is intended and has no impact on end-user performance.

`getStaticProps` can only be exported from a **page**. You **cannot** export
it from non-page files, `_app`, `_document`, or `_error`.

One of the reasons for this restriction is that React needs to have all the
required data before the page is rendered.

Also, you must use export `getStaticProps` as a standalone function — it will
**not** work if you add `getStaticProps` as a property of the page component.

> **Note** : if you have created a custom app, ensure you are passing the
> `pageProps` to the page component as shown in the linked document, otherwise
> the props will be empty.

In development (`next dev`), `getStaticProps` will be called on every request.

You can temporarily bypass static generation and render the page at **request
time** instead of build time using **Preview Mode**. For example, you might be
using a headless CMS and want to preview drafts before they're published.





# getStaticPaths

If a page has Dynamic Routes and uses `getStaticProps`, it needs to define a
list of paths to be statically generated.

When you export a function called `getStaticPaths` (Static Site Generation)
from a page that uses dynamic routes, Next.js will statically pre-render all
the paths specified by `getStaticPaths`.

    
    
    import type {
      InferGetStaticPropsType,
      GetStaticProps,
      GetStaticPaths,
    } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getStaticPaths: GetStaticPaths = async () => {
      return {
        paths: [
          {
            params: {
              name: 'next.js',
            },
          }, // See the "paths" section below
        ],
        fallback: true, // false or "blocking"
      };
    };
     
    export const getStaticProps: GetStaticProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetStaticPropsType<typeof getStaticProps>) {
      return repo.stargazers_count;
    }

The `getStaticPaths` API reference covers all parameters and props that can be
used with `getStaticPaths`.

You should use `getStaticPaths` if you’re statically pre-rendering pages that
use dynamic routes and:

  * The data comes from a headless CMS
  * The data comes from a database
  * The data comes from the filesystem
  * The data can be publicly cached (not user-specific)
  * The page must be pre-rendered (for SEO) and be very fast — `getStaticProps` generates `HTML` and `JSON` files, both of which can be cached by a CDN for performance

`getStaticPaths` will only run during build in production, it will not be
called during runtime. You can validate code written inside `getStaticPaths`
is removed from the client-side bundle with this tool.

  * `getStaticProps` runs during `next build` for any `paths` returned during build
  * `getStaticProps` runs in the background when using `fallback: true`
  * `getStaticProps` is called before initial render when using `fallback: blocking`

  * `getStaticPaths` **must** be used with `getStaticProps`
  * You **cannot** use `getStaticPaths` with `getServerSideProps`
  * You can export `getStaticPaths` from a Dynamic Route that also uses `getStaticProps`
  * You **cannot** export `getStaticPaths` from non-page file (e.g. your `components` folder)
  * You must export `getStaticPaths` as a standalone function, and not a property of the page component

In development (`next dev`), `getStaticPaths` will be called on every request.

`getStaticPaths` allows you to control which pages are generated during the
build instead of on-demand with `fallback`. Generating more pages during a
build will cause slower builds.

You can defer generating all pages on-demand by returning an empty array for
`paths`. This can be especially helpful when deploying your Next.js
application to multiple environments. For example, you can have faster builds
by generating all pages on-demand for previews (but not production builds).
This is helpful for sites with hundreds/thousands of static pages.

    
    
    export async function getStaticPaths() {
      // When this is true (in preview environments) don't
      // prerender any static pages
      // (faster builds, but slower initial page load)
      if (process.env.SKIP_BUILD_STATIC_GENERATION) {
        return {
          paths: [],
          fallback: 'blocking',
        };
      }
     
      // Call an external API endpoint to get posts
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // Get the paths we want to prerender based on posts
      // In production environments, prerender all pages
      // (slower builds, but faster initial page load)
      const paths = posts.map((post) => ({
        params: { id: post.id },
      }));
     
      // { fallback: false } means other routes should 404
      return { paths, fallback: false };
    }





# getServerSideProps

If you export a function called `getServerSideProps` (Server-Side Rendering)
from a page, Next.js will pre-render this page on each request using the data
returned by `getServerSideProps`.

    
    
    import type { InferGetServerSidePropsType, GetServerSideProps } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getServerSideProps: GetServerSideProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetServerSidePropsType<typeof getServerSideProps>) {
      return repo.stargazers_count;
    }

> Note that irrespective of rendering type, any `props` will be passed to the
> page component and can be viewed on the client-side in the initial HTML.
> This is to allow the page to be hydrated correctly. Make sure that you don't
> pass any sensitive information that shouldn't be available on the client in
> `props`.

`getServerSideProps` only runs on server-side and never runs on the browser.
If a page uses `getServerSideProps`, then:

  * When you request this page directly, `getServerSideProps` runs at request time, and this page will be pre-rendered with the returned props
  * When you request this page on client-side page transitions through `next/link` or `next/router`, Next.js sends an API request to the server, which runs `getServerSideProps`

`getServerSideProps` returns JSON which will be used to render the page. All
this work will be handled automatically by Next.js, so you don’t need to do
anything extra as long as you have `getServerSideProps` defined.

You can use the next-code-elimination tool to verify what Next.js eliminates
from the client-side bundle.

`getServerSideProps` can only be exported from a **page**. You can’t export it
from non-page files.

Note that you must export `getServerSideProps` as a standalone function — it
will **not** work if you add `getServerSideProps` as a property of the page
component.

The `getServerSideProps` API reference covers all parameters and props that
can be used with `getServerSideProps`.

You should use `getServerSideProps` only if you need to render a page whose
data must be fetched at request time. This could be due to the nature of the
data or properties of the request (such as `authorization` headers or geo
location). Pages using `getServerSideProps` will be server side rendered at
request time and only be cached if cache-control headers are configured.

If you do not need to render the data during the request, then you should
consider fetching data on the client side or `getStaticProps`.

It can be tempting to reach for an API Route when you want to fetch data from
the server, then call that API route from `getServerSideProps`. This is an
unnecessary and inefficient approach, as it will cause an extra request to be
made due to both `getServerSideProps` and API Routes running on the server.

Take the following example. An API route is used to fetch some data from a
CMS. That API route is then called directly from `getServerSideProps`. This
produces an additional call, reducing performance. Instead, directly import
the logic used inside your API Route into `getServerSideProps`. This could
mean calling a CMS, database, or other API directly from inside
`getServerSideProps`.

`getServerSideProps` can be used with both Serverless and Edge Runtimes, and
you can set props in both. However, currently in the Edge Runtime, you do not
have access to the response object. This means that you cannot — for example —
add cookies in `getServerSideProps`. To have access to the response object,
you should **continue to use the Node.js runtime** , which is the default
runtime.

You can explicitly set the runtime on a per-page basis by modifying the
`config`, for example:

    
    
    export const config = {
      runtime: 'nodejs', // or "edge"
    };
     
    export const getServerSideProps = async () => {};

If your page contains frequently updating data, and you don’t need to pre-
render the data, you can fetch the data on the client side. An example of this
is user-specific data:

  * First, immediately show the page without data. Parts of the page can be pre-rendered using Static Generation. You can show loading states for missing data
  * Then, fetch the data on the client side and display it when ready

This approach works well for user dashboard pages, for example. Because a
dashboard is a private, user-specific page, SEO is not relevant and the page
doesn’t need to be pre-rendered. The data is frequently updated, which
requires request-time data fetching.

The following example shows how to fetch data at request time and pre-render
the result.

    
    
    function Page({ data }) {
      // Render data...
    }
     
    // This gets called on every request
    export async function getServerSideProps() {
      // Fetch data from external API
      const res = await fetch(`https://.../data`);
      const data = await res.json();
     
      // Pass data to the page via props
      return { props: { data } };
    }
     
    export default Page;

You can use caching headers (`Cache-Control`) inside `getServerSideProps` to
cache dynamic responses. For example, using `stale-while-revalidate`.

    
    
    // This value is considered fresh for ten seconds (s-maxage=10).
    // If a request is repeated within the next 10 seconds, the previously
    // cached value will still be fresh. If the request is repeated before 59 seconds,
    // the cached value will be stale but still render (stale-while-revalidate=59).
    //
    // In the background, a revalidation request will be made to populate the cache
    // with a fresh value. If you refresh the page, you will see the new value.
    export async function getServerSideProps({ req, res }) {
      res.setHeader(
        'Cache-Control',
        'public, s-maxage=10, stale-while-revalidate=59',
      );
     
      return {
        props: {},
      };
    }

Learn more about caching.

If an error is thrown inside `getServerSideProps`, it will show the
`pages/500.js` file. Check out the documentation for 500 page to learn more on
how to create it. During development this file will not be used and the dev
overlay will be shown instead.





# Incremental Static Regeneration

 **Examples** **Version History** Version| Changes  
---|---  
`v12.2.0`| On-Demand ISR is stable  
`v12.1.0`| On-Demand ISR added (beta).  
`v12.0.0`| Bot-aware ISR fallback added.  
`v9.5.0`| Base Path added.  
  
Next.js allows you to create or update static pages _after_ you’ve built your
site. Incremental Static Regeneration (ISR) enables you to use static-
generation on a per-page basis, **without needing to rebuild the entire
site**. With ISR, you can retain the benefits of static while scaling to
millions of pages.

> **Note** : The `edge` runtime is currently not compatible with ISR, although
> you can leverage `stale-while-revalidate` by setting the `cache-control`
> header manually.

To use ISR, add the `revalidate` prop to `getStaticProps`:

    
    
    function Blog({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      );
    }
     
    // This function gets called at build time on server-side.
    // It may be called again, on a serverless function, if
    // revalidation is enabled and a new request comes in
    export async function getStaticProps() {
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      return {
        props: {
          posts,
        },
        // Next.js will attempt to re-generate the page:
        // - When a request comes in
        // - At most once every 10 seconds
        revalidate: 10, // In seconds
      };
    }
     
    // This function gets called at build time on server-side.
    // It may be called again, on a serverless function, if
    // the path has not been generated.
    export async function getStaticPaths() {
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // Get the paths we want to pre-render based on posts
      const paths = posts.map((post) => ({
        params: { id: post.id },
      }));
     
      // We'll pre-render only these paths at build time.
      // { fallback: 'blocking' } will server-render pages
      // on-demand if the path doesn't exist.
      return { paths, fallback: 'blocking' };
    }
     
    export default Blog;

When a request is made to a page that was pre-rendered at build time, it will
initially show the cached page.

  * Any requests to the page after the initial request and before 10 seconds are also cached and instantaneous.
  * After the 10-second window, the next request will still show the cached (stale) page
  * Next.js triggers a regeneration of the page in the background.
  * Once the page generates successfully, Next.js will invalidate the cache and show the updated page. If the background regeneration fails, the old page would still be unaltered.

When a request is made to a path that hasn’t been generated, Next.js will
server-render the page on the first request. Future requests will serve the
static file from the cache. ISR on Vercel persists the cache globally and
handles rollbacks.

> **Note** : Check if your upstream data provider has caching enabled by
> default. You might need to disable (e.g. `useCdn: false`), otherwise a
> revalidation won't be able to pull fresh data to update the ISR cache.
> Caching can occur at a CDN (for an endpoint being requested) when it returns
> the `Cache-Control` header.

If you set a `revalidate` time of `60`, all visitors will see the same
generated version of your site for one minute. The only way to invalidate the
cache is from someone visiting that page after the minute has passed.

Starting with `v12.2.0`, Next.js supports On-Demand Incremental Static
Regeneration to manually purge the Next.js cache for a specific page. This
makes it easier to update your site when:

  * Content from your headless CMS is created or updated
  * Ecommerce metadata changes (price, description, category, reviews, etc.)

Inside `getStaticProps`, you do not need to specify `revalidate` to use on-
demand revalidation. If `revalidate` is omitted, Next.js will use the default
value of `false` (no revalidation) and only revalidate the page on-demand when
`revalidate()` is called.

> **Note** : Middleware won't be executed for On-Demand ISR requests. Instead,
> call `revalidate()` on the _exact_ path that you want revalidated. For
> example, if you have `pages/blog/[slug].js` and a rewrite from `/post-1` ->
> `/blog/post-1`, you would need to call `res.revalidate('/blog/post-1')`.

First, create a secret token only known by your Next.js app. This secret will
be used to prevent unauthorized access to the revalidation API Route. You can
access the route (either manually or with a webhook) with the following URL
structure:

    
    
    https://<your-site.com>/api/revalidate?secret=<token>

Next, add the secret as an Environment Variable to your application. Finally,
create the revalidation API Route:

    
    
    export default async function handler(req, res) {
      // Check for secret to confirm this is a valid request
      if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
        return res.status(401).json({ message: 'Invalid token' });
      }
     
      try {
        // this should be the actual path not a rewritten path
        // e.g. for "/blog/[slug]" this should be "/blog/post-1"
        await res.revalidate('/path-to-revalidate');
        return res.json({ revalidated: true });
      } catch (err) {
        // If there was an error, Next.js will continue
        // to show the last successfully generated page
        return res.status(500).send('Error revalidating');
      }
    }

View our demo to see on-demand revalidation in action and provide feedback.

When running locally with `next dev`, `getStaticProps` is invoked on every
request. To verify your on-demand ISR configuration is correct, you will need
to create a production build and start the production server:

    
    
    $ next build
    $ next start

Then, you can confirm that static pages have successfully revalidated.

If there is an error inside `getStaticProps` when handling background
regeneration, or you manually throw an error, the last successfully generated
page will continue to show. On the next subsequent request, Next.js will retry
calling `getStaticProps`.

    
    
    export async function getStaticProps() {
      // If this request throws an uncaught error, Next.js will
      // not invalidate the currently shown page and
      // retry getStaticProps on the next request.
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      if (!res.ok) {
        // If there is a server error, you might want to
        // throw an error instead of returning so that the cache is not updated
        // until the next successful request.
        throw new Error(`Failed to fetch posts, received status ${res.status}`);
      }
     
      // If the request was successful, return the posts
      // and revalidate every 10 seconds.
      return {
        props: {
          posts,
        },
        revalidate: 10,
      };
    }

Incremental Static Regeneration (ISR) works on self-hosted Next.js sites out
of the box when you use `next start`.

You can use this approach when deploying to container orchestrators such as
Kubernetes or HashiCorp Nomad. By default, generated assets will be stored in-
memory on each pod. This means that each pod will have its own copy of the
static files. Stale data may be shown until that specific pod is hit by a
request.

To ensure consistency across all pods, you can disable in-memory caching. This
will inform the Next.js server to only leverage assets generated by ISR in the
file system.

You can use a shared network mount in your Kubernetes pods (or similar setup)
to reuse the same file-system cache between different containers. By sharing
the same mount, the `.next` folder which contains the `next/image` cache will
also be shared and re-used.

To disable in-memory caching, set `isrMemoryCacheSize` to `0` in your
`next.config.js` file:

    
    
    module.exports = {
      experimental: {
        // Defaults to 50MB
        isrMemoryCacheSize: 0,
      },
    };

> **Note** : You might need to consider a race condition between multiple pods
> trying to update the cache at the same time, depending on how your shared
> mount is configured.





# Client-side Fetching

Client-side data fetching is useful when your page doesn't require SEO
indexing, when you don't need to pre-render your data, or when the content of
your pages needs to update frequently. Unlike the server-side rendering APIs,
you can use client-side data fetching at the component level.

If done at the page level, the data is fetched at runtime, and the content of
the page is updated as the data changes. When used at the component level, the
data is fetched at the time of the component mount, and the content of the
component is updated as the data changes.

It's important to note that using client-side data fetching can affect the
performance of your application and the load speed of your pages. This is
because the data fetching is done at the time of the component or pages mount,
and the data is not cached.

The following example shows how you can fetch data on the client side using
the useEffect hook.

    
    
    import { useState, useEffect } from 'react';
     
    function Profile() {
      const [data, setData] = useState(null);
      const [isLoading, setLoading] = useState(false);
     
      useEffect(() => {
        setLoading(true);
        fetch('/api/profile-data')
          .then((res) => res.json())
          .then((data) => {
            setData(data);
            setLoading(false);
          });
      }, []);
     
      if (isLoading) return <p>Loading...</p>;
      if (!data) return <p>No profile data</p>;
     
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.bio}</p>
        </div>
      );
    }

The team behind Next.js has created a React hook library for data fetching
called **SWR**. It is **highly recommended** if you are fetching data on the
client-side. It handles caching, revalidation, focus tracking, refetching on
intervals, and more.

Using the same example as above, we can now use SWR to fetch the profile data.
SWR will automatically cache the data for us and will revalidate the data if
it becomes stale.

For more information on using SWR, check out the SWR docs.

    
    
    import useSWR from 'swr';
     
    const fetcher = (...args) => fetch(...args).then((res) => res.json());
     
    function Profile() {
      const { data, error } = useSWR('/api/profile-data', fetcher);
     
      if (error) return <div>Failed to load</div>;
      if (!data) return <div>Loading...</div>;
     
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.bio}</p>
        </div>
      );
    }





# Building Forms

A web form has a **client-server** relationship. They are used to send data
handled by a web server for processing and storage. The form itself is the
client, and the server is any storage mechanism that can be used to store,
retrieve and send data when needed.

This guide will teach you how to create a web form with Next.js.

HTML forms are built using the `<form>` tag. It takes a set of attributes and
fields to structure the form for features like text fields, checkboxes,
dropdown menus, buttons, radio buttons, etc.

Here's the syntax of an HTML form:

    
    
    <!-- Basic HTML Form -->
    <form action="/send-data-here" method="post">
      <label for="first">First name:</label>
      <input type="text" id="first" name="first" />
      <label for="last">Last name:</label>
      <input type="text" id="last" name="last" />
      <button type="submit">Submit</button>
    </form>

The front-end looks like this:

![html
forms](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/html-forms.png)

The HTML `<form>` tag acts as a container for different `<input>` elements
like `text` field and submit `button`. Let's study each of these elements:

  * `action`: An attribute that specifies where the form data is sent when the form is submitted. It's generally a URL (an absolute URL or a relative URL).
  * `method`: Specifies the HTTP method, i.e., `GET` or `POST` used to send data while submitting the form.
  * `<label>`: An element that defines the label for other form elements. Labels aid accessibility, especially for screen readers.
  * `<input>`: The form element that is widely used to structure the form fields. It depends significantly on the value of the `type` attribute. Input types can be `text`, `checkbox`, `email`, `radio`, and more.
  * `<button>`: Represents a clickable button that's used to submit the form data.

A process that checks if the information provided by a user is correct or not.
Form validation also ensures that the provided information is in the correct
format (e.g. there's an @ in the email field). These are of two types:

  * **Client-side** : Validation is done in the browser
  * **Server-side** : Validation is done on the server

Though both of these types are equally important, this guide will focus on
client-side validation only.

Client-side validation is further categorized as:

  * **Built-in** : Uses HTML-based attributes like `required`, `type`, `minLength`, `maxLength`, `pattern`, etc.
  * **JavaScript-based** : Validation that's coded with JavaScript.

  * `required`: Specifies which fields must be filled before submitting the form.
  * `type`: Specifies the data's type (i.e a number, email address, string, etc).
  * `minLength`: Specifies minimum length for the text data string.
  * `maxLength`: Specifies maximum length for the text data string.

So, a form using this attributes may look like:

    
    
    <!-- HTML Form with Built-in Validation -->
    <form action="/send-data-here" method="post">
      <label for="roll">Roll Number</label>
      <input
        type="text"
        id="roll"
        name="roll"
        required
        minlength="10"
        maxlength="20"
      />
      <label for="name">Name:</label>
      <input type="text" id="name" name="name" required />
      <button type="submit">Submit</button>
    </form>

With these validation checks in place, when a user tries to submit an empty
field for Name, it gives an error that pops right in the form field.
Similarly, a roll number can only be entered if it's 10-20 characters long.

![form
validation](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/form-validation.jpg)

Form Validation is important to ensure that a user has submitted the correct
data, in a correct format. JavaScript offers an additional level of validation
along with HTML native form attributes on the client side. Developers
generally prefer validating form data through JavaScript because its data
processing is faster when compared to server-side validation, however front-
end validation may be less secure in some scenarios as a malicious user could
always send malformed data to your server.

The following example shows using JavaScript to validate a form:

    
    
    <form onsubmit="validateFormWithJS()">
      <label for="rollNumber">Roll Number:</label>
      <input type="text" name="rollNumber" id="rollNumber" />
     
      <label for="name">Name:</label>
      <input type="text" name="name" id="name" />
     
      <button type="submit">Submit</button>
    </form>
     
    <script>
      function validateFormWithJS() {
        const name = document.querySelector('#name').value;
        const rollNumber = document.querySelector('#rollNumber').value;
     
        if (!name) {
          alert('Please enter your name.');
          return false;
        }
     
        if (rollNumber.length < 3) {
          alert('Roll Number should be at least 3 digits long.');
          return false;
        }
      }
    </script>

The HTML script tag is used to embed any client-side JavaScript. It can either
contain inline scripting statements (as shown in the example above) or point
to an external script file via the `src` attribute. This example validates the
name and roll number of a user. The `validateFormWithJS()` function does not
allow an empty name field, and the roll number must be at least three digits
long. The validation is performed when you hit the Submit button. You are not
redirected to the next page until the given values are correct.

![js-
validation](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/js-validation.jpg)

JavaScript validation with Regular Expressions uses the `pattern` HTML
attribute. A regular expression (commonly known as RegEx) is an object that
describes a pattern of characters. You can only apply the `pattern` attribute
to the `<input>` element. This way, you can validate the input value using
Regular Expressions (RegEx) by defining your own rules. Once again, if the
value does not match the defined pattern, the input will give an error. The
below example shows using the `pattern` attribute on an `input` element:

    
    
    <form action="/action_page.php">
      <label for="pswrd">Password:</label>
      <input
        type="password"
        id="pswrd"
        name="pswrd"
        pattern="[a-z0-9]{1,15}"
        title="Password should be digits (0 to 9) or alphabets (a to z)."
      />
     
      <button type="submit">Submit</button>
    </form>

The password form field must only contain digits (0 to 9), lowercase alphabets
(a to z) and it must be no more than 15 characters in length. No other
characters (#,$,&, etc.) are allowed. The rule in RegEx is written as
`[a-z0-9]{1,15}`.

![form-validate-
regex](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/form-validate-regex.jpg)

> To learn more about HTML forms, check out the MDN Web Docs.

In the following section you will be creating forms in React using Next.js.

Create a new Next.js app. You can use the create-next-app for a quick start.
In your command line terminal, run the following:

Answer the questions to create your project, and give it a name, this example
uses `next-forms`. Next `cd` into this directory, and run `npm run dev` or
`yarn dev` command to start the development server.

Open the URL printed in the terminal to ensure that your app is running
successfully.

Both the client and the server will be built using Next.js. For the server
part, create an API endpoint where you will send the form data.

Next.js offers a file-based system for routing that's built on the concept of
pages. Any file inside the folder `pages/api` is mapped to `/api/*` and will
be treated as an API endpoint instead of a page. This API endpoint is going to
be server-side only.

Go to `pages/api`, create a file called `form.js` and paste this code written
in Node.js:

    
    
    export default function handler(req, res) {
      // Get data submitted in request's body.
      const body = req.body;
     
      // Optional logging to see the responses
      // in the command line where next.js app is running.
      console.log('body: ', body);
     
      // Guard clause checks for first and last name,
      // and returns early if they are not found
      if (!body.first || !body.last) {
        // Sends a HTTP bad request error code
        return res.status(400).json({ data: 'First or last name not found' });
      }
     
      // Found the name.
      // Sends a HTTP success code
      res.status(200).json({ data: `${body.first} ${body.last}` });
    }

This form `handler` function will receive the request `req` from the client
(i.e. submitted form data). And in return, it'll send a response `res` as JSON
that will have both the first and the last name. You can access this API
endpoint at `http://localhost:3000/api/form` or replace the localhost URL with
an actual Vercel deployment when you deploy.

> Moreover, you can also attach this API to a database like MongoDB or Google
> Sheets. This way, your submitted form data will be securely stored for later
> use. For this guide, no database is used. Instead, the same data is returned
> to the user to demo how it's done.

You can now use `/api/form` relative endpoint inside the `action` attribute of
the form. You are sending form data to the server when the form is submitted
via `POST` HTTP method (which is used to send data).

    
    
    <form action="/api/form" method="post">
      <label for="first">First name:</label>
      <input type="text" id="first" name="first" />
      <label for="last">Last name:</label>
      <input type="text" id="last" name="last" />
      <button type="submit">Submit</button>
    </form>

If you submit this form, it will submit the data to the forms API endpoint
`/api/form`. The server then responds, generally handling the data and loading
the URL defined by the action attribute, causing a new page load. So in this
case you'll be redirected to `http://localhost:3000/api/form` with the
following response from the server.

![form-no-
js](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/form-no-js.jpg)

You have created a Next.js API Route for form submission. Now it's time to
configure the client (the form itself) inside Next.js using React. The first
step will be extending your knowledge of HTML forms and converting it into
React (using JSX).

Here's the same form in a React function component written using JSX.

    
    
    export default function Form() {
      return (
        <form action="/api/form" method="post">
          <label htmlFor="first">First Name</label>
          <input type="text" id="first" name="first" required />
     
          <label htmlFor="last">Last Name</label>
          <input type="text" id="last" name="last" required />
     
          <button type="submit">Submit</button>
        </form>
      );
    }

Here's what changed:

  * The `for` attribute is changed to `htmlFor`. (Since `for` is a keyword associated with the "for" loop in JavaScript, React elements use `htmlFor` instead.)
  * The `action` attribute now has a relative URL which is the form API endpoint.

This completes the basic structure of your Next.js-based form.

> You can view the entire source code of next-forms example repo that we're
> creating here as a working example. Feel free to clone it and start right
> away. This demo is built with create-next-app, and you can preview the basic
> form CSS styles inside `/styles/global.css` file.

![forms with
nextjs](https://assets.vercel.com/image/upload/dpr_auto,q_auto,f_auto/nextjs/guides/building-
forms/forms-with-nextjs.png)

JavaScript brings interactivity to our web applications, but sometimes you
need to control the JavaScript bundle from being too large, or your sites
visitors might have JavaScript disabled.

There are several reasons why users disable JavaScript:

  * Addressing bandwidth constraints
  * Increasing device (phone or laptop) battery life
  * For privacy so they won’t be tracked with analytical scripts

Regardless of the reason, disabling JavaScript will impact site functionality
partially, if not completely.

Next open the `next-forms` directory. Inside the `/pages` directory, create a
file `no-js-form.js`.

> **Quick Tip** : In Next.js, a page is a React Component exported from a
> `.js`, `.jsx`, `.ts`, or `.tsx` file in the Pages Router. Each page is
> associated with a route based on its file name.
>
> Example: If you create `pages/no-js-form.js`, it will be accessible at
> `your-domain.tld/no-js-form`.

Let's use the same code from above:

    
    
    export default function PageWithoutJSbasedForm() {
      return (
        <form action="/api/form" method="post">
          <label htmlFor="first">First Name</label>
          <input type="text" id="first" name="first" required />
     
          <label htmlFor="last">Last Name</label>
          <input type="text" id="last" name="last" required />
     
          <button type="submit">Submit</button>
        </form>
      );
    }

With JavaScript disabled, when you hit the Submit button, an event is
triggered, which collects the form data and sends it to our forms API endpoint
as defined in the `action` attribute and using `POST` HTTP `method`. You'll be
redirected to the `/api/form` endpoint since that's how form `action` works.

The form data will be submitted on the server as a request `req` to the form
handler function written above. It will process the data and return a JSON
string as a response `res` with your submitted name included.

> To improve the experience here, as a response you can redirect the user to a
> page and thank them for submitting the form.

Inside `/pages`, you'll create another file called `js-form.js`. This will
create a `/js-form` page on your Next.js app.

Now, as soon as the form is submitted, we prevent the form's default behavior
of reloading the page. We'll take the form data, convert it to JSON string,
and send it to our server, the API endpoint. Finally, our server will respond
with the name submitted. All of this with a basic JavaScript `handleSubmit()`
function.

Here's what this function looks like. It's well documented for you to
understand each step:

    
    
    export default function PageWithJSbasedForm() {
      // Handles the submit event on form submit.
      const handleSubmit = async (event) => {
        // Stop the form from submitting and refreshing the page.
        event.preventDefault();
     
        // Get data from the form.
        const data = {
          first: event.target.first.value,
          last: event.target.last.value,
        };
     
        // Send the data to the server in JSON format.
        const JSONdata = JSON.stringify(data);
     
        // API endpoint where we send form data.
        const endpoint = '/api/form';
     
        // Form the request for sending data to the server.
        const options = {
          // The method is POST because we are sending data.
          method: 'POST',
          // Tell the server we're sending JSON.
          headers: {
            'Content-Type': 'application/json',
          },
          // Body of the request is the JSON data we created above.
          body: JSONdata,
        };
     
        // Send the form data to our forms API on Vercel and get a response.
        const response = await fetch(endpoint, options);
     
        // Get the response data from server as JSON.
        // If server returns the name submitted, that means the form works.
        const result = await response.json();
        alert(`Is this your full name: ${result.data}`);
      };
      return (
        // We pass the event to the handleSubmit() function on submit.
        <form onSubmit={handleSubmit}>
          <label htmlFor="first">First Name</label>
          <input type="text" id="first" name="first" required />
     
          <label htmlFor="last">Last Name</label>
          <input type="text" id="last" name="last" required />
     
          <button type="submit">Submit</button>
        </form>
      );
    }

It's a Next.js page with a React function component called
`PageWithJSbasedForm` with a `<form>` element written in JSX. There's no
action on the `<form>` element. Instead, we use the `onSubmit` event handler
to send data to our `{handleSubmit}` function.

The `handleSubmit()` function processes your form data through a series of
steps:

  * The `event.preventDefault()` stops the `<form>` element from refreshing the entire page.
  * We created a JavaScript object called `data` with the `first` and `last` values from the form.
  * JSON is a language-agnostic data transfer format. So we use `JSON.stringify(data)` to convert the data to JSON.
  * We then use `fetch()` to send the data to our `/api/form` endpoint using JSON and HTTP `POST` method.
  * Server sends back a response with the name submitted. Woohoo! 🥳

This guide has covered the following:

  * The basic HTML `form` element
  * Understanding forms with React.js
  * Validating forms data with and without JavaScript
  * Using Next.js API Routes to handle `req` and `res` from the client and server

For more details go through Next.js Learn Course.





Using Pages Router

Features available in /pages





# CSS Modules

 **Examples**

Next.js has built-in support for CSS Modules using the `.module.css`
extension.

CSS Modules locally scope CSS by automatically creating a unique class name.
This allows you to use the same class name in different files without worrying
about collisions. This behavior makes CSS Modules the ideal way to include
component-level CSS.

For example, consider a reusable `Button` component in the `components/`
folder:

First, create `components/Button.module.css` with the following content:

    
    
    /*
    You do not need to worry about .error {} colliding with any other `.css` or
    `.module.css` files!
    */
    .error {
      color: white;
      background-color: red;
    }

Then, create `components/Button.js`, importing and using the above CSS file:

    
    
    import styles from './Button.module.css';
     
    export function Button() {
      return (
        <button
          type="button"
          // Note how the "error" class is accessed as a property on the imported
          // `styles` object.
          className={styles.error}
        >
          Destroy
        </button>
      );
    }

CSS Modules are an _optional feature_ and are **only enabled for files with
the`.module.css` extension**. Regular `<link>` stylesheets and global CSS
files are still supported.

In production, all CSS Module files will be automatically concatenated into
**many minified and code-split** `.css` files. These `.css` files represent
hot execution paths in your application, ensuring the minimal amount of CSS is
loaded for your application to paint.

To add a stylesheet to your application, import the CSS file within
`pages/_app.js`.

For example, consider the following stylesheet named `styles.css`:

    
    
    body {
      font-family: 'SF Pro Text', 'SF Pro Icons', 'Helvetica Neue', 'Helvetica',
        'Arial', sans-serif;
      padding: 20px 20px 60px;
      max-width: 680px;
      margin: 0 auto;
    }

Create a `pages/_app.js` file if not already present. Then, `import` the
`styles.css` file.

    
    
    import '../styles.css';
     
    // This default export is required in a new `pages/_app.js` file.
    export default function MyApp({ Component, pageProps }) {
      return <Component {...pageProps} />;
    }

These styles (`styles.css`) will apply to all pages and components in your
application. Due to the global nature of stylesheets, and to avoid conflicts,
you may **only import them inside`pages/_app.js`**.

In development, expressing stylesheets this way allows your styles to be hot
reloaded as you edit them—meaning you can keep application state.

In production, all CSS files will be automatically concatenated into a single
minified `.css` file.

Next.js allows you to import CSS files from a JavaScript file. This is
possible because Next.js extends the concept of `import` beyond JavaScript.

Since Next.js **9.5.4** , importing a CSS file from `node_modules` is
permitted anywhere in your application.

For global stylesheets, like `bootstrap` or `nprogress`, you should import the
file inside `pages/_app.js`. For example:

    
    
    import 'bootstrap/dist/css/bootstrap.css';
     
    export default function MyApp({ Component, pageProps }) {
      return <Component {...pageProps} />;
    }

For importing CSS required by a third-party component, you can do so in your
component. For example:

    
    
    import { useState } from 'react';
    import { Dialog } from '@reach/dialog';
    import VisuallyHidden from '@reach/visually-hidden';
    import '@reach/dialog/styles.css';
     
    function ExampleDialog(props) {
      const [showDialog, setShowDialog] = useState(false);
      const open = () => setShowDialog(true);
      const close = () => setShowDialog(false);
     
      return (
        <div>
          <button onClick={open}>Open Dialog</button>
          <Dialog isOpen={showDialog} onDismiss={close}>
            <button className="close-button" onClick={close}>
              <VisuallyHidden>Close</VisuallyHidden>
              <span aria-hidden>×</span>
            </button>
            <p>Hello there. I am a dialog</p>
          </Dialog>
        </div>
      );
    }

Next.js includes additional features to improve the authoring experience of
adding styles:

  * When running locally with `next dev`, local stylesheets (either global or CSS modules) will take advantage of Fast Refresh to instantly reflect changes as edits are saved.
  * When building for production with `next build`, CSS files will be bundled into fewer minified `.css` files to reduce the number of network requests needed to retrieve styles.
  * If you disable JavaScript, styles will still be loaded in the production build (`next start`). However, JavaScript is still required for `next dev` to enable Fast Refresh.





# Tailwind CSS

 **Examples**

Tailwind CSS is a utility-first CSS framework that works exceptionally well
with Next.js.

Install the Tailwind CSS packages and run the `init` command to generate both
the `tailwind.config.js` and `postcss.config.js` files:

    
    
    npm install -D tailwindcss postcss autoprefixer
    npx tailwindcss init -p

Inside `tailwind.config.js`, add paths to the files that will use Tailwind CSS
class names:

    
    
    /** @type {import('tailwindcss').Config} */
    module.exports = {
      content: [
        './app/**/*.{js,ts,jsx,tsx,mdx}', // Note the addition of the `app` directory.
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
     
        // Or if using `src` directory:
        './src/**/*.{js,ts,jsx,tsx,mdx}',
      ],
      theme: {
        extend: {},
      },
      plugins: [],
    };

You do not need to modify `postcss.config.js`.

Add the Tailwind CSS directives that Tailwind will use to inject its generated
styles to a Global Stylesheet in your application, for example:

    
    
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

Inside the root layout (`app/layout.tsx`), import the `globals.css` stylesheet
to apply the styles to every route in your application.

    
    
    import type { Metadata } from 'next';
     
    // These styles apply to every route in the application
    import './globals.css';
     
    export const metadata: Metadata = {
      title: 'Create Next App',
      description: 'Generated by create next app',
    };
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

After installing Tailwind CSS and adding the global styles, you can use
Tailwind's utility classes in your application.

    
    
    export default function Page() {
      return <h1 className="text-3xl font-bold underline">Hello, Next.js!</h1>;
    }

As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.





Using Pages Router

Features available in /pages





> **Good to know** :
>
> Sass supports two different syntax, each with their own extension. The
> `.scss` extension requires you use the SCSS syntax, while the `.sass`
> extension requires you use the Indented Syntax ("Sass").
>
> If you're not sure which to choose, start with the `.scss` extension which
> is a superset of CSS, and doesn't require you learn the Indented Syntax
> ("Sass").
    
    
    const path = require('path');
     
    module.exports = {
      sassOptions: {
        includePaths: [path.join(__dirname, 'styles')],
      },
    };

Next.js supports Sass variables exported from CSS Module files.

    
    
    import variables from '../styles/variables.module.scss';
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <Layout color={variables.primaryColor}>
          <Component {...pageProps} />
        </Layout>
      );
    }





# Optimizations

Next.js comes with a variety of built-in optimizations designed to improve
your application's speed and Core Web Vitals. This guide will cover the
optimizations you can leverage to enhance your user experience.

Built-in components abstract away the complexity of implementing common UI
optimizations. These components are:

  * **Images** : Built on the native `<img>` element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.
  * **Link** : Built on the native `<a>` tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.
  * **Scripts** : Built on the native `<script>` tags. The Script Component gives you control over loading and execution of third-party scripts.

Metadata helps search engines understand your content better (which can result
in better SEO), and allows you to customize how your content is presented on
social media, helping you create a more engaging and consistent user
experience across various platforms.

The Head Component in Next.js allows you to modify the `<head>` of a page.
Learn more in the Head Component documentation.

Next.js `/public` folder can be used to serve static assets like images,
fonts, and other files. Files inside `/public` can also be cached by CDN
providers so that they are delivered efficiently.

For large applications, Next.js integrates with popular analytics and
monitoring tools to help you understand how your application is performing.
Learn more in the Analytics, OpenTelemetry, and Instrumentation guides.





# Image Optimization

 **Examples**

The Next.js Image component extends the HTML `<img>` element with:

  * **Size Optimization:** Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
  * **Visual Stability:** Prevent layout shift automatically when images are loading.
  * **Faster Page Loads:** Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
  * **Asset Flexibility:** On-demand image resizing, even for images stored on remote servers

    
    
    import Image from 'next/image';

You can then define the `src` for your image (either local or remote).

To use a local image, `import` your `.jpg`, `.png`, or `.webp` image files.

Next.js will automatically determine the `width` and `height` of your image
based on the imported file. These values are used to prevent Cumulative Layout
Shift while your image is loading.

    
    
    import Image from 'next/image';
    import profilePic from '../public/me.png';
     
    export default function Page() {
      return (
        <Image
          src={profilePic}
          alt="Picture of the author"
          // width={500} automatically provided
          // height={500} automatically provided
          // blurDataURL="data:..." automatically provided
          // placeholder="blur" // Optional blur-up while loading
        />
      );
    }

> **Warning:** Dynamic `await import()` or `require()` are _not_ supported.
> The `import` must be static so it can be analyzed at build time.

To use a remote image, the `src` property should be a URL string.

Since Next.js does not have access to remote files during the build process,
you'll need to provide the `width`, `height` and optional `blurDataURL` props
manually.

The `width` and `height` attributes are used to infer the correct aspect ratio
of image and avoid layout shift from the image loading in. The `width` and
`height` do _not_ determine the rendered size of the image file. Learn more
about Image Sizing.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <Image
          src="https://s3.amazonaws.com/my-bucket/profile.png"
          alt="Picture of the author"
          width={500}
          height={500}
        />
      );
    }

To safely allow optimizing images, define a list of supported URL patterns in
`next.config.js`. Be as specific as possible to prevent malicious usage. For
example, the following configuration will only allow images from a specific
AWS S3 bucket:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 's3.amazonaws.com',
            port: '',
            pathname: '/my-bucket/**',
          },
        ],
      },
    };

Learn more about `remotePatterns` configuration. If you want to use relative
URLs for the image `src`, use a `loader`.

Sometimes you may want to optimize a remote image, but still use the built-in
Next.js Image Optimization API. To do this, leave the `loader` at its default
setting and enter an absolute URL for the Image `src` prop.

To protect your application from malicious users, you must define a list of
remote hostnames you intend to use with the `next/image` component.

> Learn more about `remotePatterns` configuration.

Note that in the example earlier, a partial URL (`"/me.png"`) is provided for
a remote image. This is possible because of the loader architecture.

A loader is a function that generates the URLs for your image. It modifies the
provided `src`, and generates multiple URLs to request the image at different
sizes. These multiple URLs are used in the automatic srcset generation, so
that visitors to your site will be served an image that is the right size for
their viewport.

The default loader for Next.js applications uses the built-in Image
Optimization API, which optimizes images from anywhere on the web, and then
serves them directly from the Next.js web server. If you would like to serve
your images directly from a CDN or image server, you can write your own loader
function with a few lines of JavaScript.

You can define a loader per-image with the `loader` prop, or at the
application level with the `loaderFile` configuration.

You should add the `priority` property to the image that will be the Largest
Contentful Paint (LCP) element for each page. Doing so allows Next.js to
specially prioritize the image for loading (e.g. through preload tags or
priority hints), leading to a meaningful boost in LCP.

The LCP element is typically the largest image or text block visible within
the viewport of the page. When you run `next dev`, you'll see a console
warning if the LCP element is an `<Image>` without the `priority` property.

Once you've identified the LCP image, you can add the property like this:

    
    
    import Image from 'next/image';
     
    export default function Home() {
      return (
        <>
          <h1>My Homepage</h1>
          <Image
            src="/me.png"
            alt="Picture of the author"
            width={500}
            height={500}
            priority
          />
          <p>Welcome to my homepage!</p>
        </>
      );
    }

See more about priority in the `next/image` component documentation.

One of the ways that images most commonly hurt performance is through _layout
shift_ , where the image pushes other elements around on the page as it loads
in. This performance problem is so annoying to users that it has its own Core
Web Vital, called Cumulative Layout Shift. The way to avoid image-based layout
shifts is to always size your images. This allows the browser to reserve
precisely enough space for the image before it loads.

Because `next/image` is designed to guarantee good performance results, it
cannot be used in a way that will contribute to layout shift, and **must** be
sized in one of three ways:

  1. Automatically, using a static import
  2. Explicitly, by including a `width` and `height` property
  3. Implicitly, by using fill which causes the image to expand to fill its parent element.

> **What if I don't know the size of my images?**
>
> If you are accessing images from a source without knowledge of the images'
> sizes, there are several things you can do:
>
> **Use`fill`**
>
> The `fill` prop allows your image to be sized by its parent element.
> Consider using CSS to give the image's parent element space on the page
> along `sizes` prop to match any media query break points. You can also use
> `object-fit` with `fill`, `contain`, or `cover`, and `object-position` to
> define how the image should occupy that space.
>
> **Normalize your images**
>
> If you're serving images from a source that you control, consider modifying
> your image pipeline to normalize the images to a specific size.
>
> **Modify your API calls**
>
> If your application is retrieving image URLs using an API call (such as to a
> CMS), you may be able to modify the API call to return the image dimensions
> along with the URL.

If none of the suggested methods works for sizing your images, the
`next/image` component is designed to work well on a page alongside standard
`<img>` elements.

Styling the Image component is similar to styling a normal `<img>` element,
but there are a few guidelines to keep in mind:

  * Use `className` or `style`, not `styled-jsx`. 
    * In most cases, we recommend using the `className` prop. This can be an imported CSS Module, a global stylesheet, etc.
    * You can also use the `style` prop to assign inline styles.
    * You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as `global`).
  * When using `fill`, the parent element must have `position: relative`
    * This is necessary for the proper rendering of the image element in that layout mode.
  * When using `fill`, the parent element must have `display: block`
    * This is the default for `<div>` elements but should be specified otherwise.

For examples, see the Image Component Demo.

For examples of the Image component used with the various styles, see the
Image Component Demo.

**View all properties available to the`next/image` component.**

The `next/image` component and Next.js Image Optimization API can be
configured in the `next.config.js` file. These configurations allow you to
enable remote images, define custom image breakpoints, change caching behavior
and more.

**Read the full image configuration documentation for more information.**





# Font Optimization

 **`next/font`** will automatically optimize your fonts (including custom
fonts) and remove external network requests for improved privacy and
performance.

> **🎥 Watch:** Learn more about how to use `next/font` → YouTube (6 minutes).

`next/font` includes **built-in automatic self-hosting** for _any_ font file.
This means you can optimally load web fonts with zero layout shift, thanks to
the underlying CSS `size-adjust` property used.

This new font system also allows you to conveniently use all Google Fonts with
performance and privacy in mind. CSS and font files are downloaded at build
time and self-hosted with the rest of your static assets. **No requests are
sent to Google by the browser.**

Automatically self-host any Google Font. Fonts are included in the deployment
and served from the same domain as your deployment. **No requests are sent to
Google by the browser.**

Get started by importing the font you would like to use from
`next/font/google` as a function. We recommend using variable fonts for the
best performance and flexibility.

To use the font in all your pages, add it to `_app.js` file under `/pages` as
shown below:

    
    
    import { Inter } from 'next/font/google';
     
    // If loading a variable font, you don't need to specify the font weight
    const inter = Inter({ subsets: ['latin'] });
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <main className={inter.className}>
          <Component {...pageProps} />
        </main>
      );
    }

If you can't use a variable font, you will **need to specify a weight** :

    
    
    import { Roboto } from 'next/font/google';
     
    const roboto = Roboto({
      weight: '400',
      subsets: ['latin'],
    });
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <main className={roboto.className}>
          <Component {...pageProps} />
        </main>
      );
    }

You can specify multiple weights and/or styles by using an array:

    
    
    const roboto = Roboto({
      weight: ['400', '700'],
      style: ['normal', 'italic'],
      subsets: ['latin'],
      display: 'swap',
    });

> **Good to know** : Use an underscore (_) for font names with multiple words.
> E.g. `Roboto Mono` should be imported as `Roboto_Mono`.

You can also use the font without a wrapper and `className` by injecting it
inside the `<head>` as follows:

    
    
    import { Inter } from 'next/font/google';
     
    const inter = Inter({ subsets: ['latin'] });
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <>
          <style jsx global>{`
            html {
              font-family: ${inter.style.fontFamily};
            }
          `}</style>
          <Component {...pageProps} />
        </>
      );
    }

To use the font on a single page, add it to the specific page as shown below:

    
    
    import { Inter } from 'next/font/google';
     
    const inter = Inter({ subsets: ['latin'] });
     
    export default function Home() {
      return (
        <div className={inter.className}>
          <p>Hello World</p>
        </div>
      );
    }

Google Fonts are automatically subset. This reduces the size of the font file
and improves performance. You'll need to define which of these subsets you
want to preload. Failing to specify any subsets while `preload` is `true` will
result in a warning.

This can be done by adding it to the function call:

    
    
    const inter = Inter({ subsets: ['latin'] });

View the Font API Reference for more information.

You can import and use multiple fonts in your application. There are two
approaches you can take.

The first approach is to create a utility function that exports a font,
imports it, and applies its `className` where needed. This ensures the font is
preloaded only when it's rendered:

    
    
    import { Inter, Roboto_Mono } from 'next/font/google';
     
    export const inter = Inter({
      subsets: ['latin'],
      display: 'swap',
    });
     
    export const roboto_mono = Roboto_Mono({
      subsets: ['latin'],
      display: 'swap',
    });

In the example above, `Inter` will be applied globally, and `Roboto Mono` can
be imported and applied as needed.

Alternatively, you can create a CSS variable and use it with your preferred
CSS solution:

    
    
    html {
      font-family: var(--font-inter);
    }
     
    h1 {
      font-family: var(--font-roboto-mono);
    }

In the example above, `Inter` will be applied globally, and any `<h1>` tags
will be styled with `Roboto Mono`.

> **Recommendation** : Use multiple fonts conservatively since each new font
> is an additional resource the client has to download.

Import `next/font/local` and specify the `src` of your local font file. We
recommend using variable fonts for the best performance and flexibility.

    
    
    import localFont from 'next/font/local';
     
    // Font files can be colocated inside of `pages`
    const myFont = localFont({ src: './my-font.woff2' });
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <main className={myFont.className}>
          <Component {...pageProps} />
        </main>
      );
    }

If you want to use multiple files for a single font family, `src` can be an
array:

    
    
    const roboto = localFont({
      src: [
        {
          path: './Roboto-Regular.woff2',
          weight: '400',
          style: 'normal',
        },
        {
          path: './Roboto-Italic.woff2',
          weight: '400',
          style: 'italic',
        },
        {
          path: './Roboto-Bold.woff2',
          weight: '700',
          style: 'normal',
        },
        {
          path: './Roboto-BoldItalic.woff2',
          weight: '700',
          style: 'italic',
        },
      ],
    });

View the Font API Reference for more information.

`next/font` can be used with Tailwind CSS through a CSS variable.

In the example below, we use the font `Inter` from `next/font/google` (you can
use any font from Google or Local Fonts). Load your font with the `variable`
option to define your CSS variable name and assign it to `inter`. Then, use
`inter.variable` to add the CSS variable to your HTML document.

    
    
    import { Inter } from 'next/font/google';
     
    const inter = Inter({
      subsets: ['latin'],
      variable: '--font-inter',
    });
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <main className={`${inter.variable} font-sans`}>
          <Component {...pageProps} />
        </main>
      );
    }

Finally, add the CSS variable to your Tailwind CSS config:

    
    
    /** @type {import('tailwindcss').Config} */
    module.exports = {
      content: [
        './pages/**/*.{js,ts,jsx,tsx}',
        './components/**/*.{js,ts,jsx,tsx}',
      ],
      theme: {
        extend: {
          fontFamily: {
            sans: ['var(--font-inter)'],
            mono: ['var(--font-roboto-mono)'],
          },
        },
      },
      plugins: [],
    };

You can now use the `font-sans` and `font-mono` utility classes to apply the
font to your elements.

When a font function is called on a page of your site, it is not globally
available and preloaded on all routes. Rather, the font is only preloaded on
the related route/s based on the type of file where it is used:

  * if it's a unique page, it is preloaded on the unique route for that page
  * if it's in the custom App, it is preloaded on all the routes of the site under `/pages`

Every time you call the `localFont` or Google font function, that font is
hosted as one instance in your application. Therefore, if you load the same
font function in multiple files, multiple instances of the same font are
hosted. In this situation, it is recommended to do the following:

  * Call the font loader function in one shared file
  * Export it as a constant
  * Import the constant in each file where you would like to use this font





# Script Optimization

To load a third-party script for all routes, import `next/script` and include
the script directly in your custom `_app`:

    
    
    import Script from 'next/script';
     
    export default function MyApp({ Component, pageProps }) {
      return (
        <>
          <Component {...pageProps} />
          <Script src="https://example.com/script.js" />
        </>
      );
    }

This script will load and execute when _any_ route in your application is
accessed. Next.js will ensure the script will **only load once** , even if a
user navigates between multiple pages.

> **Recommendation** : We recommend only including third-party scripts in
> specific pages or layouts in order to minimize any unnecessary impact to
> performance.

Although the default behavior of `next/script` allows you load third-party
scripts in any page or layout, you can fine-tune its loading behavior by using
the `strategy` property:

  * `beforeInteractive`: Load the script before any Next.js code and before any page hydration occurs.
  * `afterInteractive`: ( **default** ) Load the script early but after some hydration on the page occurs.
  * `lazyOnload`: Load the script later during browser idle time.
  * `worker`: (experimental) Load the script in a web worker.

Refer to the `next/script` API reference documentation to learn more about
each strategy and their use cases.

> **Warning:** The `worker` strategy is not yet stable and does not yet work
> with the `app` directory. Use with caution.

Scripts that use the `worker` strategy are offloaded and executed in a web
worker with Partytown. This can improve the performance of your site by
dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the
`nextScriptWorkers` flag is enabled in `next.config.js`:

    
    
    module.exports = {
      experimental: {
        nextScriptWorkers: true,
      },
    };

Then, run `next` (normally `npm run dev` or `yarn dev`) and Next.js will guide
you through the installation of the required packages to finish the setup:

You'll see instructions like these: Please install Partytown by running `npm
install @builder.io/partytown`

Once setup is complete, defining `strategy="worker"` will automatically
instantiate Partytown in your application and offload the script to a web
worker.

    
    
    import Script from 'next/script';
     
    export default function Home() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="worker" />
        </>
      );
    }

There are a number of trade-offs that need to be considered when loading a
third-party script in a web worker. Please see Partytown's tradeoffs
documentation for more information.

Inline scripts, or scripts not loaded from an external file, are also
supported by the Script component. They can be written by placing the
JavaScript within curly braces:

    
    
    <Script id="show-banner">
      {`document.getElementById('banner').classList.remove('hidden')`}
    </Script>

Or by using the `dangerouslySetInnerHTML` property:

    
    
    <Script
      id="show-banner"
      dangerouslySetInnerHTML={{
        __html: `document.getElementById('banner').classList.remove('hidden')`,
      }}
    />

> **Warning** : An `id` property must be assigned for inline scripts in order
> for Next.js to track and optimize the script.

Event handlers can be used with the Script component to execute additional
code after a certain event occurs:

  * `onLoad`: Execute code after the script has finished loading.
  * `onReady`: Execute code after the script has finished loading and every time the component is mounted.
  * `onError`: Execute code if the script fails to load.

These handlers will only work when `next/script` is imported and used inside
of a Client Component where `"use client"` is defined as the first line of
code:

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            onLoad={() => {
              console.log('Script has loaded');
            }}
          />
        </>
      );
    }

Refer to the `next/script` API reference to learn more about each event
handler and view examples.

There are many DOM attributes that can be assigned to a `<script>` element
that are not used by the Script component, like `nonce` or custom data
attributes. Including any additional attributes will automatically forward it
to the final, optimized `<script>` element that is included in the HTML.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            id="example-script"
            nonce="XUENAJFW"
            data-test="script"
          />
        </>
      );
    }





Using Pages Router

Features available in /pages





# Lazy Loading

Lazy loading in Next.js helps improve the initial loading performance of an
application by decreasing the amount of JavaScript needed to render a route.

It allows you to defer loading of **Client Components** and imported
libraries, and only include them in the client bundle when they're needed. For
example, you might want to defer loading a modal until a user clicks to open
it.

There are two ways you can implement lazy loading in Next.js:

  1. Using Dynamic Imports with `next/dynamic`
  2. Using `React.lazy()` with Suspense

By default, Server Components are automatically code split, and you can use
streaming to progressively send pieces of UI from the server to the client.
Lazy loading applies to Client Components.

`next/dynamic` is a composite of `React.lazy()` and Suspense. It behaves the
same way in the `app` and `pages` directories to allow for incremental
migration.

By using `next/dynamic`, the header component will not be included in the
page's initial JavaScript bundle. The page will render the Suspense `fallback`
first, followed by the `Header` component when the `Suspense` boundary is
resolved.

    
    
    import dynamic from 'next/dynamic';
     
    const DynamicHeader = dynamic(() => import('../components/header'), {
      loading: () => <p>Loading...</p>,
    });
     
    export default function Home() {
      return <DynamicHeader />;
    }

> **Note** : In `import('path/to/component')`, the path must be explicitly
> written. It can't be a template string nor a variable. Furthermore the
> `import()` has to be inside the `dynamic()` call for Next.js to be able to
> match webpack bundles / module ids to the specific `dynamic()` call and
> preload them before rendering. `dynamic()` can't be used inside of React
> rendering as it needs to be marked in the top level of the module for
> preloading to work, similar to `React.lazy`.

To dynamically import a named export, you can return it from the Promise
returned by `import()`:

    
    
    export function Hello() {
      return <p>Hello!</p>;
    }
     
    // pages/index.js
    import dynamic from 'next/dynamic';
     
    const DynamicComponent = dynamic(() =>
      import('../components/hello').then((mod) => mod.Hello),
    );

To dynamically load a component on the client side, you can use the `ssr`
option to disable server-rendering. This is useful if an external dependency
or component relies on browser APIs like `window`.

    
    
    import dynamic from 'next/dynamic';
     
    const DynamicHeader = dynamic(() => import('../components/header'), {
      ssr: false,
    });

This example uses the external library `fuse.js` for fuzzy search. The module
is only loaded in the browser after the user types in the search input.

    
    
    import { useState } from 'react';
     
    const names = ['Tim', 'Joe', 'Bel', 'Lee'];
     
    export default function Page() {
      const [results, setResults] = useState();
     
      return (
        <div>
          <input
            type="text"
            placeholder="Search"
            onChange={async (e) => {
              const { value } = e.currentTarget;
              // Dynamically load fuse.js
              const Fuse = (await import('fuse.js')).default;
              const fuse = new Fuse(names);
     
              setResults(fuse.search(value));
            }}
          />
          <pre>Results: {JSON.stringify(results, null, 2)}</pre>
        </div>
      );
    }





# Analytics

Next.js Speed Insights allows you to analyze and measure the performance of
pages using different metrics.

You can start collecting your Real Experience Score with zero-configuration on
Vercel deployments.

The rest of this documentation describes the built-in relayer Next.js Speed
Insights uses.

First, you will need to create a custom App component and define a
`reportWebVitals` function:

    
    
    export function reportWebVitals(metric) {
      console.log(metric);
    }
     
    function MyApp({ Component, pageProps }) {
      return <Component {...pageProps} />;
    }
     
    export default MyApp;

This function is fired when the final values for any of the metrics have
finished calculating on the page. You can use to log any of the results to the
console or send to a particular endpoint.

The `metric` object returned to the function consists of a number of
properties:

  * `id`: Unique identifier for the metric in the context of the current page load
  * `name`: Metric name
  * `startTime`: First recorded timestamp of the performance entry in milliseconds (if applicable)
  * `value`: Value, or duration in milliseconds, of the performance entry
  * `label`: Type of metric (`web-vital` or `custom`)

There are two types of metrics that are tracked:

  * Web Vitals
  * Custom metrics

Web Vitals are a set of useful metrics that aim to capture the user experience
of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the `web-vital` label:

    
    
    export function reportWebVitals(metric) {
      if (metric.label === 'web-vital') {
        console.log(metric); // The metric object ({ id, name, startTime, value, label }) is logged to the console
      }
    }

There's also the option of handling each of the metrics separately:

    
    
    export function reportWebVitals(metric) {
      switch (metric.name) {
        case 'FCP':
          // handle FCP results
          break;
        case 'LCP':
          // handle LCP results
          break;
        case 'CLS':
          // handle CLS results
          break;
        case 'FID':
          // handle FID results
          break;
        case 'TTFB':
          // handle TTFB results
          break;
        case 'INP':
          // handle INP results (note: INP is still an experimental metric)
          break;
        default:
          break;
      }
    }

A third-party library, web-vitals, is used to measure these metrics. Browser
compatibility depends on the particular metric, so refer to the Browser
Support section to find out which browsers are supported.

In addition to the core metrics listed above, there are some additional custom
metrics that measure the time it takes for the page to hydrate and render:

  * `Next.js-hydration`: Length of time it takes for the page to start and finish hydrating (in ms)
  * `Next.js-route-change-to-render`: Length of time it takes for a page to start rendering after a route change (in ms)
  * `Next.js-render`: Length of time it takes for a page to finish render after a route change (in ms)

You can handle all the results of these metrics using the `custom` label:

    
    
    export function reportWebVitals(metric) {
      if (metric.label === 'custom') {
        console.log(metric); // The metric object ({ id, name, startTime, value, label }) is logged to the console
      }
    }

There's also the option of handling each of the metrics separately:

    
    
    export function reportWebVitals(metric) {
      switch (metric.name) {
        case 'Next.js-hydration':
          // handle hydration results
          break;
        case 'Next.js-route-change-to-render':
          // handle route-change to render results
          break;
        case 'Next.js-render':
          // handle render results
          break;
        default:
          break;
      }
    }

These metrics work in all browsers that support the User Timing API.

With the relay function, you can send results to any endpoint to measure and
track real user performance on your site. For example:

    
    
    export function reportWebVitals(metric) {
      const body = JSON.stringify(metric);
      const url = 'https://example.com/analytics';
     
      // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url, body);
      } else {
        fetch(url, { body, method: 'POST', keepalive: true });
      }
    }

> **Note** : If you use Google Analytics, using the `id` value can allow you
> to construct metric distributions manually (to calculate percentiles, etc.)
>  
>  
>     export function reportWebVitals({ id, name, label, value }) {
>       // Use `window.gtag` if you initialized Google Analytics as this
> example:
>       // https://github.com/vercel/next.js/blob/canary/examples/with-google-
> analytics/pages/_app.js
>       window.gtag('event', name, {
>         event_category:
>           label === 'web-vital' ? 'Web Vitals' : 'Next.js custom metric',
>         value: Math.round(name === 'CLS' ? value * 1000 : value), // values
> must be integers
>         event_label: id, // id unique to current page load
>         non_interaction: true, // avoids affecting bounce rate.
>       });
>     }
>
> Read more about sending results to Google Analytics.

If you are using TypeScript, you can use the built-in type
`NextWebVitalsMetric`:

    
    
    import type { AppProps, NextWebVitalsMetric } from 'next/app';
     
    function MyApp({ Component, pageProps }: AppProps) {
      return <Component {...pageProps} />;
    }
     
    export function reportWebVitals(metric: NextWebVitalsMetric) {
      console.log(metric);
    }
     
    export default MyApp;





# OpenTelemetry

> **Note** : This feature is experimental, you need to explicitly opt-in by
> providing `experimental.instrumentationHook = true;` in your
> `next.config.js`.

Observability is crucial for understanding and optimizing the behavior and
performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to
identify and diagnose issues that may arise. By leveraging observability
tools, such as logging and metrics, developers can gain insights into their
application's behavior and identify areas for optimization. With
observability, developers can proactively address issues before they become
major problems and provide a better user experience. Therefore, it is highly
recommended to use observability in your Next.js applications to improve
performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps. It's a platform-
agnostic way to instrument apps that allows you to change your observability
provider without changing your code. Read Official OpenTelemetry docs for more
information about OpenTelemetry and how it works.

This documentation uses terms like _Span_ , _Trace_ or _Exporter_ throughout
this doc, all of which can be found in the OpenTelemetry Observability Primer.

Next.js supports OpenTelemetry instrumentation out of the box, which means
that we already instrumented Next.js itself. When you enable OpenTelemetry we
will automatically wrap all your code like `getStaticProps` in _spans_ with
helpful attributes.

> **Note** : We currently support OpenTelemetry bindings only in serverless
> functions. We don't provide any for `edge` or client side code.

OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package `@vercel/otel` that helps you get started
quickly. It's not extensible and you should configure OpenTelemetry manually
you need to customize your setup.

To get started, you must install `@vercel/otel`:

Next, create a custom `instrumentation.ts` file in the root of the project:

    
    
    import { registerOTel } from '@vercel/otel';
     
    export function register() {
      registerOTel('next-app');
    }

> **Note** : We have created a basic with-opentelemetry example that you can
> use.

If our wrapper `@vercel/otel` doesn't suit your needs, you can configure
OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

    
    
    npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http

Now you can initialize `NodeSDK` in your `instrumentation.ts`. OpenTelemetry
APIs are not compatible with edge runtime, so you need to make sure that you
are importing them only when `process.env.NEXT_RUNTIME === 'nodejs'`. We
recommend creating a new file `instrumentation.node.ts` which you
conditionally import only when using node:

    
    
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        await import('./instrumentation.node.ts');
      }
    }
    
    
    import { trace, context } from '@opentelemetry/api';
    import { NodeSDK } from '@opentelemetry/sdk-node';
    import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
    import { Resource } from '@opentelemetry/resources';
    import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
    import { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node';
     
    const sdk = new NodeSDK({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: 'next-app',
      }),
      spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),
    });
    sdk.start();

Doing this is equivalent to using `@vercel/otel`, but it's possible to modify
and extend. For example, you could use `@opentelemetry/exporter-trace-otlp-
grpc` instead of `@opentelemetry/exporter-trace-otlp-http` or you can specify
more resource attributes.

You need an OpenTelemetry collector with a compatible backend to test
OpenTelemetry traces locally. We recommend using our OpenTelemetry dev
environment.

If everything works well you should be able to see the root server span
labeled as `GET /requested/pathname`. All other spans from that particular
trace will be nested under it.

Next.js traces more spans than are emitted by default. To see more spans, you
must set `NEXT_OTEL_VERBOSE=1`.

When you are deploying with OpenTelemetry Collector, you can use
`@vercel/otel`. It will work both on Vercel and when self-hosted.

We made sure that OpenTelemetry works out of the box on Vercel.

Follow Vercel documentation to connect your project to an observability
provider.

Deploying to other platforms is also straightforward. You will need to spin up
your own OpenTelemetry Collector to receive and process the telemetry data
from your Next.js app.

To do this, follow the OpenTelemetry Collector Getting Started guide, which
will walk you through setting up the collector and configuring it to receive
data from your Next.js app.

Once you have your collector up and running, you can deploy your Next.js app
to your chosen platform following their respective deployment guides.

We recommend using OpenTelemetry Collector. If that is not possible on your
platform, you can use a custom OpenTelemetry exporter with manual
OpenTelemetry configuration

You can add a custom span with OpenTelemetry APIs.

    
    
    npm install @opentelemetry/api

The following example demonstrates a function that fetches GitHub stars and
adds a custom `fetchGithubStars` span to track the fetch request's result:

    
    
    import { trace } from '@opentelemetry/api';
     
    export async function fetchGithubStars() {
      return await trace
        .getTracer('nextjs-example')
        .startActiveSpan('fetchGithubStars', async (span) => {
          try {
            return await getValue();
          } finally {
            span.end();
          }
        });
    }

The `register` function will execute before your code runs in a new
environment. You can start creating new spans, and they should be correctly
added to the exported trace.

Next.js automatically instruments several spans for you to provide useful
insights into your application's performance.

Attributes on spans follow OpenTelemetry semantic conventions. We also add
some custom attributes under the `next` namespace:

  * `next.span_name` \- duplicates span name
  * `next.span_type` \- each span type has a unique identifier
  * `next.route` \- The route pattern of the request (e.g., `/[param]/user`).
  * `next.page`
    * This is an internal value used by an app router.
    * You can think about it as a route to a special file (like `page.ts`, `layout.ts`, `loading.ts` and others)
    * It can be used as a unique identifier only when paired with `next.route` because `/layout` can be used to identify both `/(groupA)/layout.ts` and `/(groupB)/layout.ts`

  * `next.span_type`: `BaseServer.handleRequest`

This span represents the root span for each incoming request to your Next.js
application. It tracks the HTTP method, route, target, and status code of the
request.

Attributes:

  * `next.span_type`: `AppRender.getBodyResult`.

This span represents the process of rendering a route in the app router.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `AppRender.fetch`

This span represents the fetch request executed in your code.

Attributes:

  * `next.span_type`: `AppRouteRouteHandlers.runHandler`.

This span represents the execution of an API route handler in the app router.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.getServerSideProps`.

This span represents the execution of `getServerSideProps` for a specific
route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.getStaticProps`.

This span represents the execution of `getStaticProps` for a specific route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `Render.renderDocument`.

This span represents the process of rendering the document for a specific
route.

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.route`

  * `next.span_type`: `ResolveMetadata.generateMetadata`.

This span represents the process of generating metadata for a specific page (a
single route can have multiple of these spans).

Attributes:

  * `next.span_name`
  * `next.span_type`
  * `next.page`





# Instrumentation

> **Note** : This feature is experimental. To use it, you must explicitly opt
> in by defining `experimental.instrumentationHook = true;` in your
> `next.config.js`.

If you export a function named `register` from this file, we will call that
function whenever a new Next.js server instance is bootstrapped. When your
`register` function is deployed, it will be called on each cold boot (but
exactly once in each environment).

Sometimes, it may be useful to import a file in your code because of the side
effects it will cause. For example, you might import a file that defines a set
of global variables, but never explicitly use the imported file in your code.
You would still have access to the global variables the package has declared.

You can import files with side effects in `instrumentation.ts`, which you
might want to use in your `register` function as demonstrated in the following
example:

    
    
    import { init } from 'package-init';
     
    export function register() {
      init();
    }

However, we recommend importing files with side effects using `import` from
within your `register` function instead. The following example demonstrates a
basic usage of `import` in a `register` function:

    
    
    export async function register() {
      await import('package-with-side-effect');
    }

By doing this, you can colocate all of your side effects in one place in your
code, and avoid any unintended consequences from importing files.

We call `register` in all environments, so it's necessary to conditionally
import any code that doesn't support both `edge` and `nodejs`. You can use the
environment variable `NEXT_RUNTIME` to get the current environment. Importing
an environment-specific code would look like this:

    
    
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        await import('./instrumentation-node');
      }
     
      if (process.env.NEXT_RUNTIME === 'edge') {
        await import('./instrumentation-edge');
      }
    }





# Testing

 **Examples**

Learn how to set up Next.js with commonly used testing tools: Cypress,
Playwright, and Jest with React Testing Library.

Cypress is a test runner used for **End-to-End (E2E)** and **Component
Testing**.

You can use `create-next-app` with the with-cypress example to quickly get
started.

    
    
    npx create-next-app@latest --example with-cypress with-cypress-app

To get started with Cypress, install the `cypress` package:

    
    
    npm install --save-dev cypress

Add Cypress to the `package.json` scripts field:

    
    
    "scripts": {
      "dev": "next dev",
      "build": "next build",
      "start": "next start",
      "cypress": "cypress open",
    }

Run Cypress for the first time to generate examples that use their recommended
folder structure:

You can look through the generated examples and the Writing Your First Test
section of the Cypress Documentation to help you get familiar with Cypress.

The Cypress docs contain a guide on the difference between these two types of
tests and when it is appropriate to use each.

Assuming the following two Next.js pages:

    
    
    import Link from 'next/link';
     
    export default function Home() {
      return (
        <nav>
          <h1>Homepage</h1>
          <Link href="/about">About</Link>
        </nav>
      );
    }
    
    
    export default function About() {
      return (
        <div>
          <h1>About Page</h1>
          <Link href="/">Homepage</Link>
        </div>
      );
    }

Add a test to check your navigation is working correctly:

    
    
    describe('Navigation', () => {
      it('should navigate to the about page', () => {
        // Start from the index page
        cy.visit('http://localhost:3000/');
     
        // Find a link with an href attribute containing "about" and click it
        cy.get('a[href*="about"]').click();
     
        // The new url should include "/about"
        cy.url().should('include', '/about');
     
        // The new page should contain an h1 with "About page"
        cy.get('h1').contains('About Page');
      });
    });

You can use `cy.visit("/")` instead of `cy.visit("http://localhost:3000/")` if
you add `baseUrl: 'http://localhost:3000'` to the `cypress.config.js`
configuration file.

Component tests build and mount a specific component without having to bundle
your whole application or launch a server. This allows for more performant
tests that still provide visual feedback and the same API used for Cypress E2E
tests.

> **Note** : Since component tests do not launch a Next.js server,
> capabilities like `<Image />` and `getServerSideProps` which rely on a
> server being available will not function out-of-the-box. See the Cypress
> Next.js docs for examples of getting these features working within component
> tests.

Assuming the same components from the previous section, add a test to validate
a component is rendering the expected output:

    
    
    import AboutPage from './about.js';
     
    describe('<AboutPage />', () => {
      it('should render and display expected content', () => {
        // Mount the React component for the About page
        cy.mount(<AboutPage />);
     
        // The new page should contain an h1 with "About page"
        cy.get('h1').contains('About Page');
     
        // Validate that a link with the expected URL is present
        // *Following* the link is better suited to an E2E test
        cy.get('a[href="/"]').should('be.visible');
      });
    });

Since Cypress E2E tests are testing a real Next.js application they require
the Next.js server to be running prior to starting Cypress. We recommend
running your tests against your production code to more closely resemble how
your application will behave.

Run `npm run build` and `npm run start`, then run `npm run cypress -- --e2e`
in another terminal window to start Cypress and run your E2E testing suite.

> **Note** : Alternatively, you can install the `start-server-and-test`
> package and add it to the `package.json` scripts field: `"test": "start-
> server-and-test start http://localhost:3000 cypress"` to start the Next.js
> production server in conjunction with Cypress. Remember to rebuild your
> application after new changes.

Run `npm run cypress -- --component` to start Cypress and execute your
component testing suite.

You will have noticed that running Cypress so far has opened an interactive
browser which is not ideal for CI environments. You can also run Cypress
headlessly using the `cypress run` command:

    
    
     
    "scripts": {
      //...
      "e2e": "start-server-and-test dev http://localhost:3000 \"cypress open --e2e\"",
      "e2e:headless": "start-server-and-test dev http://localhost:3000 \"cypress run --e2e\"",
      "component": "cypress open --component",
      "component:headless": "cypress run --component"
    }

You can learn more about Cypress and Continuous Integration from these
resources:

Playwright is a testing framework that lets you automate Chromium, Firefox,
and WebKit with a single API. You can use it to write **End-to-End (E2E)** and
**Integration** tests across all platforms.

The fastest way to get started is to use `create-next-app` with the with-
playwright example. This will create a Next.js project complete with
Playwright all set up.

    
    
    npx create-next-app@latest --example with-playwright with-playwright-app

You can also use `npm init playwright` to add Playwright to an existing `NPM`
project.

To manually get started with Playwright, install the `@playwright/test`
package:

    
    
    npm install --save-dev @playwright/test

Add Playwright to the `package.json` scripts field:

    
    
    "scripts": {
      "dev": "next dev",
      "build": "next build",
      "start": "next start",
      "test:e2e": "playwright test",
    }

Assuming the following two Next.js pages:

    
    
    import Link from 'next/link';
     
    export default function Home() {
      return (
        <nav>
          <Link href="/about">About</Link>
        </nav>
      );
    }
    
    
    export default function About() {
      return (
        <div>
          <h1>About Page</h1>
        </div>
      );
    }

Add a test to verify that your navigation is working correctly:

    
    
    import { test, expect } from '@playwright/test';
     
    test('should navigate to the about page', async ({ page }) => {
      // Start from the index page (the baseURL is set via the webServer in the playwright.config.ts)
      await page.goto('http://localhost:3000/');
      // Find an element with the text 'About Page' and click on it
      await page.click('text=About');
      // The new URL should be "/about" (baseURL is used there)
      await expect(page).toHaveURL('http://localhost:3000/about');
      // The new page should contain an h1 with "About Page"
      await expect(page.locator('h1')).toContainText('About Page');
    });

You can use `page.goto("/")` instead of `page.goto("http://localhost:3000/")`,
if you add `"baseURL": "http://localhost:3000"` to the `playwright.config.ts`
configuration file.

Since Playwright is testing a real Next.js application, it requires the
Next.js server to be running prior to starting Playwright. It is recommended
to run your tests against your production code to more closely resemble how
your application will behave.

Run `npm run build` and `npm run start`, then run `npm run test:e2e` in
another terminal window to run the Playwright tests.

> **Note** : Alternatively, you can use the `webServer` feature to let
> Playwright start the development server and wait until it's fully available.

Playwright will by default run your tests in the headless mode. To install all
the Playwright dependencies, run `npx playwright install-deps`.

You can learn more about Playwright and Continuous Integration from these
resources:

Jest and React Testing Library are frequently used together for **Unit
Testing**. There are three ways you can start using Jest within your Next.js
application:

  1. Using one of our quickstart examples
  2. With the Next.js Rust Compiler
  3. With Babel

The following sections will go through how you can set up Jest with each of
these options:

You can use `create-next-app` with the with-jest example to quickly get
started with Jest and React Testing Library:

    
    
    npx create-next-app@latest --example with-jest with-jest-app

Since the release of Next.js 12, Next.js now has built-in configuration for
Jest.

To set up Jest, install `jest`, `jest-environment-jsdom`, `@testing-
library/react`, `@testing-library/jest-dom`:

    
    
    npm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom

Create a `jest.config.mjs` file in your project's root directory and add the
following:

    
    
    import nextJest from 'next/jest.js';
     
    const createJestConfig = nextJest({
      // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
      dir: './',
    });
     
    // Add any custom config to be passed to Jest
    /** @type {import('jest').Config} */
    const config = {
      // Add more setup options before each test is run
      // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
     
      testEnvironment: 'jest-environment-jsdom',
    };
     
    // createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
    export default createJestConfig(config);

Under the hood, `next/jest` is automatically configuring Jest for you,
including:

  * Setting up `transform` using SWC
  * Auto mocking stylesheets (`.css`, `.module.css`, and their scss variants), image imports and `next/font`
  * Loading `.env` (and all variants) into `process.env`
  * Ignoring `node_modules` from test resolving and transforms
  * Ignoring `.next` from test resolving
  * Loading `next.config.js` for flags that enable SWC transforms

> **Note** : To test environment variables directly, load them manually in a
> separate setup script or in your `jest.config.js` file. For more
> information, please see Test Environment Variables.

If you opt out of the Rust Compiler, you will need to manually configure Jest
and install `babel-jest` and `identity-obj-proxy` in addition to the packages
above.

Here are the recommended options to configure Jest for Next.js:

    
    
    module.exports = {
      collectCoverage: true,
      // on node 14.x coverage provider v8 offers good speed and more or less good report
      coverageProvider: 'v8',
      collectCoverageFrom: [
        '**/*.{js,jsx,ts,tsx}',
        '!**/*.d.ts',
        '!**/node_modules/**',
        '!<rootDir>/out/**',
        '!<rootDir>/.next/**',
        '!<rootDir>/*.config.js',
        '!<rootDir>/coverage/**',
      ],
      moduleNameMapper: {
        // Handle CSS imports (with CSS modules)
        // https://jestjs.io/docs/webpack#mocking-css-modules
        '^.+\\.module\\.(css|sass|scss)$': 'identity-obj-proxy',
     
        // Handle CSS imports (without CSS modules)
        '^.+\\.(css|sass|scss)$': '<rootDir>/__mocks__/styleMock.js',
     
        // Handle image imports
        // https://jestjs.io/docs/webpack#handling-static-assets
        '^.+\\.(png|jpg|jpeg|gif|webp|avif|ico|bmp|svg)$/i': `<rootDir>/__mocks__/fileMock.js`,
     
        // Handle module aliases
        '^@/components/(.*)$': '<rootDir>/components/$1',
      },
      // Add more setup options before each test is run
      // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
      testPathIgnorePatterns: ['<rootDir>/node_modules/', '<rootDir>/.next/'],
      testEnvironment: 'jsdom',
      transform: {
        // Use babel-jest to transpile tests with the next/babel preset
        // https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object
        '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
      },
      transformIgnorePatterns: [
        '/node_modules/',
        '^.+\\.module\\.(css|sass|scss)$',
      ],
    };

You can learn more about each configuration option in the Jest docs.

**Handling stylesheets and image imports**

Stylesheets and images aren't used in the tests but importing them may cause
errors, so they will need to be mocked. Create the mock files referenced in
the configuration above - `fileMock.js` and `styleMock.js` \- inside a
`__mocks__` directory:

    
    
    module.exports = {
      src: '/img.jpg',
      height: 24,
      width: 24,
      blurDataURL: 'data:image/png;base64,imagedata',
    };

For more information on handling static assets, please refer to the Jest Docs.

**Optional: Extend Jest with custom matchers**

`@testing-library/jest-dom` includes a set of convenient custom matchers such
as `.toBeInTheDocument()` making it easier to write tests. You can import the
custom matchers for every test by adding the following option to the Jest
configuration file:

    
    
    setupFilesAfterEnv: ['<rootDir>/jest.setup.js'];

Then, inside `jest.setup.js`, add the following import:

    
    
    import '@testing-library/jest-dom/extend-expect';

If you need to add more setup options before each test, it's common to add
them to the `jest.setup.js` file above.

**Optional: Absolute Imports and Module Path Aliases**

If your project is using Module Path Aliases, you will need to configure Jest
to resolve the imports by matching the paths option in the `jsconfig.json`
file with the `moduleNameMapper` option in the `jest.config.js` file. For
example:

    
    
    {
      "compilerOptions": {
        "baseUrl": ".",
        "paths": {
          "@/components/*": ["components/*"]
        }
      }
    }
    
    
    moduleNameMapper: {
      '^@/components/(.*)$': '<rootDir>/components/$1',
    }

**Add a test script to package.json**

Add the Jest executable in watch mode to the `package.json` scripts:

    
    
    "scripts": {
      "dev": "next dev",
      "build": "next build",
      "start": "next start",
      "test": "jest --watch"
    }

`jest --watch` will re-run tests when a file is changed. For more Jest CLI
options, please refer to the Jest Docs.

**Create your first tests**

Your project is now ready to run tests. Follow Jest's convention by adding
tests to the `__tests__` folder in your project's root directory.

For example, we can add a test to check if the `<Home />` component
successfully renders a heading:

    
    
    import { render, screen } from '@testing-library/react';
    import Home from '../pages/index';
    import '@testing-library/jest-dom';
     
    describe('Home', () => {
      it('renders a heading', () => {
        render(<Home />);
     
        const heading = screen.getByRole('heading', {
          name: /welcome to next\.js!/i,
        });
     
        expect(heading).toBeInTheDocument();
      });
    });

Optionally, add a snapshot test to keep track of any unexpected changes to
your `<Home />` component:

    
    
    import { render } from '@testing-library/react';
    import Home from '../pages/index';
     
    it('renders homepage unchanged', () => {
      const { container } = render(<Home />);
      expect(container).toMatchSnapshot();
    });

> **Note** : Test files should not be included inside the Pages Router because
> any files inside the Pages Router are considered routes.

**Running your test suite**

Run `npm run test` to run your test suite. After your tests pass or fail, you
will notice a list of interactive Jest commands that will be helpful as you
add more tests.

For further reading, you may find these resources helpful:

The Next.js community has created packages and articles you may find helpful:

For more information on what to read next, we recommend:

  * pages/basic-features/environment-variables#test-environment-variables





Using Pages Router

Features available in /pages





# TypeScript

Next.js provides a TypeScript-first development experience for building your
React application.

It comes with built-in TypeScript support for automatically installing the
necessary packages and configuring the proper settings.

`create-next-app` now ships with TypeScript by default.

    
    
    npx create-next-app@latest

Add TypeScript to your project by renaming a file to `.ts` / `.tsx`. Run `next
dev` and `next build` to automatically install the necessary dependencies and
add a `tsconfig.json` file with the recommended config options.

It is highly recommended to be on at least `v4.5.2` of TypeScript to get
syntax features such as type modifiers on import names and performance
improvements.

For `getStaticProps`, `getStaticPaths`, and `getServerSideProps`, you can use
the `GetStaticProps`, `GetStaticPaths`, and `GetServerSideProps` types
respectively:

    
    
    import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next';
     
    export const getStaticProps: GetStaticProps = async (context) => {
      // ...
    };
     
    export const getStaticPaths: GetStaticPaths = async () => {
      // ...
    };
     
    export const getServerSideProps: GetServerSideProps = async (context) => {
      // ...
    };

The following is an example of how to use the built-in types for API routes:

    
    
    import type { NextApiRequest, NextApiResponse } from 'next';
     
    export default function handler(req: NextApiRequest, res: NextApiResponse) {
      res.status(200).json({ name: 'John Doe' });
    }

You can also type the response data:

    
    
    import type { NextApiRequest, NextApiResponse } from 'next';
     
    type Data = {
      name: string;
    };
     
    export default function handler(
      req: NextApiRequest,
      res: NextApiResponse<Data>,
    ) {
      res.status(200).json({ name: 'John Doe' });
    }

If you have a custom `App`, you can use the built-in type `AppProps` and
change file name to `./pages/_app.tsx` like so:

    
    
    import type { AppProps } from 'next/app';
     
    export default function MyApp({ Component, pageProps }: AppProps) {
      return <Component {...pageProps} />;
    }

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"`
options.

You can learn more about this feature on the Module Path aliases
documentation.

The `next.config.js` file must be a JavaScript file as it does not get parsed
by Babel or TypeScript, however you can add some type checking in your IDE
using JSDoc as below:

    
    
    // @ts-check
     
    /**
     * @type {import('next').NextConfig}
     **/
    const nextConfig = {
      /* config options here */
    };
     
    module.exports = nextConfig;

Since `v10.2.1` Next.js supports incremental type checking when enabled in
your `tsconfig.json`, this can help speed up type checking in larger
applications.

Next.js fails your **production build** (`next build`) when TypeScript errors
are present in your project.

If you'd like Next.js to dangerously produce production code even when your
application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or
deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the
`typescript` config:

    
    
    module.exports = {
      typescript: {
        // !! WARN !!
        // Dangerously allow production builds to successfully complete even if
        // your project has type errors.
        // !! WARN !!
        ignoreBuildErrors: true,
      },
    };

Version| Changes  
---|---  
`v13.2.0`| Statically typed links are available in beta  
`v12.0.0`| SWC is now used by default to compile TypeScript and TSX for faster
builds.  
`v10.2.1`| Incremental type checking support added when enabled in your
`tsconfig.json`.



  
  
# ESLint

Next.js provides an integrated ESLint experience out of the box. Add `next
lint` as a script to `package.json`:

    
    
    "scripts": {
      "lint": "next lint"
    }

Then run `npm run lint` or `yarn lint`:

If you don't already have ESLint configured in your application, you will be
guided through the installation and configuration process.

> You'll see a prompt like this:
>
> ? How would you like to configure ESLint?
>
> ❯ Base configuration + Core Web Vitals rule-set (recommended) Base
> configuration None

One of the following three options can be selected:

  * **Strict** : Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.
    
        {
      "extends": "next/core-web-vitals"
    }

  * **Base** : Includes Next.js' base ESLint configuration.

  * **Cancel** : Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.

If either of the two configuration options are selected, Next.js will
automatically install `eslint` and `eslint-config-next` as development
dependencies in your application and create an `.eslintrc.json` file in the
root of your project that includes your selected configuration.

You can now run `next lint` every time you want to run ESLint to catch errors.
Once ESLint has been set up, it will also automatically run during every build
(`next build`). Errors will fail the build, while warnings will not.

> If you do not want ESLint to run during `next build`, refer to the
> documentation for Ignoring ESLint.

We recommend using an appropriate integration to view warnings and errors
directly in your code editor during development.

The default configuration (`eslint-config-next`) includes everything you need
to have an optimal out-of-the-box linting experience in Next.js. If you do not
have ESLint already configured in your application, we recommend using `next
lint` to set up ESLint along with this configuration.

> If you would like to use `eslint-config-next` along with other ESLint
> configurations, refer to the Additional Configurations section to learn how
> to do so without causing any conflicts.

Recommended rule-sets from the following ESLint plugins are all used within
`eslint-config-next`:

This will take precedence over the configuration from `next.config.js`.

Next.js provides an ESLint plugin, `eslint-plugin-next`, already bundled
within the base configuration that makes it possible to catch common issues
and problems in a Next.js application. The full set of rules is as follows:

Enabled in the recommended configuration

If you already have ESLint configured in your application, we recommend
extending from this plugin directly instead of including `eslint-config-next`
unless a few conditions are met. Refer to the Recommended Plugin Ruleset to
learn more.

If you're using `eslint-plugin-next` in a project where Next.js isn't
installed in your root directory (such as a monorepo), you can tell `eslint-
plugin-next` where to find your Next.js application using the `settings`
property in your `.eslintrc`:

    
    
    {
      "extends": "next",
      "settings": {
        "next": {
          "rootDir": "packages/my-app/"
        }
      }
    }

`rootDir` can be a path (relative or absolute), a glob (i.e. `"packages/*/"`),
or an array of paths and/or globs.

By default, Next.js will run ESLint for all files in the `pages/`, `app` (only
if the experimental `appDir` feature is enabled), `components/`, `lib/`, and
`src/` directories. However, you can specify which directories using the
`dirs` option in the `eslint` config in `next.config.js` for production
builds:

    
    
    module.exports = {
      eslint: {
        dirs: ['pages', 'utils'], // Only run ESLint on the 'pages' and 'utils' directories during production builds (next build)
      },
    };

Similarly, the `--dir` and `--file` flags can be used for `next lint` to lint
specific directories and files:

    
    
    next lint --dir pages --dir utils --file bar.js

To improve performance, information of files processed by ESLint are cached by
default. This is stored in `.next/cache` or in your defined build directory.
If you include any ESLint rules that depend on more than the contents of a
single source file and need to disable the cache, use the `--no-cache` flag
with `next lint`.

If you would like to modify or disable any rules provided by the supported
plugins (`react`, `react-hooks`, `next`), you can directly change them using
the `rules` property in your `.eslintrc`:

    
    
    {
      "extends": "next",
      "rules": {
        "react/no-unescaped-entities": "off",
        "@next/next/no-page-custom-font": "off"
      }
    }

The `next/core-web-vitals` rule set is enabled when `next lint` is run for the
first time and the **strict** option is selected.

    
    
    {
      "extends": "next/core-web-vitals"
    }

`next/core-web-vitals` updates `eslint-plugin-next` to error on a number of
rules that are warnings by default if they affect Core Web Vitals.

> The `next/core-web-vitals` entry point is automatically included for new
> applications built with Create Next App.

ESLint also contains code formatting rules, which can conflict with your
existing Prettier setup. We recommend including eslint-config-prettier in your
ESLint config to make ESLint and Prettier work together.

First, install the dependency:

    
    
    npm install --save-dev eslint-config-prettier
     
    yarn add --dev eslint-config-prettier

Then, add `prettier` to your existing ESLint config:

    
    
    {
      "extends": ["next", "prettier"]
    }

If you would like to use `next lint` with lint-staged to run the linter on
staged git files, you'll have to add the following to the `.lintstagedrc.js`
file in the root of your project in order to specify usage of the `--file`
flag.

    
    
    const path = require('path');
     
    const buildEslintCommand = (filenames) =>
      `next lint --fix --file ${filenames
        .map((f) => path.relative(process.cwd(), f))
        .join(' --file ')}`;
     
    module.exports = {
      '*.{js,jsx,ts,tsx}': [buildEslintCommand],
    };

If you already have ESLint configured in your application and any of the
following conditions are true:

  * You have one or more of the following plugins already installed (either separately or through a different config such as `airbnb` or `react-app`): 
    * `react`
    * `react-hooks`
    * `jsx-a11y`
    * `import`
  * You've defined specific `parserOptions` that are different from how Babel is configured within Next.js (this is not recommended unless you have customized your Babel configuration)
  * You have `eslint-plugin-import` installed with Node.js and/or TypeScript resolvers defined to handle imports

Then we recommend either removing these settings if you prefer how these
properties have been configured within `eslint-config-next` or extending
directly from the Next.js ESLint plugin instead:

    
    
    module.exports = {
      extends: [
        //...
        'plugin:@next/next/recommended',
      ],
    };

The plugin can be installed normally in your project without needing to run
`next lint`:

    
    
    npm install --save-dev @next/eslint-plugin-next
     
    yarn add --dev @next/eslint-plugin-next

This eliminates the risk of collisions or errors that can occur due to
importing the same plugin or parser across multiple configurations.

If you already use a separate ESLint configuration and want to include
`eslint-config-next`, ensure that it is extended last after other
configurations. For example:

    
    
    {
      "extends": ["eslint:recommended", "next"]
    }

The `next` configuration already handles setting default values for the
`parser`, `plugins` and `settings` properties. There is no need to manually
re-declare any of these properties unless you need a different configuration
for your use case.

If you include any other shareable configurations, **you will need to make
sure that these properties are not overwritten or modified**. Otherwise, we
recommend removing any configurations that share behavior with the `next`
configuration or extending directly from the Next.js ESLint plugin as
mentioned above.





# Environment Variables

 **Examples**

Next.js comes with built-in support for environment variables, which allows
you to do the following:

Next.js has built-in support for loading environment variables from
`.env.local` into `process.env`.

    
    
    DB_HOST=localhost
    DB_USER=myuser
    DB_PASS=mypassword

This loads `process.env.DB_HOST`, `process.env.DB_USER`, and
`process.env.DB_PASS` into the Node.js environment automatically allowing you
to use them in Next.js data fetching methods and API routes.

For example, using `getStaticProps`:

    
    
    export async function getStaticProps() {
      const db = await myDB.connect({
        host: process.env.DB_HOST,
        username: process.env.DB_USER,
        password: process.env.DB_PASS,
      });
      // ...
    }

Next.js will automatically expand variables that use `$` to reference other
variables e.g. `$VARIABLE` inside of your `.env*` files. This allows you to
reference other secrets. For example:

    
    
    HOSTNAME=localhost
    PORT=8080
    HOST=http://$HOSTNAME:$PORT

In the above example, `process.env.HOST` would be set to
`http://localhost:8080`.

> **Note** : If you need to use variable with a `$` in the actual value, it
> needs to be escaped e.g. `\$`.

By default environment variables are only available in the Node.js
environment, meaning they won't be exposed to the browser.

In order to expose a variable to the browser you have to prefix the variable
with `NEXT_PUBLIC_`. For example:

    
    
    NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk

This loads `process.env.NEXT_PUBLIC_ANALYTICS_ID` into the Node.js environment
automatically, allowing you to use it anywhere in your code. The value will be
inlined into JavaScript sent to the browser because of the `NEXT_PUBLIC_`
prefix. This inlining occurs at build time, so your various `NEXT_PUBLIC_`
envs need to be set when the project is built.

    
    
    import setupAnalyticsService from '../lib/my-analytics-service';
     
    // 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.
    // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.
    setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID);
     
    function HomePage() {
      return <h1>Hello World</h1>;
    }
     
    export default HomePage;

Note that dynamic lookups will _not_ be inlined, such as:

    
    
    // This will NOT be inlined, because it uses a variable
    const varName = 'NEXT_PUBLIC_ANALYTICS_ID';
    setupAnalyticsService(process.env[varName]);
     
    // This will NOT be inlined, because it uses a variable
    const env = process.env;
    setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID);

In general only one `.env.local` file is needed. However, sometimes you might
want to add some defaults for the `development` (`next dev`) or `production`
(`next start`) environment.

Next.js allows you to set defaults in `.env` (all environments),
`.env.development` (development environment), and `.env.production`
(production environment).

`.env.local` always overrides the defaults set.

> **Note** : `.env`, `.env.development`, and `.env.production` files should be
> included in your repository as they define defaults. **`.env*.local` should
> be added to `.gitignore`**, as those files are intended to be ignored.
> `.env.local` is where secrets can be stored.

When deploying your Next.js application to Vercel, Environment Variables can
be configured in the Project Settings.

All types of Environment Variables should be configured there. Even
Environment Variables used in Development – which can be downloaded onto your
local device afterwards.

If you've configured Development Environment Variables you can pull them into
a `.env.local` for usage on your local machine using the following command:

    
    
    vercel env pull .env.local

Apart from `development` and `production` environments, there is a 3rd option
available: `test`. In the same way you can set defaults for development or
production environments, you can do the same with a `.env.test` file for the
`testing` environment (though this one is not as common as the previous two).
Next.js will not load environment variables from `.env.development` or
`.env.production` in the `testing` environment.

This one is useful when running tests with tools like `jest` or `cypress`
where you need to set specific environment vars only for testing purposes.
Test default values will be loaded if `NODE_ENV` is set to `test`, though you
usually don't need to do this manually as testing tools will address it for
you.

There is a small difference between `test` environment, and both `development`
and `production` that you need to bear in mind: `.env.local` won't be loaded,
as you expect tests to produce the same results for everyone. This way every
test execution will use the same env defaults across different executions by
ignoring your `.env.local` (which is intended to override the default set).

> **Note** : similar to Default Environment Variables, `.env.test` file should
> be included in your repository, but `.env.test.local` shouldn't, as
> `.env*.local` are intended to be ignored through `.gitignore`.

While running unit tests you can make sure to load your environment variables
the same way Next.js does by leveraging the `loadEnvConfig` function from the
`@next/env` package.

    
    
    // The below can be used in a Jest global setup file or similar for your testing set-up
    import { loadEnvConfig } from '@next/env';
     
    export default async () => {
      const projectDir = process.cwd();
      loadEnvConfig(projectDir);
    };

Environment variables are looked up in the following places, in order,
stopping once the variable is found.

  1. `process.env`
  2. `.env.$(NODE_ENV).local`
  3. `.env.local` (Not checked when `NODE_ENV` is `test`.)
  4. `.env.$(NODE_ENV)`
  5. `.env`

For example, if `NODE_ENV` is `development` and you define a variable in both
`.env.development.local` and `.env`, the value in `.env.development.local`
will be used.

> **Note** : The allowed values for `NODE_ENV` are `production`, `development`
> and `test`.

  * If you are using a `/src` directory, `env.*` files should remain in the root of your project.





# Absolute Imports and Module Path Aliases

 **Examples**

Next.js has in-built support for the `"paths"` and `"baseUrl"` options of
`tsconfig.json` and `jsconfig.json` files.

These options allow you to alias project directories to absolute paths, making
it easier to import modules. For example:

    
    
    // before
    import { Button } from '../../../components/button';
     
    // after
    import { Button } from '@/components/button';

> **Good to know** : `create-next-app` will prompt to configure these options
> for you.

The `baseUrl` configuration option allows you to import directly from the root
of the project.

An example of this configuration:

    
    
    {
      "compilerOptions": {
        "baseUrl": "."
      }
    }
    
    
    export default function Button() {
      return <button>Click me</button>;
    }
    
    
    import Button from 'components/button';
     
    export default function HomePage() {
      return (
        <>
          <h1>Hello World</h1>
          <Button />
        </>
      );
    }

In addition to configuring the `baseUrl` path, you can use the `"paths"`
option to "alias" module paths.

For example, the following configuration maps `@/components/*` to
`components/*`:

    
    
    {
      "compilerOptions": {
        "baseUrl": ".",
        "paths": {
          "@/components/*": ["components/*"]
        }
      }
    }
    
    
    export default function Button() {
      return <button>Click me</button>;
    }
    
    
    import Button from '@/components/button';
     
    export default function HomePage() {
      return (
        <>
          <h1>Hello World</h1>
          <Button />
        </>
      );
    }





Using Pages Router

Features available in /pages





# MDX

Markdown is a lightweight markup language used to format text. It allows you
to write using plain text syntax and convert it to structurally valid HTML.
It's commonly used for writing content on websites and blogs.

You write...

    
    
    I **love** using [Next.js](https://nextjs.org/)

Output:

    
    
    <p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>

MDX is a superset of markdown that lets you write JSX directly in your
markdown files. It is a powerful way to add dynamic interactivity and embed
React components within your content.

Next.js can support both local MDX content inside your application, as well as
remote MDX files fetched dynamically on the server. The Next.js plugin handles
tranforming Markdown and React components into HTML, including support for
usage in Server Components (default in `app`).

The `@next/mdx` package is configured in the `next.config.js` file at your
projects root. **It sources data from local files** , allowing you to create
pages with a `.mdx` extension, directly in your `/pages` or `/app` directory.

Install the required packages:

    
    
      npm install @next/mdx @mdx-js/loader @mdx-js/react

Require the package and configure to support top level `.mdx` pages. The
following adds the `options` object key allowing you to pass in any plugins:

    
    
    // next.config.js
     
    const withMDX = require('@next/mdx')({
      extension: /\.mdx?$/,
      options: {
        // If you use remark-gfm, you'll need to use next.config.mjs
        // as the package is ESM only
        // https://github.com/remarkjs/remark-gfm#install
        remarkPlugins: [],
        rehypePlugins: [],
        // If you use `MDXProvider`, uncomment the following line.
        // providerImportSource: "@mdx-js/react",
      },
    });
     
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      // Configure pageExtensions to include md and mdx
      pageExtensions: ['ts', 'tsx', 'js', 'jsx', 'md', 'mdx'],
      // Optionally, add any other Next.js config below
      reactStrictMode: true,
    };
     
    // Merge MDX config with Next.js config
    module.exports = withMDX(nextConfig);

You can now import a React component directly inside your MDX page:

    
    
    import { MyComponent } from 'my-components';
     
    My MDX page
     
    This is a list in markdown:
     
    - One
    - Two
    - Three
     
    Checkout my React component:
     
    <MyComponent />

If your Markdown or MDX files do _not_ live inside your application, you can
fetch them dynamically on the server. This is useful for fetching content from
a CMS or other data source.

There are two popular community packages for fetching MDX content: `next-mdx-
remote` and `contentlayer`. For example, the following example uses `next-mdx-
remote`:

> **Note:** Please proceed with caution. MDX compiles to JavaScript and is
> executed on the server. You should only fetch MDX content from a trusted
> source, otherwise this can lead to remote code execution (RCE).
    
    
    import { MDXRemote } from 'next-mdx-remote/rsc';
     
    export default async function Home() {
      const res = await fetch('https://...');
      const markdown = await res.text();
      return <MDXRemote source={markdown} />;
    }

To share a layout around MDX content, you can use the built-in layouts support
with the App Router.

To add a layout to your MDX page, create a new component and import it into
the MDX page. Then you can wrap the MDX page with your layout component:

    
    
    import { MyComponent, MyLayoutComponent } from 'my-components';
     
    export const meta = {
      author: 'Rich Haines',
    };
     
    My MDX Page with a Layout
     
    This is a list in markdown:
     
    - One
    - Two
    - Three
     
    Checkout my React component:
     
    <MyComponent />
     
    export default ({ children }) => (
      <MyLayoutComponent meta={meta}>{children}</MyLayoutComponent>
    );
     
    ;

You can optionally provide `remark` and `rehype` plugins to transform the MDX
content. For example, you can use `remark-gfm` to support GitHub Flavored
Markdown.

Since the `remark` and `rehype` ecosystem is ESM only, you'll need to use
`next.config.mjs` as the configuration file.

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        appDir: true,
      },
    };
     
    const withMDX = require('@next/mdx')({
      options: {
        remarkPlugins: [],
        rehypePlugins: [],
        // If you use `MDXProvider`, uncomment the following line.
        // providerImportSource: "@mdx-js/react",
      },
    });
    module.exports = withMDX(nextConfig);

Frontmatter is a YAML like key/value pairing that can be used to store data
about a page. `@next/mdx` does **not** support frontmatter by default, though
there are many solutions for adding frontmatter to your MDX content, such as
gray-matter.

To access page metadata with `@next/mdx`, you can export a meta object from
within the `.mdx` file:

    
    
    export const meta = {
      author: 'Rich Haines',
    };
     
    # My MDX page

One of the pleasant aspects of using markdown, is that it maps to native
`HTML` elements, making writing fast, and intuitive:

    
    
    This is a list in markdown:
     
    - One
    - Two
    - Three

The above generates the following `HTML`:

    
    
    <p>This is a list in markdown:</p>
     
    <ul>
      <li>One</li>
      <li>Two</li>
      <li>Three</li>
    </ul>

When you want to style your own elements to give a custom feel to your website
or application, you can pass in shortcodes. These are your own custom
components that map to `HTML` elements. To do this you use the `MDXProvider`
and pass a components object as a prop. Each object key in the components
object maps to a `HTML` element name.

To enable you need to specify `providerImportSource: "@mdx-js/react"` in
`next.config.js`.

    
    
    const withMDX = require('@next/mdx')({
      // ...
      options: {
        providerImportSource: '@mdx-js/react',
      },
    });

Then setup the provider in your page

    
    
     
    import { MDXProvider } from '@mdx-js/react'
    import Image from 'next/image'
    import { Heading, InlineCode, Pre, Table, Text } from 'my-components'
     
    const ResponsiveImage = (props) => (
      <Image alt={props.alt} sizes="100vw" style={ width: '100%', height: 'auto' }  {...props} />
    )
     
    const components = {
      img: ResponsiveImage,
      h1: Heading.H1,
      h2: Heading.H2,
      p: Text,
      pre: Pre,
      code: InlineCode,
    }
     
    export default function Post(props) {
      return (
        <MDXProvider components={components}>
          <main {...props} />
        </MDXProvider>
      )
    }

If you use it across the site you may want to add the provider to `_app.js` so
all MDX pages pick up the custom element config.

React does not natively understand Markdown. The markdown plaintext needs to
first be transformed into HTML. This can be accomplished with `remark` and
`rehype`.

`remark` is an ecosystem of tools around markdown. `rehype` is the same, but
for HTML. For example, the following code snippet transforms markdown into
HTML:

    
    
    import { unified } from 'unified';
    import remarkParse from 'remark-parse';
    import remarkRehype from 'remark-rehype';
    import rehypeSanitize from 'rehype-sanitize';
    import rehypeStringify from 'rehype-stringify';
     
    main();
     
    async function main() {
      const file = await unified()
        .use(remarkParse) // Convert into markdown AST
        .use(remarkRehype) // Transform to HTML AST
        .use(rehypeSanitize) // Sanitize HTML input
        .use(rehypeStringify) // Convert AST into serialized HTML
        .process('Hello, Next.js!');
     
      console.log(String(file)); // <p>>Hello, Next.js!</p>
    }

The `remark` and `rehype` ecosystem contains plugins for syntax highlighting,
linking headings, generating a table of contents, and more.

When using `@next/mdx` as shown below, you **do not** need to use `remark` or
`rehype` directly, as it is handled for you.

Next.js supports a new MDX compiler written in Rust. This compiler is still
experimental and is not recommended for production use. To use the new
compiler, you need to configure `next.config.js` when you pass it to
`withMDX`:

    
    
    module.exports = withMDX({
      experimental: {
        mdxRs: true,
      },
    });





# AMP

 **Examples**

With Next.js you can turn any React page into an AMP page, with minimal
config, and without leaving React.

You can read more about AMP in the official amp.dev site.

To enable AMP support for a page, and to learn more about the different AMP
configs, read the API documentation for `next/amp`.

The AMP community provides many components to make AMP pages more interactive.
Next.js will automatically import all components used on a page and there is
no need to manually import AMP component scripts:

    
    
    export const config = { amp: true };
     
    function MyAmpPage() {
      const date = new Date();
     
      return (
        <div>
          <p>Some time: {date.toJSON()}</p>
          <amp-timeago
            width="0"
            height="15"
            datetime={date.toJSON()}
            layout="responsive"
          >
            .
          </amp-timeago>
        </div>
      );
    }
     
    export default MyAmpPage;

The above example uses the `amp-timeago` component.

By default, the latest version of a component is always imported. If you want
to customize the version, you can use `next/head`, as in the following
example:

    
    
    import Head from 'next/head';
     
    export const config = { amp: true };
     
    function MyAmpPage() {
      const date = new Date();
     
      return (
        <div>
          <Head>
            <script
              async
              key="amp-timeago"
              custom-element="amp-timeago"
              src="https://cdn.ampproject.org/v0/amp-timeago-0.1.js"
            />
          </Head>
     
          <p>Some time: {date.toJSON()}</p>
          <amp-timeago
            width="0"
            height="15"
            datetime={date.toJSON()}
            layout="responsive"
          >
            .
          </amp-timeago>
        </div>
      );
    }
     
    export default MyAmpPage;

AMP pages are automatically validated with amphtml-validator during
development. Errors and warnings will appear in the terminal where you started
Next.js.

Pages are also validated during Static HTML export and any warnings / errors
will be printed to the terminal. Any AMP errors will cause the export to exit
with status code `1` because the export is not valid AMP.

You can set up custom AMP validator in `next.config.js` as shown below:

    
    
    module.exports = {
      amp: {
        validator: './custom_validator.js',
      },
    };

To turn off AMP validation add the following code to `next.config.js`

    
    
    experimental: {
      amp: {
        skipValidation: true;
      }
    }

When using Static HTML export statically prerender pages, Next.js will detect
if the page supports AMP and change the exporting behavior based on that.

For example, the hybrid AMP page `pages/about.js` would output:

  * `out/about.html` \- HTML page with client-side React runtime
  * `out/about.amp.html` \- AMP page

And if `pages/about.js` is an AMP-only page, then it would output:

  * `out/about.html` \- Optimized AMP page

Next.js will automatically insert a link to the AMP version of your page in
the HTML version, so you don't have to, like so:

    
    
    <link rel="amphtml" href="/about.amp.html" />

And the AMP version of your page will include a link to the HTML page:

    
    
    <link rel="canonical" href="/about" />

When `trailingSlash` is enabled the exported pages for `pages/about.js` would
be:

  * `out/about/index.html` \- HTML page
  * `out/about.amp/index.html` \- AMP page

AMP currently doesn't have built-in types for TypeScript, but it's in their
roadmap (#13791).

As a workaround you can manually create a file called `amp.d.ts` inside your
project and add these custom types.





# Babel

 **Examples**

Next.js includes the `next/babel` preset to your app, which includes
everything needed to compile React applications and server-side code. But if
you want to extend the default Babel configs, it's also possible.

To start, you only need to define a `.babelrc` file (or `babel.config.js`) in
the root directory of your project. If such a file is found, it will be
considered as the _source of truth_ , and therefore it needs to define what
Next.js needs as well, which is the `next/babel` preset.

Here's an example `.babelrc` file:

    
    
    {
      "presets": ["next/babel"],
      "plugins": []
    }

You can take a look at this file to learn about the presets included by
`next/babel`.

To add presets/plugins **without configuring them** , you can do it this way:

    
    
    {
      "presets": ["next/babel"],
      "plugins": ["@babel/plugin-proposal-do-expressions"]
    }

To add presets/plugins **with custom configuration** , do it on the
`next/babel` preset like so:

    
    
    {
      "presets": [
        [
          "next/babel",
          {
            "preset-env": {},
            "transform-runtime": {},
            "styled-jsx": {},
            "class-properties": {}
          }
        ]
      ],
      "plugins": []
    }

To learn more about the available options for each config, visit babel's
documentation site.

> **Good to know:**
>
>   * Next.js uses the **current** Node.js version for server-side
> compilations.
>   * The `modules` option on `"preset-env"` should be kept to `false`,
> otherwise webpack code splitting is turned off.
>





# PostCSS

 **Examples**

Next.js compiles CSS for its built-in CSS support using PostCSS.

Out of the box, with no configuration, Next.js compiles CSS with the following
transformations:

By default, CSS Grid and Custom Properties (CSS variables) are **not
compiled** for IE11 support.

To compile CSS Grid Layout for IE11, you can place the following comment at
the top of your CSS file:

    
    
    /* autoprefixer grid: autoplace */

You can also enable IE11 support for CSS Grid Layout in your entire project by
configuring autoprefixer with the configuration shown below (collapsed). See
"Customizing Plugins" below for more information.

**Click to view the configuration to enable CSS Grid Layout**

    
    
     {
      "plugins": [
        "postcss-flexbugs-fixes",
        [
          "postcss-preset-env",
          {
            "autoprefixer": {
              "flexbox": "no-2009",
              "grid": "autoplace"
            },
            "stage": 3,
            "features": {
              "custom-properties": false
            }
          }
        ]
      ]
    }

CSS variables are not compiled because it is not possible to safely do so. If
you must use variables, consider using something like Sass variables which are
compiled away by Sass.

Next.js allows you to configure the target browsers (for Autoprefixer and
compiled css features) through Browserslist.

To customize browserslist, create a `browserslist` key in your `package.json`
like so:

    
    
    {
      "browserslist": [">0.3%", "not dead", "not op_mini all"]
    }

You can use the browsersl.ist tool to visualize what browsers you are
targeting.

No configuration is needed to support CSS Modules. To enable CSS Modules for a
file, rename the file to have the extension `.module.css`.

You can learn more about Next.js' CSS Module support here.

> **Warning** : When you define a custom PostCSS configuration file, Next.js
> **completely disables** the default behavior. Be sure to manually configure
> all the features you need compiled, including Autoprefixer. You also need to
> install any plugins included in your custom configuration manually, i.e.
> `npm install postcss-flexbugs-fixes postcss-preset-env`.

To customize the PostCSS configuration, create a `postcss.config.json` file in
the root of your project.

This is the default configuration used by Next.js:

    
    
    {
      "plugins": [
        "postcss-flexbugs-fixes",
        [
          "postcss-preset-env",
          {
            "autoprefixer": {
              "flexbox": "no-2009"
            },
            "stage": 3,
            "features": {
              "custom-properties": false
            }
          }
        ]
      ]
    }

> **Note** : Next.js also allows the file to be named `.postcssrc.json`, or,
> to be read from the `postcss` key in `package.json`.

It is also possible to configure PostCSS with a `postcss.config.js` file,
which is useful when you want to conditionally include plugins based on
environment:

    
    
    module.exports = {
      plugins:
        process.env.NODE_ENV === 'production'
          ? [
              'postcss-flexbugs-fixes',
              [
                'postcss-preset-env',
                {
                  autoprefixer: {
                    flexbox: 'no-2009',
                  },
                  stage: 3,
                  features: {
                    'custom-properties': false,
                  },
                },
              ],
            ]
          : [
              // No transformations in development
            ],
    };

> **Note** : Next.js also allows the file to be named `.postcssrc.js`.

Do **not use`require()`** to import the PostCSS Plugins. Plugins must be
provided as strings.

> **Note** : If your `postcss.config.js` needs to support other non-Next.js
> tools in the same project, you must use the interoperable object-based
> format instead:
>  
>  
>     module.exports = {
>       plugins: {
>         'postcss-flexbugs-fixes': {},
>         'postcss-preset-env': {
>           autoprefixer: {
>             flexbox: 'no-2009',
>           },
>           stage: 3,
>           features: {
>             'custom-properties': false,
>           },
>         },
>       },
>     };





# Custom Server

 **Examples**

By default, Next.js includes its own server with `next start`. If you have an
existing backend, you can still use it with Next.js (this is not a custom
server). A custom Next.js server allows you to start a server 100%
programmatically in order to use custom server patterns. Most of the time, you
will not need this - but it's available for complete customization.

> **Note** : A custom server **cannot** be deployed on Vercel.

> Before deciding to use a custom server, please keep in mind that it should
> only be used when the integrated router of Next.js can't meet your app
> requirements. A custom server will remove important performance
> optimizations, like **serverless functions** and **Automatic Static
> Optimization.**

Take a look at the following example of a custom server:

    
    
    const { createServer } = require('http');
    const { parse } = require('url');
    const next = require('next');
     
    const dev = process.env.NODE_ENV !== 'production';
    const hostname = 'localhost';
    const port = 3000;
    // when using middleware `hostname` and `port` must be provided below
    const app = next({ dev, hostname, port });
    const handle = app.getRequestHandler();
     
    app.prepare().then(() => {
      createServer(async (req, res) => {
        try {
          // Be sure to pass `true` as the second argument to `url.parse`.
          // This tells it to parse the query portion of the URL.
          const parsedUrl = parse(req.url, true);
          const { pathname, query } = parsedUrl;
     
          if (pathname === '/a') {
            await app.render(req, res, '/a', query);
          } else if (pathname === '/b') {
            await app.render(req, res, '/b', query);
          } else {
            await handle(req, res, parsedUrl);
          }
        } catch (err) {
          console.error('Error occurred handling', req.url, err);
          res.statusCode = 500;
          res.end('internal server error');
        }
      })
        .once('error', (err) => {
          console.error(err);
          process.exit(1);
        })
        .listen(port, () => {
          console.log(`> Ready on http://${hostname}:${port}`);
        });
    });

> `server.js` doesn't go through babel or webpack. Make sure the syntax and
> sources this file requires are compatible with the current node version you
> are running.

To run the custom server you'll need to update the `scripts` in `package.json`
like so:

    
    
    "scripts": {
      "dev": "node server.js",
      "build": "next build",
      "start": "NODE_ENV=production node server.js"
    }

* * *

The custom server uses the following import to connect the server with the
Next.js application:

    
    
    const next = require('next');
    const app = next({});

The above `next` import is a function that receives an object with the
following options:

  * `dev`: `Boolean` \- Whether or not to launch Next.js in dev mode. Defaults to `false`
  * `dir`: `String` \- Location of the Next.js project. Defaults to `'.'`
  * `quiet`: `Boolean` \- Hide error messages containing server information. Defaults to `false`
  * `conf`: `object` \- The same object you would use in next.config.js. Defaults to `{}`

The returned `app` can then be used to let Next.js handle requests as
required.

By default, `Next` will serve each file in the `pages` folder under a pathname
matching the filename. If your project uses a custom server, this behavior may
result in the same content being served from multiple paths, which can present
problems with SEO and UX.

To disable this behavior and prevent routing based on files in `pages`, open
`next.config.js` and disable the `useFileSystemPublicRoutes` config:

    
    
    module.exports = {
      useFileSystemPublicRoutes: false,
    };

> Note that `useFileSystemPublicRoutes` disables filename routes from SSR;
> client-side routing may still access those paths. When using this option,
> you should guard against navigation to routes you do not want
> programmatically.

> You may also wish to configure the client-side router to disallow client-
> side redirects to filename routes; for that refer to
> `router.beforePopState`.





# Draft Mode

In the Pages documentation and the Data Fetching documentation, we talked
about how to pre-render a page at build time ( **Static Generation** ) using
`getStaticProps` and `getStaticPaths`.

Static Generation is useful when your pages fetch data from a headless CMS.
However, it’s not ideal when you’re writing a draft on your headless CMS and
want to view the draft immediately on your page. You’d want Next.js to render
these pages at **request time** instead of build time and fetch the draft
content instead of the published content. You’d want Next.js to bypass Static
Generation only for this specific case.

Next.js has a feature called **Draft Mode** which solves this problem. Here
are instructions on how to use it.

> Take a look at the API Routes documentation first if you’re not familiar
> with Next.js API Routes.

First, create the **API route**. It can have any name - e.g.
`pages/api/draft.ts`

In this API route, you need to call `setDraftMode` on the response object.

    
    
    export default function handler(req, res) {
      // ...
      res.setDraftMode({ enable: true });
      // ...
    }

This will set a **cookie** to enable draft mode. Subsequent requests
containing this cookie will trigger **Draft Mode** changing the behavior for
statically generated pages (more on this later).

You can test this manually by creating an API route like below and accessing
it from your browser manually:

    
    
    // simple example for testing it manually from your browser.
    export default function handler(req, res) {
      res.setDraftMode({ enable: true });
      res.end('Draft mode is enabled');
    }

If you open your browser’s developer tools and visit `/api/draft`, you’ll
notice a `Set-Cookie` response header with a cookie named
`__prerender_bypass`.

In practice, you’d want to call this API route _securely_ from your headless
CMS. The specific steps will vary depending on which headless CMS you’re
using, but here are some common steps you could take.

These steps assume that the headless CMS you’re using supports setting
**custom draft URLs**. If it doesn’t, you can still use this method to secure
your draft URLs, but you’ll need to construct and access the draft URL
manually.

**First** , you should create a **secret token string** using a token
generator of your choice. This secret will only be known by your Next.js app
and your headless CMS. This secret prevents people who don’t have access to
your CMS from accessing draft URLs.

**Second** , if your headless CMS supports setting custom draft URLs, specify
the following as the draft URL. This assumes that your draft API route is
located at `pages/api/draft.ts`.

    
    
    https://<your-site>/api/draft?secret=<token>&slug=<path>

  * `<your-site>` should be your deployment domain.
  * `<token>` should be replaced with the secret token you generated.
  * `<path>` should be the path for the page that you want to view. If you want to view `/posts/foo`, then you should use `&slug=/posts/foo`.

Your headless CMS might allow you to include a variable in the draft URL so
that `<path>` can be set dynamically based on the CMS’s data like so:
`&slug=/posts/{entry.fields.slug}`

**Finally** , in the draft API route:

  * Check that the secret matches and that the `slug` parameter exists (if not, the request should fail).
  *   * Call `res.setDraftMode`.
  * Then redirect the browser to the path specified by `slug`. (The following example uses a 307 redirect).

    
    
    export default async (req, res) => {
      // Check the secret and next parameters
      // This secret should only be known to this API route and the CMS
      if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {
        return res.status(401).json({ message: 'Invalid token' });
      }
     
      // Fetch the headless CMS to check if the provided `slug` exists
      // getPostBySlug would implement the required fetching logic to the headless CMS
      const post = await getPostBySlug(req.query.slug);
     
      // If the slug doesn't exist prevent draft mode from being enabled
      if (!post) {
        return res.status(401).json({ message: 'Invalid slug' });
      }
     
      // Enable Draft Mode by setting the cookie
      res.setDraftMode({ enable: true });
     
      // Redirect to the path from the fetched post
      // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities
      res.redirect(post.slug);
    };

If it succeeds, then the browser will be redirected to the path you want to
view with the draft mode cookie.

The next step is to update `getStaticProps` to support draft mode.

If you request a page which has `getStaticProps` with the cookie set (via
`res.setDraftMode`), then `getStaticProps` will be called at **request time**
(instead of at build time).

Furthermore, it will be called with a `context` object where
`context.draftMode` will be `true`.

    
    
    export async function getStaticProps(context) {
      if (context.draftMode) {
        // dynamic data
      }
    }

We used `res.setDraftMode` in the draft API route, so `context.draftMode` will
be `true`.

If you’re also using `getStaticPaths`, then `context.params` will also be
available.

You can update `getStaticProps` to fetch different data based on
`context.draftMode`.

For example, your headless CMS might have a different API endpoint for draft
posts. If so, you can modify the API endpoint URL like below:

    
    
    export async function getStaticProps(context) {
      const url = context.draftMode
        ? 'https://draft.example.com'
        : 'https://production.example.com';
      const res = await fetch(url);
      // ...
    }

That’s it! If you access the draft API route (with `secret` and `slug`) from
your headless CMS or manually, you should now be able to see the draft
content. And if you update your draft without publishing, you should be able
to view the draft.

Set this as the draft URL on your headless CMS or access manually, and you
should be able to see the draft.

    
    
    https://<your-site>/api/draft?secret=<token>&slug=<path>

By default, the Draft Mode session ends when the browser is closed.

To clear the Draft Mode cookie manually, create an API route that calls
`setDraftMode({ enable: false })`:

    
    
    export default function handler(req, res) {
      res.setDraftMode({ enable: false });
    }

Then, send a request to `/api/disable-draft` to invoke the API Route. If
calling this route using `next/link`, you must pass `prefetch={false}` to
prevent accidentally deleting the cookie on prefetch.

Draft Mode works with `getServerSideProps` as well. It will also be available
on the `context` object containing `draftMode`

API Routes will have access to `draftMode` on the request object. For example:

    
    
    export default function myApiRoute(req, res) {
      if (req.draftMode) {
        // get draft data
      }
    }

A new bypass cookie value will be generated each time you run `next build`.

This ensures that the bypass cookie can’t be guessed.

> **Note** : To test Draft Mode locally over HTTP, your browser will need to
> allow third-party cookies and local storage access.





# Error Handling

This documentation explains how you can handle development, server-side, and
client-side errors.

When there is a runtime error during the development phase of your Next.js
application, you will encounter an **overlay**. It is a modal that covers the
webpage. It is **only** visible when the development server runs using `next
dev` via `pnpm dev`, `npm run dev`, or `yarn dev` and will not be shown in
production. Fixing the error will automatically dismiss the overlay.

Here is an example of an overlay:

![Example of an overlay when in development
mode](https://assets.vercel.com/image/upload/v1645118290/docs-
assets/static/docs/error-handling/overlay.png)

Next.js provides a static 500 page by default to handle server-side errors
that occur in your application. You can also customize this page by creating a
`pages/500.js` file.

Having a 500 page in your application does not show specific errors to the app
user.

You can also use 404 page to handle specific runtime error like `file not
found`.

React Error Boundaries is a graceful way to handle a JavaScript error on the
client so that the other parts of the application continue working. In
addition to preventing the page from crashing, it allows you to provide a
custom fallback component and even log error information.

To use Error Boundaries for your Next.js application, you must create a class
component `ErrorBoundary` and wrap the `Component` prop in the `pages/_app.js`
file. This component will be responsible to:

  * Render a fallback UI after an error is thrown
  * Provide a way to reset the Application's state
  * Log error information

You can create an `ErrorBoundary` class component by extending
`React.Component`. For example:

    
    
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
     
        // Define a state variable to track whether is an error or not
        this.state = { hasError: false };
      }
      static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI
     
        return { hasError: true };
      }
      componentDidCatch(error, errorInfo) {
        // You can use your own error logging service here
        console.log({ error, errorInfo });
      }
      render() {
        // Check if the error is thrown
        if (this.state.hasError) {
          // You can render any custom fallback UI
          return (
            <div>
              <h2>Oops, there is an error!</h2>
              <button
                type="button"
                onClick={() => this.setState({ hasError: false })}
              >
                Try again?
              </button>
            </div>
          );
        }
     
        // Return children components in case of no error
     
        return this.props.children;
      }
    }
     
    export default ErrorBoundary;

The `ErrorBoundary` component keeps track of an `hasError` state. The value of
this state variable is a boolean. When the value of `hasError` is `true`, then
the `ErrorBoundary` component will render a fallback UI. Otherwise, it will
render the children components.

After creating an `ErrorBoundary` component, import it in the `pages/_app.js`
file to wrap the `Component` prop in your Next.js application.

    
    
    // Import the ErrorBoundary component
    import ErrorBoundary from '../components/ErrorBoundary';
     
    function MyApp({ Component, pageProps }) {
      return (
        // Wrap the Component prop with ErrorBoundary component
        <ErrorBoundary>
          <Component {...pageProps} />
        </ErrorBoundary>
      );
    }
     
    export default MyApp;

You can learn more about Error Boundaries in React's documentation.

To monitor client errors, use a service like Sentry, Bugsnag or Datadog.





# Debugging

This documentation explains how you can debug your Next.js frontend and
backend code with full source maps support using either the VS Code debugger
or Chrome DevTools.

Any debugger that can attach to Node.js can also be used to debug a Next.js
application. You can find more details in the Node.js Debugging Guide.

Create a file named `.vscode/launch.json` at the root of your project with the
following content:

    
    
    {
      "version": "0.2.0",
      "configurations": [
        {
          "name": "Next.js: debug server-side",
          "type": "node-terminal",
          "request": "launch",
          "command": "npm run dev"
        },
        {
          "name": "Next.js: debug client-side",
          "type": "chrome",
          "request": "launch",
          "url": "http://localhost:3000"
        },
        {
          "name": "Next.js: debug full stack",
          "type": "node-terminal",
          "request": "launch",
          "command": "npm run dev",
          "serverReadyAction": {
            "pattern": "started server on .+, url: (https?://.+)",
            "uriFormat": "%s",
            "action": "debugWithChrome"
          }
        }
      ]
    }

`npm run dev` can be replaced with `yarn dev` if you're using Yarn. If you're
changing the port number your application starts on, replace the `3000` in
`http://localhost:3000` with the port you're using instead.

Now go to the Debug panel (`Ctrl+Shift+D` on Windows/Linux, `⇧+⌘+D` on macOS),
select a launch configuration, then press `F5` or select **Debug: Start
Debugging** from the Command Palette to start your debugging session.

Click the drop down menu listing the runtime configuration, and click `Edit
Configurations...`. Create a `Javascript Debug` debug configuration with
`http://localhost:3000` as the URL. Customize to your liking (e.g. Browser for
debugging, store as project file), and click `OK`. Run this debug
configuration, and the selected browser should automatically open. At this
point, you should have 2 applications in debug mode: the NextJS node
application, and the client/ browser application.

Start your development server as usual by running `next dev`, `npm run dev`,
or `yarn dev`. Once the server starts, open `http://localhost:3000` (or your
alternate URL) in Chrome. Next, open Chrome's Developer Tools (`Ctrl+Shift+J`
on Windows/Linux, `⌥+⌘+I` on macOS), then go to the **Sources** tab.

Now, any time your client-side code reaches a `debugger` statement, code
execution will pause and that file will appear in the debug area. You can also
press `Ctrl+P` on Windows/Linux or `⌘+P` on macOS to search for a file and set
breakpoints manually. Note that when searching here, your source files will
have paths starting with `webpack://_N_E/./`.

To debug server-side Next.js code with Chrome DevTools, you need to pass the
`--inspect` flag to the underlying Node.js process:

    
    
    NODE_OPTIONS='--inspect' next dev

If you're using `npm run dev` or `yarn dev` then you should update the `dev`
script on your `package.json`:

    
    
    "dev": "NODE_OPTIONS='--inspect' next dev"

Launching the Next.js dev server with the `--inspect` flag will look something
like this:

    
    
    Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95
    For help, see: https://nodejs.org/en/docs/inspector
    ready - started server on 0.0.0.0:3000, url: http://localhost:3000

> Be aware that running `NODE_OPTIONS='--inspect' npm run dev` or
> `NODE_OPTIONS='--inspect' yarn dev` won't work. This would try to start
> multiple debuggers on the same port: one for the npm/yarn process and one
> for Next.js. You would then get an error like `Starting inspector on
> 127.0.0.1:9229 failed: address already in use` in your console.

Once the server starts, open a new tab in Chrome and visit `chrome://inspect`,
where you should see your Next.js application inside the **Remote Target**
section. Click **inspect** under your application to open a separate DevTools
window, then go to the **Sources** tab.

Debugging server-side code here works much like debugging client-side code
with Chrome DevTools, except that when you search for files here with `Ctrl+P`
or `⌘+P`, your source files will have paths starting with
`webpack://{application-name}/./` (where `{application-name}` will be replaced
with the name of your application according to your `package.json` file).

Windows users may run into an issue when using `NODE_OPTIONS='--inspect'` as
that syntax is not supported on Windows platforms. To get around this, install
the `cross-env` package as a development dependency (`-D` with `npm` and
`yarn`) and replace the `dev` script with the following.

    
    
    "dev": "cross-env NODE_OPTIONS='--inspect' next dev",

`cross-env` will set the `NODE_OPTIONS` environment variable regardless of
which platform you are on (including Mac, Linux, and Windows) and allow you to
debug consistently across devices and operating systems.

> **Note** : Ensure Windows Defender is disabled on your machine. This
> external service will check _every file read_ , which has been reported to
> greatly increase Fast Refresh time with `next dev`. This is a known issue,
> not related to Next.js, but it does affect Next.js development.

To learn more about how to use a JavaScript debugger, take a look at the
following documentation:



  
  
# Preview Mode (Legacy)

> **Warning** : This feature is **legacy** and is superseded by Draft Mode.

**Examples**

In the Pages documentation and the Data Fetching documentation, we talked
about how to pre-render a page at build time ( **Static Generation** ) using
`getStaticProps` and `getStaticPaths`.

Static Generation is useful when your pages fetch data from a headless CMS.
However, it’s not ideal when you’re writing a draft on your headless CMS and
want to **preview** the draft immediately on your page. You’d want Next.js to
render these pages at **request time** instead of build time and fetch the
draft content instead of the published content. You’d want Next.js to bypass
Static Generation only for this specific case.

Next.js has a feature called **Preview Mode** which solves this problem. Here
are instructions on how to use it.

> Take a look at the API Routes documentation first if you’re not familiar
> with Next.js API Routes.

First, create a **preview API route**. It can have any name - e.g.
`pages/api/preview.js` (or `.ts` if using TypeScript).

In this API route, you need to call `setPreviewData` on the response object.
The argument for `setPreviewData` should be an object, and this can be used by
`getStaticProps` (more on this later). For now, we’ll use `{}`.

    
    
    export default function handler(req, res) {
      // ...
      res.setPreviewData({});
      // ...
    }

`res.setPreviewData` sets some **cookies** on the browser which turns on the
preview mode. Any requests to Next.js containing these cookies will be
considered as the **preview mode** , and the behavior for statically generated
pages will change (more on this later).

You can test this manually by creating an API route like below and accessing
it from your browser manually:

    
    
    // simple example for testing it manually from your browser.
    export default function handler(req, res) {
      res.setPreviewData({});
      res.end('Preview mode enabled');
    }

If you open your browser’s developer tools and visit `/api/preview`, you’ll
notice that the `__prerender_bypass` and `__next_preview_data` cookies will be
set on this request.

In practice, you’d want to call this API route _securely_ from your headless
CMS. The specific steps will vary depending on which headless CMS you’re
using, but here are some common steps you could take.

These steps assume that the headless CMS you’re using supports setting
**custom preview URLs**. If it doesn’t, you can still use this method to
secure your preview URLs, but you’ll need to construct and access the preview
URL manually.

**First** , you should create a **secret token string** using a token
generator of your choice. This secret will only be known by your Next.js app
and your headless CMS. This secret prevents people who don’t have access to
your CMS from accessing preview URLs.

**Second** , if your headless CMS supports setting custom preview URLs,
specify the following as the preview URL. This assumes that your preview API
route is located at `pages/api/preview.js`.

    
    
    https://<your-site>/api/preview?secret=<token>&slug=<path>

  * `<your-site>` should be your deployment domain.
  * `<token>` should be replaced with the secret token you generated.
  * `<path>` should be the path for the page that you want to preview. If you want to preview `/posts/foo`, then you should use `&slug=/posts/foo`.

Your headless CMS might allow you to include a variable in the preview URL so
that `<path>` can be set dynamically based on the CMS’s data like so:
`&slug=/posts/{entry.fields.slug}`

**Finally** , in the preview API route:

  * Check that the secret matches and that the `slug` parameter exists (if not, the request should fail).
  *   * Call `res.setPreviewData`.
  * Then redirect the browser to the path specified by `slug`. (The following example uses a 307 redirect).

    
    
    export default async (req, res) => {
      // Check the secret and next parameters
      // This secret should only be known to this API route and the CMS
      if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {
        return res.status(401).json({ message: 'Invalid token' });
      }
     
      // Fetch the headless CMS to check if the provided `slug` exists
      // getPostBySlug would implement the required fetching logic to the headless CMS
      const post = await getPostBySlug(req.query.slug);
     
      // If the slug doesn't exist prevent preview mode from being enabled
      if (!post) {
        return res.status(401).json({ message: 'Invalid slug' });
      }
     
      // Enable Preview Mode by setting the cookies
      res.setPreviewData({});
     
      // Redirect to the path from the fetched post
      // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities
      res.redirect(post.slug);
    };

If it succeeds, then the browser will be redirected to the path you want to
preview with the preview mode cookies being set.

The next step is to update `getStaticProps` to support the preview mode.

If you request a page which has `getStaticProps` with the preview mode cookies
set (via `res.setPreviewData`), then `getStaticProps` will be called at
**request time** (instead of at build time).

Furthermore, it will be called with a `context` object where:

  * `context.preview` will be `true`.
  * `context.previewData` will be the same as the argument used for `setPreviewData`.

    
    
    export async function getStaticProps(context) {
      // If you request this page with the preview mode cookies set:
      //
      // - context.preview will be true
      // - context.previewData will be the same as
      //   the argument used for `setPreviewData`.
    }

We used `res.setPreviewData({})` in the preview API route, so
`context.previewData` will be `{}`. You can use this to pass session
information from the preview API route to `getStaticProps` if necessary.

If you’re also using `getStaticPaths`, then `context.params` will also be
available.

You can update `getStaticProps` to fetch different data based on
`context.preview` and/or `context.previewData`.

For example, your headless CMS might have a different API endpoint for draft
posts. If so, you can use `context.preview` to modify the API endpoint URL
like below:

    
    
    export async function getStaticProps(context) {
      // If context.preview is true, append "/preview" to the API endpoint
      // to request draft data instead of published data. This will vary
      // based on which headless CMS you're using.
      const res = await fetch(`https://.../${context.preview ? 'preview' : ''}`);
      // ...
    }

That’s it! If you access the preview API route (with `secret` and `slug`) from
your headless CMS or manually, you should now be able to see the preview
content. And if you update your draft without publishing, you should be able
to preview the draft.

Set this as the preview URL on your headless CMS or access manually, and you
should be able to see the preview.

    
    
    https://<your-site>/api/preview?secret=<token>&slug=<path>

> **Note** : during rendering `next/router` exposes an `isPreview` flag, see
> the router object docs for more info.

`setPreviewData` takes an optional second parameter which should be an options
object. It accepts the following keys:

  * `maxAge`: Specifies the number (in seconds) for the preview session to last for.
  * `path`: Specifies the path the cookie should be applied under. Defaults to `/` enabling preview mode for all paths.

    
    
    setPreviewData(data, {
      maxAge: 60 * 60, // The preview mode cookies expire in 1 hour
      path: '/about', // The preview mode cookies apply to paths with /about
    });

By default, no expiration date is set for Preview Mode cookies, so the preview
session ends when the browser is closed.

To clear the Preview Mode cookies manually, create an API route that calls
`clearPreviewData()`:

    
    
    export default function handler(req, res) {
      res.clearPreviewData({});
    }

Then, send a request to `/api/clear-preview-mode-cookies` to invoke the API
Route. If calling this route using `next/link`, you must pass
`prefetch={false}` to prevent calling `clearPreviewData` during link
prefetching.

If a path was specified in the `setPreviewData` call, you must pass the same
path to `clearPreviewData`:

    
    
    export default function handler(req, res) {
      const { path } = req.query;
     
      res.clearPreviewData({ path });
    }

You can pass an object to `setPreviewData` and have it be available in
`getStaticProps`. However, because the data will be stored in a cookie,
there’s a size limitation. Currently, preview data is limited to 2KB.

The preview mode works on `getServerSideProps` as well. It will also be
available on the `context` object containing `preview` and `previewData`.

API Routes will have access to `preview` and `previewData` under the request
object. For example:

    
    
    export default function myApiRoute(req, res) {
      const isPreview = req.preview;
      const previewData = req.previewData;
      // ...
    }

Both the bypass cookie value and the private key for encrypting the
`previewData` change when `next build` is completed. This ensures that the
bypass cookie can’t be guessed.

> **Note** : To test Preview Mode locally over HTTP your browser will need to
> allow third-party cookies and local storage access.





# Deploying

Congratulations! You're here because you are ready to deploy your Next.js
application. This page will show how to deploy either managed or self-hosted
using the Next.js Build API.

`next build` generates an optimized version of your application for
production. This standard output includes:

  * HTML files for pages using `getStaticProps` or Automatic Static Optimization
  * CSS files for global styles or for individually scoped styles
  * JavaScript for pre-rendering dynamic content from the Next.js server
  * JavaScript for interactivity on the client-side through React

This output is generated inside the `.next` folder:

  * `.next/static/chunks/pages` – Each JavaScript file inside this folder relates to the route with the same name. For example, `.next/static/chunks/pages/about.js` would be the JavaScript file loaded when viewing the `/about` route in your application
  * `.next/static/media` – Statically imported images from `next/image` are hashed and copied here
  * `.next/static/css` – Global CSS files for all pages in your application
  * `.next/server/pages` – The HTML and JavaScript entry points prerendered from the server. The `.nft.json` files are created when Output File Tracing is enabled and contain all the file paths that depend on a given page.
  * `.next/server/chunks` – Shared JavaScript chunks used in multiple places throughout your application
  * `.next/cache` – Output for the build cache and cached images, responses, and pages from the Next.js server. Using a cache helps decrease build times and improve performance of loading images

All JavaScript code inside `.next` has been **compiled** and browser bundles
have been **minified** to help achieve the best performance and support all
modern browsers.

Vercel is the fastest way to deploy your Next.js application with zero
configuration.

When deploying to Vercel, the platform automatically detects Next.js, runs
`next build`, and optimizes the build output for you, including:

In addition, Vercel provides features like:

Deploy a Next.js application to Vercel for free to try it out.

You can self-host Next.js with support for all features using Node.js or
Docker. You can also do a Static HTML Export, which has some limitations.

Next.js can be deployed to any hosting provider that supports Node.js. For
example, AWS EC2 or a DigitalOcean Droplet.

First, ensure your `package.json` has the `"build"` and `"start"` scripts:

    
    
    {
      "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start"
      }
    }

Then, run `npm run build` to build your application. Finally, run `npm run
start` to start the Node.js server. This server supports all features of
Next.js.

> If you are using `next/image`, consider adding `sharp` for more performant
> Image Optimization in your production environment by running `npm install
> sharp` in your project directory. On Linux platforms, `sharp` may require
> additional configuration to prevent excessive memory usage.

Next.js can be deployed to any hosting provider that supports Docker
containers. You can use this approach when deploying to container
orchestrators such as Kubernetes or HashiCorp Nomad, or when running inside a
single node in any cloud provider.

  1. Install Docker on your machine
  2. Clone the with-docker example
  3. Build your container: `docker build -t nextjs-docker .`
  4. Run your container: `docker run -p 3000:3000 nextjs-docker`

If you need to use different Environment Variables across multiple
environments, check out our with-docker-multi-env example.

If you’d like to do a static HTML export of your Next.js app, follow the
directions on our Static HTML Export documentation.

The following services support Next.js `v12+`. Below, you’ll find examples or
guides to deploy Next.js to each service.

> **Note** : There are also managed platforms that allow you to use a
> Dockerfile as shown in the example above.

The following services only support deploying Next.js using `output:
'export'`.

You can also manually deploy the output from `output: 'export'` to any static
hosting provider, often through your CI/CD pipeline like GitHub Actions,
Jenkins, AWS CodeBuild, Circle CI, Azure Pipelines, and more.

> **Note** : Not all serverless providers implement the Next.js Build API from
> `next start`. Please check with the provider to see what features are
> supported.

When you deploy your Next.js application, you want to see the latest version
without needing to reload.

Next.js will automatically load the latest version of your application in the
background when routing. For client-side navigations, `next/link` will
temporarily function as a normal `<a>` tag.

**Note** : If a new page (with an old version) has already been prefetched by
`next/link`, Next.js will use the old version. Navigating to a page that has
_not_ been prefetched (and is not cached at the CDN level) will load the
latest version.

Sometimes you might want to run some cleanup code on process signals like
`SIGTERM` or `SIGINT`.

You can do that by setting the env variable `NEXT_MANUAL_SIG_HANDLE` to `true`
and then register a handler for that signal inside your `_document.js` file.
Please note that you need to register env variable directly in the system env
variable, not in the `.env` file.

    
    
    {
      "scripts": {
        "dev": "NEXT_MANUAL_SIG_HANDLE=true next dev",
        "build": "next build",
        "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
      }
    }
    
    
    if (process.env.NEXT_MANUAL_SIG_HANDLE) {
      // this should be added in your custom _document
      process.on('SIGTERM', () => {
        console.log('Received SIGTERM: ', 'cleaning up');
        process.exit(0);
      });
     
      process.on('SIGINT', () => {
        console.log('Received SIGINT: ', 'cleaning up');
        process.exit(0);
      });
    }





# Going to Production

Before taking your Next.js application to production, here are some
recommendations to ensure the best user experience.

  * Use caching wherever possible.
  * Ensure your database and backend are deployed in the same region.
  * Aim to ship the least amount of JavaScript possible.
  * Defer loading heavy JavaScript bundles until needed.
  * Ensure logging is set up.
  * Ensure error handling is set up.
  * Configure the 404 (Not Found) and 500 (Error) pages.
  * Ensure you are measuring performance.
  * Run Lighthouse to check for performance, best practices, accessibility, and SEO. For best results, use a production build of Next.js and use incognito in your browser so results aren't affected by extensions.
  * Review Supported Browsers and Features.
  * Improve performance using: 
  * Improve loading performance

**Examples**

Caching improves response times and reduces the number of requests to external
services. Next.js automatically adds caching headers to immutable assets
served from `/_next/static` including JavaScript, CSS, static images, and
other media.

    
    
    Cache-Control: public, max-age=31536000, immutable

`Cache-Control` headers set in `next.config.js` will be overwritten in
production to ensure that static assets can be cached effectively. If you need
to revalidate the cache of a page that has been statically generated, you can
do so by setting `revalidate` in the page's `getStaticProps` function. If
you're using `next/image`, you can configure the `minimumCacheTTL` for the
default Image Optimization loader.

> **Note** : When running your application locally with `next dev`, your
> headers are overwritten to prevent caching locally.
    
    
    Cache-Control: no-cache, no-store, max-age=0, must-revalidate

You can also use caching headers inside `getServerSideProps` and API Routes
for dynamic responses. For example, using `stale-while-revalidate`.

    
    
    // This value is considered fresh for ten seconds (s-maxage=10).
    // If a request is repeated within the next 10 seconds, the previously
    // cached value will still be fresh. If the request is repeated before 59 seconds,
    // the cached value will be stale but still render (stale-while-revalidate=59).
    //
    // In the background, a revalidation request will be made to populate the cache
    // with a fresh value. If you refresh the page, you will see the new value.
    export async function getServerSideProps({ req, res }) {
      res.setHeader(
        'Cache-Control',
        'public, s-maxage=10, stale-while-revalidate=59',
      );
     
      return {
        props: {},
      };
    }

By default, `Cache-Control` headers will be set differently depending on how
your page fetches data.

  * If the page uses `getServerSideProps` or `getInitialProps`, it will use the default `Cache-Control` header set by `next start` in order to prevent accidental caching of responses that cannot be cached. If you want a different cache behavior while using `getServerSideProps`, use `res.setHeader('Cache-Control', 'value_you_prefer')` inside of the function as shown above.
  * If the page is using `getStaticProps`, it will have a `Cache-Control` header of `s-maxage=REVALIDATE_SECONDS, stale-while-revalidate`, or if `revalidate` is _not_ used, `s-maxage=31536000, stale-while-revalidate` to cache for the maximum age possible.

> **Note** : Your deployment provider must support caching for dynamic
> responses. If you are self-hosting, you will need to add this logic yourself
> using a key/value store like Redis. If you are using Vercel, Edge Caching
> works without configuration.

**Examples**

To reduce the amount of JavaScript sent to the browser, you can use the
following tools to understand what is included inside each JavaScript bundle:

  * Import Cost – Display the size of the imported package inside VSCode.
  * Package Phobia – Find the cost of adding a new dev dependency to your project.
  * Bundle Phobia \- Analyze how much a dependency can increase bundle sizes.
  * Webpack Bundle Analyzer – Visualize the size of webpack output files with an interactive, zoomable treemap.
  * bundlejs \- An online tool to quickly bundle & minify your projects, while viewing the compressed gzip/brotli bundle size, all running locally on your browser.

Each file inside your `pages/` directory will automatically be code split into
its own JavaScript bundle during `next build`. You can also use Dynamic
Imports to lazy-load components and libraries. For example, you might want to
defer loading your modal code until a user clicks the open button.

**Examples**

Since Next.js runs on both the client and server, there are multiple forms of
logging supported:

  * `console.log` in the browser
  * `stdout` on the server

If you want a structured logging package, we recommend Pino. If you're using
Vercel, there are pre-built logging integrations compatible with Next.js.

**Examples**

When an unhandled exception occurs, you can control the experience for your
users with the 500 page. We recommend customizing this to your brand instead
of the default Next.js theme.

You can also log and track exceptions with a tool like Sentry. This example
shows how to catch & report errors on both the client and server-side, using
the Sentry SDK for Next.js. There's also a Sentry integration for Vercel.

To improve loading performance, you first need to determine what to measure
and how to measure it. Core Web Vitals is a good industry standard that is
measured using your own web browser. If you are not familiar with the metrics
of Core Web Vitals, review this blog post and determine which specific
metric/s will be your drivers for loading performance. Ideally, you would want
to measure the loading performance in the following environments:

  * In the lab, using your own computer or a simulator.
  * In the field, using real-world data from actual visitors.
  * Local, using a test that runs on your device.
  * Remote, using a test that runs in the cloud.

Once you are able to measure the loading performance, use the following
strategies to improve it iteratively so that you apply one strategy, measure
the new performance and continue tweaking until you do not see much
improvement. Then, you can move on to the next strategy.

  * Use caching regions that are close to the regions where your database or API is deployed.
  * As described in the caching section, use a `stale-while-revalidate` value that will not overload your backend.
  * Use Incremental Static Regeneration to reduce the number of requests to your backend.
  * Remove unused JavaScript. Review this blog post to understand what Core Web Vitals metrics bundle size affects and what strategies you can use to reduce it, such as: 
    * Setting up your Code Editor to view import costs and sizes
    * Finding alternative smaller packages
    * Dynamically loading components and dependencies





# Static Exports

Next.js enables starting as a static site or Single-Page Application (SPA),
then later optionally upgrading to use features that require a server.

When running `next build`, Next.js generates an HTML file per route. By
breaking a strict SPA into individual HTML files, Next.js can avoid loading
unnecessary JavaScript code on the client-side, reducing the bundle size and
enabling faster page loads.

Since Next.js supports this static export, it can be deployed and hosted on
any web server that can serve HTML/CSS/JS static assets.

> **Note:** We recommend using the App Router for enhanced static export
> support.

To enable a static export, change the output mode inside `next.config.js`:

    
    
    /**
     * @type {import('next').NextConfig}
     */
    const nextConfig = {
      output: 'export',
      // Optional: Add a trailing slash to all paths `/about` -> `/about/`
      // trailingSlash: true,
      // Optional: Change the output directory `out` -> `dist`
      // distDir: 'dist',
    };
     
    module.exports = nextConfig;

After running `next build`, Next.js will produce an `out` folder which
contains the HTML/CSS/JS assets for your application.

You can utilize `getStaticProps` and `getStaticPaths` to generate an HTML file
for each page in your `pages` directory (or more for dynamic routes).

The majority of core Next.js features needed to build a static site are
supported, including:

Image Optimization through `next/image` can be used with a static export by
defining a custom image loader in `next.config.js`. For example, you can
optimize images with a service like Cloudinary:

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      output: 'export',
      images: {
        loader: 'custom',
        loaderFile: './app/image.ts',
      },
    };
     
    module.exports = nextConfig;

This custom loader will define how to fetch images from a remote source. For
example, the following loader will construct the URL for Cloudinary:

    
    
    export default function cloudinaryLoader({
      src,
      width,
      quality,
    }: {
      src: string;
      width: number;
      quality?: number;
    }) {
      const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
      return `https://res.cloudinary.com/demo/image/upload/${params.join(
        ',',
      )}${src}`;
    }

You can then use `next/image` in your application, defining relative paths to
the image in Cloudinary:

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return <Image alt="turtles" src="/turtles.jpg" width={300} height={300} />;
    }

Features that require a Node.js server, or dynamic logic that cannot be
computed during the build process, are not supported:

With a static export, Next.js can be deployed and hosted on any web server
that can serve HTML/CSS/JS static assets.

When running `next build`, Next.js generates the static export into the `out`
folder. Using `next export` is no longer needed. For example, let's say you
have the following routes:

After running `next build`, Next.js will generate the following files:

  * `/out/index.html`
  * `/out/404.html`
  * `/out/blog/post-1.html`
  * `/out/blog/post-2.html`

If you are using a static host like Nginx, you can configure rewrites from
incoming requests to the correct files:

    
    
    server {
      listen 80;
      server_name acme.com;
     
      root /var/www;
     
      location / {
          try_files /out/index.html =404;
      }
     
      location /blog/ {
          rewrite ^/blog/(.*)$ /out/blog/$1.html break;
      }
     
      error_page 404 /out/404.html;
      location = /404.html {
          internal;
      }
    }

Version| Changes  
---|---  
`v13.4.0`| App Router (Stable) adds enhanced static export support, including
using React Server Components and Route Handlers  
`v13.3.0`| `next export` is deprecated and replaced with `"output": "export"`





Using Pages Router

Features available in /pages





# Continuous Integration (CI) Build Caching

To improve build performance, Next.js saves a cache to `.next/cache` that is
shared between builds.

To take advantage of this cache in Continuous Integration (CI) environments,
your CI workflow will need to be configured to correctly persist the cache
between builds.

> If your CI is not configured to persist `.next/cache` between builds, you
> may see a No Cache Detected error.

Here are some example cache configurations for common CI providers:

Next.js caching is automatically configured for you. There's no action
required on your part.

Edit your `save_cache` step in `.circleci/config.yml` to include
`.next/cache`:

    
    
    steps:
      - save_cache:
          key: dependency-cache-{{ checksum "yarn.lock" }}
          paths:
            - ./node_modules
            - ./.next/cache

If you do not have a `save_cache` key, please follow CircleCI's documentation
on setting up build caching.

Add or merge the following into your `.travis.yml`:

    
    
    cache:
      directories:
        - $HOME/.cache/yarn
        - node_modules
        - .next/cache

Add or merge the following into your `.gitlab-ci.yml`:

    
    
    cache:
      key: ${CI_COMMIT_REF_SLUG}
      paths:
        - node_modules/
        - .next/cache/

Use Netlify Plugins with `@netlify/plugin-nextjs`.

Add (or merge in) the following to your `buildspec.yml`:

    
    
    cache:
      paths:
        - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`
        - '.next/cache/**/*' # Cache Next.js for faster application rebuilds

Using GitHub's actions/cache, add the following step in your workflow file:

    
    
    uses: actions/cache@v3
    with:
      # See here for caching with `yarn` https://github.com/actions/cache/blob/main/examples#node---yarn or you can leverage caching with actions/setup-node https://github.com/actions/setup-node
      path: |
        ~/.npm
        ${{ github.workspace }}/.next/cache
      # Generate a new cache whenever packages or source files change.
      key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}
      # If source files changed but packages didn't, rebuild from a prior cache.
      restore-keys: |
        ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-

Add or merge the following into your `bitbucket-pipelines.yml` at the top
level (same level as `pipelines`):

    
    
    definitions:
      caches:
        nextcache: .next/cache

Then reference it in the `caches` section of your pipeline's `step`:

    
    
    - step:
        name: your_step_name
        caches:
          - node
          - nextcache

Using Heroku's custom cache, add a `cacheDirectories` array in your top-level
package.json:

    
    
    "cacheDirectories": [".next/cache"]

Using Azure Pipelines' Cache task, add the following task to your pipeline
yaml file somewhere prior to the task that executes `next build`:

    
    
    - task: Cache@2
      displayName: 'Cache .next/cache'
      inputs:
        key: next | $(Agent.OS) | yarn.lock
        path: '$(System.DefaultWorkingDirectory)/.next/cache'





Using Pages Router

Features available in /pages





# Codemods

Codemods are transformations that run on your codebase programmatically. This
allows a large number of changes to be programmatically applied without having
to manually go through every file.

Next.js provides Codemod transformations to help upgrade your Next.js codebase
when an API is updated or deprecated.

In your terminal, navigate (`cd`) into your project's folder, then run:

    
    
    npx @next/codemod <transform> <path>

Replacing `<transform>` and `<path>` with appropriate values.

  * `transform` \- name of transform
  * `path` \- files or directory to transform
  * `--dry` Do a dry-run, no code will be edited
  * `--print` Prints the changed output for comparison

    
    
    npx @next/codemod@latest built-in-next-font

This codemod uninstalls the `@next/font` package and transforms `@next/font`
imports into the built-in `next/font`.

For example:

    
    
    import { Inter } from '@next/font/google';

Transforms into:

    
    
    import { Inter } from 'next/font/google';
    
    
    npx @next/codemod@latest next-image-to-legacy-image ./pages

Safely renames `next/image` imports in existing Next.js 10, 11, or 12
applications to `next/legacy/image` in Next.js 13. Also renames
`next/future/image` to `next/image`.

For example:

    
    
    import Image1 from 'next/image';
    import Image2 from 'next/future/image';
     
    export default function Home() {
      return (
        <div>
          <Image1 src="/test.jpg" width="200" height="300" />
          <Image2 src="/test.png" width="500" height="400" />
        </div>
      );
    }

Transforms into:

    
    
    // 'next/image' becomes 'next/legacy/image'
    import Image1 from 'next/legacy/image';
    // 'next/future/image' becomes 'next/image'
    import Image2 from 'next/image';
     
    export default function Home() {
      return (
        <div>
          <Image1 src="/test.jpg" width="200" height="300" />
          <Image2 src="/test.png" width="500" height="400" />
        </div>
      );
    }
    
    
    npx @next/codemod@latest next-image-experimental ./pages

Dangerously migrates from `next/legacy/image` to the new `next/image` by
adding inline styles and removing unused props.

  * Removes `layout` prop and adds `style`.
  * Removes `objectFit` prop and adds `style`.
  * Removes `objectPosition` prop and adds `style`.
  * Removes `lazyBoundary` prop.
  * Removes `lazyRoot` prop.

    
    
    npx @next/codemod@latest new-link ./pages

Remove `<a>` tags inside Link Components, or add a `legacyBehavior` prop to
Links that cannot be auto-fixed.

For example:

    
    
    <Link href="/about">
      <a>About</a>
    </Link>
    // transforms into
    <Link href="/about">
      About
    </Link>
     
    <Link href="/about">
      <a onClick={() => console.log('clicked')}>About</a>
    </Link>
    // transforms into
    <Link href="/about" onClick={() => console.log('clicked')}>
      About
    </Link>

In cases where auto-fixing can't be applied, the `legacyBehavior` prop is
added. This allows your app to keep functioning using the old behavior for
that particular link.

    
    
    const Component = () => <a>About</a>
     
    <Link href="/about">
      <Component />
    </Link>
    // becomes
    <Link href="/about" legacyBehavior>
      <Component />
    </Link>
    
    
    npx @next/codemod cra-to-next

Migrates a Create React App project to Next.js; creating a Pages Router and
necessary config to match behavior. Client-side only rendering is leveraged
initially to prevent breaking compatibility due to `window` usage during SSR
and can be enabled seamlessly to allow the gradual adoption of Next.js
specific features.

Please share any feedback related to this transform in this discussion.

    
    
    npx @next/codemod add-missing-react-import

Transforms files that do not import `React` to include the import in order for
the new React JSX transform to work.

For example:

    
    
    export default class Home extends React.Component {
      render() {
        return <div>Hello World</div>;
      }
    }

Transforms into:

    
    
    import React from 'react';
    export default class Home extends React.Component {
      render() {
        return <div>Hello World</div>;
      }
    }
    
    
    npx @next/codemod name-default-component

**Versions 9 and above.**

Transforms anonymous components into named components to make sure they work
with Fast Refresh.

For example:

    
    
    export default function () {
      return <div>Hello World</div>;
    }

Transforms into:

    
    
    export default function MyComponent() {
      return <div>Hello World</div>;
    }

The component will have a camel-cased name based on the name of the file, and
it also works with arrow functions.

    
    
    npx @next/codemod withamp-to-config

Transforms the `withAmp` HOC into Next.js 9 page configuration.

For example:

    
    
    // Before
    import { withAmp } from 'next/amp';
     
    function Home() {
      return <h1>My AMP Page</h1>;
    }
     
    export default withAmp(Home);
    
    
    // After
    export default function Home() {
      return <h1>My AMP Page</h1>;
    }
     
    export const config = {
      amp: true,
    };
    
    
    npx @next/codemod url-to-withrouter

Transforms the deprecated automatically injected `url` property on top level
pages to using `withRouter` and the `router` property it injects. Read more
here: https://nextjs.org/docs/messages/url-deprecated

For example:

    
    
    import React from 'react';
    export default class extends React.Component {
      render() {
        const { pathname } = this.props.url;
        return <div>Current pathname: {pathname}</div>;
      }
    }
    
    
    import React from 'react';
    import { withRouter } from 'next/router';
    export default withRouter(
      class extends React.Component {
        render() {
          const { pathname } = this.props.router;
          return <div>Current pathname: {pathname}</div>;
        }
      },
    );

This is one case. All the cases that are transformed (and tested) can be found
in the `__testfixtures__` directory.





# From Pages to App

This guide will help you:

The minimum Node.js version is now **v16.8**. See the Node.js documentation
for more information.

To update to Next.js version 13, run the following command using your
preferred package manager:

    
    
    npm install next@latest react@latest react-dom@latest

If you're using ESLint, you need to upgrade your ESLint version:

    
    
    npm install -D eslint-config-next@latest

> **Note:** You may need to restart the ESLint server in VS Code for the
> ESLint changes to take effect. Open the Command Palette (`cmd+shift+p` on
> Mac; `ctrl+shift+p` on Windows) and search for `ESLint: Restart ESLint
> Server`.

After you've updated, see the following sections for next steps:

Next.js 13 introduced the new App Router with new features and conventions.
The new Router is available in the `app` directory and co-exists with the
`pages` directory.

Upgrading to Next.js 13 does **not** require using the new App Router. You can
continue using `pages` with new features that work in both directories, such
as the updated Image component, Link component, Script component, and Font
optimization.

Next.js 12 introduced new improvements to the Image Component with a temporary
import: `next/future/image`. These improvements included less client-side
JavaScript, easier ways to extend and style images, better accessibility, and
native browser lazy loading.

In version 13, this new behavior is now the default for `next/image`.

There are two codemods to help you migrate to the new Image Component:

  * **`next-image-to-legacy-image` codemod**: Safely and automatically renames `next/image` imports to `next/legacy/image`. Existing components will maintain the same behavior.
  * **`next-image-experimental` codemod**: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run the `next-image-to-legacy-image` codemod first.

The `<Link>` Component no longer requires manually adding an `<a>` tag as a
child. This behavior was added as an experimental option in version 12.2 and
is now the default. In Next.js 13, `<Link>` always renders `<a>` and allows
you to forward props to the underlying tag.

For example:

    
    
    import Link from 'next/link'
     
    // Next.js 12: `<a>` has to be nested otherwise it's excluded
    <Link href="/about">
      <a>About</a>
    </Link>
     
    // Next.js 13: `<Link>` always renders `<a>` under the hood
    <Link href="/about">
      About
    </Link>

To upgrade your links to Next.js 13, you can use the `new-link` codemod.

The behavior of `next/script` has been updated to support both `pages` and
`app`, but some changes need to be made to ensure a smooth migration:

  * Move any `beforeInteractive` scripts you previously included in `_document.js` to the root layout file (`app/layout.tsx`).
  * The experimental `worker` strategy does not yet work in `app` and scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g. `lazyOnload`).
  * `onLoad`, `onReady`, and `onError` handlers will not work in Server Components so make sure to move them to a Client Component or remove them altogether.

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13
introduces the new `next/font` module which gives you the ability to customize
your font loading experience while still ensuring great performance and
privacy. `next/font` is supported in both the `pages` and `app` directories.

While inlining CSS still works in `pages`, it does not work in `app`. You
should use `next/font` instead.

See the Font Optimization page to learn how to use `next/font`.

Moving to the App Router may be the first time using React features that
Next.js builds on top of such as Server Components, Suspense, and more. When
combined with new Next.js features such as special files and layouts,
migration means new concepts, mental models, and behavioral changes to learn.

We recommend reducing the combined complexity of these updates by breaking
down your migration into smaller steps. The `app` directory is intentionally
designed to work simultaneously with the `pages` directory to allow for
incremental page-by-page migration.

  * The `app` directory supports nested routes _and_ layouts. Learn more.
  * Use nested folders to define routes and a special `page.js` file to make a route segment publicly accessible. Learn more.
  * Special file conventions are used to create UI for each route segment. The most common special files are `page.js` and `layout.js`. 
    * Use `page.js` to define UI unique to a route.
    * Use `layout.js` to define UI that is shared across multiple routes.
    * `.js`, `.jsx`, or `.tsx` file extensions can be used for special files.
  * You can colocate other files inside the `app` directory such as components, styles, tests, and more. Learn more.
  * Data fetching functions like `getServerSideProps` and `getStaticProps` have been replaced with a new API inside `app`. `getStaticPaths` has been replaced with `generateStaticParams`.
  * `pages/_app.js` and `pages/_document.js` have been replaced with a single `app/layout.js` root layout. Learn more.
  * `pages/_error.js` has been replaced with more granular `error.js` special files. Learn more.
  * `pages/404.js` has been replaced with the `not-found.js` file.
  * You can colocate other files inside the `app` directory such as components, styles, tests, and more. Learn more.
  * `pages/api/*` currently remain inside the `pages` directory.

Update to the latest Next.js version (requires 13.4 or greater):

Then, create a new `app` directory at the root of your project (or `src/`
directory).

Create a new `app/layout.tsx` file inside the `app` directory. This is a root
layout that will apply to all routes inside `app`.

    
    
    export default function RootLayout({
      // Layouts must accept a children prop.
      // This will be populated with nested layouts or pages
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

  * The `app` directory **must** include a root layout.
  * The root layout must define `<html>`, and `<body>` tags since Next.js does not automatically create them
  * The root layout replaces the `pages/_app.tsx` and `pages/_document.tsx` files.
  * `.js`, `.jsx`, or `.tsx` extensions can be used for layout files.

To manage `<head>` HTML elements, you can use the built-in SEO support:

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'Home',
      description: 'Welcome to Next.js',
    };

If you have an existing `_app` or `_document` file, you can copy the contents
(e.g. global styles) to the root layout (`app/layout.tsx`). Styles in
`app/layout.tsx` will _not_ apply to `pages/*`. You should keep
`_app`/`_document` while migrating to prevent your `pages/*` routes from
breaking. Once fully migrated, you can then safely delete them.

If you are using any React Context providers, they will need to be moved to a
Client Component.

Next.js recommended adding a property to Page components to achieve per-page
layouts in the `pages` directory. This pattern can be replaced with native
support for nested layouts in the `app` directory.

**See before and after example**

 **Before**

    
    
     export default function DashboardLayout({ children }) {
      return (
        <div>
          <h2>My Dashboard</h2>
          {children}
        </div>
      );
    }
    
    
    import DashboardLayout from '../components/DashboardLayout';
     
    export default function Page() {
      return <p>My Page</p>;
    }
     
    Page.getLayout = function getLayout(page) {
      return <DashboardLayout>{page}</DashboardLayout>;
    };

 **After**

  * Remove the `Page.getLayout` property from `pages/dashboard/index.js` and follow the steps for migrating pages to the `app` directory.
    
        export default function Page() {
      return <p>My Page</p>;
    }

  * Move the contents of `DashboardLayout` into a new Client Component to retain `pages` directory behavior.
    
        'use client'; // this directive should be at top of the file, before any imports.
     
    // This is a Client Component
    export default function DashboardLayout({ children }) {
      return (
        <div>
          <h2>My Dashboard</h2>
          {children}
        </div>
      );
    }

  * Import the `DashboardLayout` into a new `layout.js` file inside the `app` directory.
    
        import DashboardLayout from './DashboardLayout';
     
    // This is a Server Component
    export default function Layout({ children }) {
      return <DashboardLayout>{children}</DashboardLayout>;
    }

  * You can incrementally move non-interactive parts of `DashboardLayout.js` (Client Component) into `layout.js` (Server Component) to reduce the amount of component JavaScript you send to the client.

In the `pages` directory, the `next/head` React component is used to manage
`<head>` HTML elements such as `title` and `meta` . In the `app` directory,
`next/head` is replaced with the new built-in SEO support.

**Before:**

    
    
    import Head from 'next/head';
     
    export default function Page() {
      return (
        <>
          <Head>
            <title>My page title</title>
          </Head>
        </>
      );
    }

**After:**

    
    
    import { Metadata } from 'next';
     
    export const metadata: Metadata = {
      title: 'My Page Title',
    };
     
    export default function Page() {
      return '...';
    }

See all metadata options.

  * Pages in the `app` directory are Server Components by default. This is different from the `pages` directory where pages are Client Components.
  * Data fetching has changed in `app`. `getServerSideProps`, `getStaticProps` and `getInitialProps` have been replaced for a simpler API.
  * The `app` directory uses nested folders to define routes and a special `page.js` file to make a route segment publicly accessible.
  * `pages` Directory| `app` Directory| Route  
---|---|---  
`index.js`| `page.js`| `/`  
`about.js`| `about/page.js`| `/about`  
`blog/[slug].js`| `blog/[slug]/page.js`| `/blog/post-1`  

We recommend breaking down the migration of a page into two main steps:

  * Step 1: Move the default exported Page Component into a new Client Component.
  * Step 2: Import the new Client Component into a new `page.js` file inside the `app` directory.

> **Note:** This is the easiest migration path because it has the most
> comparable behavior to the `pages` directory.

**Step 1: Create a new Client Component**

  * Create a new separate file inside the `app` directory (i.e. `app/home-page.tsx` or similar) that exports a Client Component. To define Client Components, add the `'use client'` directive to the top of the file (before any imports).
  * Move the default exported page component from `pages/index.js` to `app/home-page.tsx`.

    
    
    'use client';
     
    // This is a Client Component. It receives data as props and
    // has access to state and effects just like Page components
    // in the `pages` directory.
    export default function HomePage({ recentPosts }) {
      return (
        <div>
          {recentPosts.map((post) => (
            <div key={post.id}>{post.title}</div>
          ))}
        </div>
      );
    }

**Step 2: Create a new page**

  * Create a new `app/page.tsx` file inside the `app` directory. This is a Server Component by default.

  * Import the `home-page.tsx` Client Component into the page.

  * If you were fetching data in `pages/index.js`, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details.
    
        // Import your Client Component
    import HomePage from './home-page';
     
    async function getPosts() {
      const res = await fetch('https://...');
      const posts = await res.json();
      return posts;
    }
     
    export default async function Page() {
      // Fetch data directly in a Server Component
      const recentPosts = await getPosts();
      // Forward fetched data to your Client Component
      return <HomePage recentPosts={recentPosts} />;
    }

  * If your previous page used `useRouter`, you'll need to update to the new routing hooks. Learn more.

  * Start your development server and visit `http://localhost:3000`. You should see your existing index route, now served through the app directory.

A new router has been added to support the new behavior in the `app`
directory.

In `app`, you should use the three new hooks imported from `next/navigation`:
`useRouter()`, `usePathname()`, and `useSearchParams()`.

  * The new `useRouter` hook is imported from `next/navigation` and has different behavior to the `useRouter` hook in `pages` which is imported from `next/router`. 
  * The new `useRouter` does not return the `pathname` string. Use the separate `usePathname` hook instead.
  * The new `useRouter` does not return the `query` object. Use the separate `useSearchParams` hook instead.
  * You can use `useSearchParams` and `usePathname` together to listen to page changes. See the Router Events section for more details.
  * These new hooks are only supported in Client Components. They cannot be used in Server Components.

    
    
    'use client';
     
    import { useRouter, usePathname, useSearchParams } from 'next/navigation';
     
    export default function ExampleClientComponent() {
      const router = useRouter();
      const pathname = usePathname();
      const searchParams = useSearchParams();
     
      // ...
    }

In addition, the new `useRouter` hook has the following changes:

  * `isFallback` has been removed because `fallback` has been replaced.
  * The `locale`, `locales`, `defaultLocales`, `domainLocales` values have been removed because built-in i18n Next.js features are no longer necessary in the `app` directory. Learn more about i18n.
  * `basePath` has been removed. The alternative will not be part of `useRouter`. It has not yet been implemented.
  * `asPath` has been removed because the concept of `as` has been removed from the new router.
  * `isReady` has been removed because it is no longer necessary. During static rendering, any component that uses the `useSearchParams()` hook will skip the prerendering step and instead be rendered on the client at runtime.

View the `useRouter()` API reference.

The `pages` directory uses `getServerSideProps` and `getStaticProps` to fetch
data for pages. Inside the `app` directory, these previous data fetching
functions are replaced with a simpler API built on top of `fetch()` and
`async` React Server Components.

    
    
    export default async function Page() {
      // This request should be cached until manually invalidated.
      // Similar to `getStaticProps`.
      // `force-cache` is the default and can be omitted.
      const staticData = await fetch(`https://...`, { cache: 'force-cache' });
     
      // This request should be refetched on every request.
      // Similar to `getServerSideProps`.
      const dynamicData = await fetch(`https://...`, { cache: 'no-store' });
     
      // This request should be cached with a lifetime of 10 seconds.
      // Similar to `getStaticProps` with the `revalidate` option.
      const revalidatedData = await fetch(`https://...`, {
        next: { revalidate: 10 },
      });
     
      return <div>...</div>;
    }

In the `pages` directory, `getServerSideProps` is used to fetch data on the
server and forward props to the default exported React component in the file.
The initial HTML for the page is prerendered from the server, followed by
"hydrating" the page in the browser (making it interactive).

    
    
    // `pages` directory
     
    export async function getServerSideProps() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return { props: { projects } };
    }
     
    export default function Dashboard({ projects }) {
      return (
        <ul>
          {projects.map((project) => (
            <li key={project.id}>{project.name}</li>
          ))}
        </ul>
      );
    }

In the `app` directory, we can colocate our data fetching inside our React
components using Server Components. This allows us to send less JavaScript to
the client, while maintaining the rendered HTML from the server.

By setting the `cache` option to `no-store`, we can indicate that the fetched
data should never be cached. This is similar to `getServerSideProps` in the
`pages` directory.

    
    
    // `app` directory
     
    // This function can be named anything
    async function getProjects() {
      const res = await fetch(`https://...`, { cache: 'no-store' });
      const projects = await res.json();
     
      return projects;
    }
     
    export default async function Dashboard() {
      const projects = await getProjects();
     
      return (
        <ul>
          {projects.map((project) => (
            <li key={project.id}>{project.name}</li>
          ))}
        </ul>
      );
    }

In the `pages` directory, you can retrieve request-based data based on the
Node.js HTTP API.

For example, you can retrieve the `req` object from `getServerSideProps` and
use it to retrieve the request's cookies and headers.

    
    
    // `pages` directory
     
    export async function getServerSideProps({ req, query }) {
      const authHeader = req.getHeaders()['authorization'];
      const theme = req.cookies['theme'];
     
      return { props: { ... }}
    }
     
    export default function Page(props) {
      return ...
    }

The `app` directory exposes new read-only functions to retrieve request data:

    
    
    // `app` directory
    import { cookies, headers } from 'next/headers';
     
    async function getData() {
      const authHeader = headers().get('authorization');
     
      return '...';
    }
     
    export default async function Page() {
      // You can use `cookies()` or `headers()` inside Server Components
      // directly or in your data fetching function
      const theme = cookies().get('theme');
      const data = await getData();
      return '...';
    }

In the `pages` directory, the `getStaticProps` function is used to pre-render
a page at build time. This function can be used to fetch data from an external
API or directly from a database, and pass this data down to the entire page as
it's being generated during the build.

    
    
    // `pages` directory
     
    export async function getStaticProps() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return { props: { projects } };
    }
     
    export default function Index({ projects }) {
      return projects.map((project) => <div>{project.name}</div>);
    }

In the `app` directory, data fetching with `fetch()` will default to `cache:
'force-cache'`, which will cache the request data until manually invalidated.
This is similar to `getStaticProps` in the `pages` directory.

    
    
    // `app` directory
     
    // This function can be named anything
    async function getProjects() {
      const res = await fetch(`https://...`);
      const projects = await res.json();
     
      return projects;
    }
     
    export default async function Index() {
      const projects = await getProjects();
     
      return projects.map((project) => <div>{project.name}</div>);
    }

In the `pages` directory, the `getStaticPaths` function is used to define the
dynamic paths that should be pre-rendered at build time.

    
    
    // `pages` directory
    import PostLayout from '@/components/post-layout';
     
    export async function getStaticPaths() {
      return {
        paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
      };
    }
     
    export async function getStaticProps({ params }) {
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      return { props: { post } };
    }
     
    export default function Post({ post }) {
      return <PostLayout post={post} />;
    }

In the `app` directory, `getStaticPaths` is replaced with
`generateStaticParams`.

`generateStaticParams` behaves similarly to `getStaticPaths`, but has a
simplified API for returning route parameters and can be used inside layouts.
The return shape of `generateStaticParams` is an array of segments instead of
an array of nested `param` objects or a string of resolved paths.

    
    
    // `app` directory
    import PostLayout from '@/components/post-layout';
     
    export async function generateStaticParams() {
      return [{ id: '1' }, { id: '2' }];
    }
     
    async function getPost(params) {
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      return post;
    }
     
    export default async function Post({ params }) {
      const post = await getPost(params);
     
      return <PostLayout post={post} />;
    }

Using the name `generateStaticParams` is more appropriate than
`getStaticPaths` for the new model in the `app` directory. The `get` prefix is
replaced with a more descriptive `generate`, which sits better alone now that
`getStaticProps` and `getServerSideProps` are no longer necessary. The `Paths`
suffix is replaced by `Params`, which is more appropriate for nested routing
with multiple dynamic segments.

* * *

In the `pages` directory, the `fallback` property returned from
`getStaticPaths` is used to define the behavior of a page that isn't pre-
rendered at build time. This property can be set to `true` to show a fallback
page while the page is being generated, `false` to show a 404 page, or
`blocking` to generate the page at request time.

    
    
    // `pages` directory
     
    export async function getStaticPaths() {
      return {
        paths: [],
        fallback: 'blocking'
      };
    }
     
    export async function getStaticProps({ params }) {
      ...
    }
     
    export default function Post({ post }) {
      return ...
    }

In the `app` directory the `config.dynamicParams` property controls how params
outside of `generateStaticParams` are handled:

  * **`true`** : (default) Dynamic segments not included in `generateStaticParams` are generated on demand.
  * **`false`** : Dynamic segments not included in `generateStaticParams` will return a 404.

This replaces the `fallback: true | false | 'blocking'` option of
`getStaticPaths` in the `pages` directory. The `fallback: 'blocking'` option
is not included in `dynamicParams` because the difference between `'blocking'`
and `true` is negligible with streaming.

    
    
    // `app` directory
     
    export const dynamicParams = true;
     
    export async function generateStaticParams() {
      return [...]
    }
     
    async function getPost(params) {
      ...
    }
     
    export default async function Post({ params }) {
      const post = await getPost(params);
     
      return ...
    }

With `dynamicParams` set to `true` (the default), when a route segment is
requested that hasn't been generated, it will be server-rendered and cached as
static data on success.

In the `pages` directory, the `getStaticProps` function allows you to add a
`revalidate` field to automatically regenerate a page after a certain amount
of time. This is called Incremental Static Regeneration (ISR) and helps you
update static content without redeploying.

    
    
    // `pages` directory
     
    export async function getStaticProps() {
      const res = await fetch(`https://.../posts`);
      const posts = await res.json();
     
      return {
        props: { posts },
        revalidate: 60,
      };
    }
     
    export default function Index({ posts }) {
      return (
        <Layout>
          <PostList posts={posts} />
        </Layout>
      );
    }

In the `app` directory, data fetching with `fetch()` can use `revalidate`,
which will cache the request for the specified amount of seconds.

    
    
    // `app` directory
     
    async function getPosts() {
      const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } });
      const data = await res.json();
     
      return data.posts;
    }
     
    export default async function PostList() {
      const posts = await getPosts();
     
      return posts.map((post) => <div>{post.name}</div>);
    }

API Routes continue to work in the `pages/api` directory without any changes.
However, they have been replaced by Route Handlers in the `app` directory.

Route Handlers allow you to create custom request handlers for a given route
using the Web Request and Response APIs.

    
    
    export async function GET(request: Request) {}

> **Note:** If you previously used API routes to call an external API from the
> client, you can now use Server Components instead to securely fetch data.
> Learn more about data fetching.

In the `pages` directory, global stylesheets are restricted to only
`pages/_app.js`. With the `app` directory, this restriction has been lifted.
Global styles can be added to any layout, page, or component.

If you're using Tailwind CSS, you'll need to add the `app` directory to your
`tailwind.config.js` file:

    
    
    module.exports = {
      content: [
        './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add this line
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
      ],
    };

You'll also need to import your global styles in your `app/layout.js` file:

    
    
    import '../styles/globals.css';
     
    export default function RootLayout({ children }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Learn more about styling with Tailwind CSS

Next.js provides Codemod transformations to help upgrade your codebase when a
feature is deprecated. See Codemods for more information.





# Version 13

To update to Next.js version 13, run the following command using your
preferred package manager:

    
    
    npm i next@latest react@latest react-dom@latest eslint-config-next@latest
    # or
    yarn add next@latest react@latest react-dom@latest eslint-config-next@latest
    # or
    pnpm up next react react-dom eslint-config-next --latest

  * The Supported Browsers have been changed to drop Internet Explorer and target modern browsers.
  * The minimum Node.js version has been bumped from 12.22.0 to 14.18.0, since 12.x has reached end-of-life.
  * The minimum React version has been bumped from 17.0.2 to 18.2.0.
  * The `swcMinify` configuration property was changed from `false` to `true`. See Next.js Compiler for more info.
  * The `next/image` import was renamed to `next/legacy/image`. The `next/future/image` import was renamed to `next/image`. A codemod is available to safely and automatically rename your imports.
  * The `next/link` child can no longer be `<a>`. Add the `legacyBehavior` prop to use the legacy behavior or remove the `<a>` to upgrade. A codemod is available to automatically upgrade your code.
  * The `target` configuration property has been removed and superseded by Output File Tracing.

Next.js 13 introduces a new `app` directory with new features and conventions.
However, upgrading to Next.js 13 does **not** require using the new `app`
directory.

You can continue using `pages` with new features that work in both
directories, such as the updated Image component, Link component, Script
component, and Font optimization.

Next.js 12 introduced many improvements to the Image Component with a
temporary import: `next/future/image`. These improvements included less
client-side JavaScript, easier ways to extend and style images, better
accessibility, and native browser lazy loading.

Starting in Next.js 13, this new behavior is now the default for `next/image`.

There are two codemods to help you migrate to the new Image Component:

  * next-image-to-legacy-image: This codemod will safely and automatically rename `next/image` imports to `next/legacy/image` to maintain the same behavior as Next.js 12. We recommend running this codemod to quickly update to Next.js 13 automatically.
  * next-image-experimental: After running the previous codemod, you can optionally run this experimental codemod to upgrade `next/legacy/image` to the new `next/image`, which will remove unused props and add inline styles. Please note this codemod is experimental and only covers static usage (such as `<Image src={img} layout="responsive" />`) but not dynamic usage (such as `<Image {...props} />`).

Alternatively, you can manually update by following the migration guide and
also see the legacy comparison.

The `<Link>` Component no longer requires manually adding an `<a>` tag as a
child. This behavior was added as an experimental option in version 12.2 and
is now the default. In Next.js 13, `<Link>` always renders `<a>` and allows
you to forward props to the underlying tag.

For example:

    
    
    import Link from 'next/link'
     
    // Next.js 12: `<a>` has to be nested otherwise it's excluded
    <Link href="/about">
      <a>About</a>
    </Link>
     
    // Next.js 13: `<Link>` always renders `<a>` under the hood
    <Link href="/about">
      About
    </Link>

To upgrade your links to Next.js 13, you can use the `new-link` codemod.

The behavior of `next/script` has been updated to support both `pages` and
`app`. If incrementally adopting `app`, read the upgrade guide.

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13
introduces the new `next/font` module which gives you the ability to customize
your font loading experience while still ensuring great performance and
privacy.

See Optimizing Fonts to learn how to use `next/font`.





# Version 12

To upgrade to version 12, run the following command:

    
    
    npm install next@12
     
    yarn add next@12
     
    pnpm update next@12

Middleware \- If you were using Middleware prior to `12.2`, please see the
upgrade guide for more information.

Minimum Node.js Version \- The minimum Node.js version has been bumped from
`12.0.0` to `12.22.0` which is the first version of Node.js with native ES
Modules support.

Minimum React Version \- The minimum required React version is `17.0.2`. To
upgrade you can run the following command in the terminal:

    
    
    npm install react@latest react-dom@latest
     
    yarn add react@latest react-dom@latest
     
    pnpm update react@latest react-dom@latest

Next.js now uses the Rust-based compiler SWC to compile JavaScript/TypeScript.
This new compiler is up to 17x faster than Babel when compiling individual
files and up to 5x faster Fast Refresh.

Next.js provides full backward compatibility with applications that have
custom Babel configuration. All transformations that Next.js handles by
default like styled-jsx and tree-shaking of `getStaticProps` /
`getStaticPaths` / `getServerSideProps` have been ported to Rust.

When an application has a custom Babel configuration, Next.js will
automatically opt-out of using SWC for compiling JavaScript/Typescript and
will fall back to using Babel in the same way that it was used in Next.js 11.

Many of the integrations with external libraries that currently require custom
Babel transformations will be ported to Rust-based SWC transforms in the near
future. These include but are not limited to:

  * Styled Components
  * Emotion
  * Relay

In order to prioritize transforms that will help you adopt SWC, please provide
your `.babelrc` on this feedback thread.

You can opt-in to replacing Terser with SWC for minifying JavaScript up to 7x
faster using a flag in `next.config.js`:

    
    
    module.exports = {
      swcMinify: true,
    };

Minification using SWC is an opt-in flag to ensure it can be tested against
more real-world Next.js applications before it becomes the default in Next.js
12.1. If you have feedback about minification, please leave it on this
feedback thread.

On top of the Rust-based compiler we've implemented a new CSS parser based on
the one used for the styled-jsx Babel transform. This new parser has improved
handling of CSS and now errors when invalid CSS is used that would previously
slip through and cause unexpected behavior.

Because of this change invalid CSS will throw an error during development and
`next build`. This change only affects styled-jsx usage.

`next/image` now renders the `<img>` inside a `<span>` instead of `<div>`.

If your application has specific CSS targeting span such as `.container span`,
upgrading to Next.js 12 might incorrectly match the wrapping element inside
the `<Image>` component. You can avoid this by restricting the selector to a
specific class such as `.container span.item` and updating the relevant
component with that className, such as `<span className="item" />`.

If your application has specific CSS targeting the `next/image` `<div>` tag,
for example `.container div`, it may not match anymore. You can update the
selector `.container span`, or preferably, add a new `<div
className="wrapper">` wrapping the `<Image>` component and target that instead
such as `.container .wrapper`.

The `className` prop is unchanged and will still be passed to the underlying
`<img>` element.

See the documentation for more info.

Previously, Next.js used a server-sent events connection to receive HMR
events. Next.js 12 now uses a WebSocket connection.

In some cases when proxying requests to the Next.js dev server, you will need
to ensure the upgrade request is handled correctly. For example, in `nginx`
you would need to add the following configuration:

    
    
    location /_next/webpack-hmr {
        proxy_pass http://localhost:3000/_next/webpack-hmr;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

If you are using Apache (2.x), you can add the following configuration to
enable web sockets to the server. Review the port, host name and server names.

    
    
    <VirtualHost *:443>
     # ServerName yourwebsite.local
     ServerName "${WEBSITE_SERVER_NAME}"
     ProxyPass / http://localhost:3000/
     ProxyPassReverse / http://localhost:3000/
     # Next.js 12 uses websocket
     <Location /_next/webpack-hmr>
        RewriteEngine On
        RewriteCond %{QUERY_STRING} transport=websocket [NC]
        RewriteCond %{HTTP:Upgrade} websocket [NC]
        RewriteCond %{HTTP:Connection} upgrade [NC]
        RewriteRule /(.*) ws://localhost:3000/_next/webpack-hmr/$1 [P,L]
        ProxyPass ws://localhost:3000/_next/webpack-hmr retry=0 timeout=30
        ProxyPassReverse ws://localhost:3000/_next/webpack-hmr
     </Location>
    </VirtualHost>
    

For custom servers, such as `express`, you may need to use `app.all` to ensure
the request is passed correctly, for example:

    
    
    app.all('/_next/webpack-hmr', (req, res) => {
      nextjsRequestHandler(req, res);
    });

If you are already using webpack 5 you can skip this section.

Next.js has adopted webpack 5 as the default for compilation in Next.js 11. As
communicated in the webpack 5 upgrading documentation Next.js 12 removes
support for webpack 4.

If your application is still using webpack 4 using the opt-out flag, you will
now see an error linking to the webpack 5 upgrading documentation.

If you do not have `target` in `next.config.js` you can skip this section.

The target option has been deprecated in favor of built-in support for tracing
what dependencies are needed to run a page.

During `next build`, Next.js will automatically trace each page and its
dependencies to determine all of the files that are needed for deploying a
production version of your application.

If you are currently using the `target` option set to `serverless`, please
read the documentation on how to leverage the new output.





# Version 11

To upgrade to version 11, run the following command:

    
    
    npm install next@11
     
    yarn add next@11

Webpack 5 is now the default for all Next.js applications. If you did not have
a custom webpack configuration, your application is already using webpack 5.
If you do have a custom webpack configuration, you can refer to the Next.js
webpack 5 documentation for upgrade guidance.

The build output directory (defaults to `.next`) is now cleared by default
except for the Next.js caches. You can refer to the cleaning `distDir` RFC for
more information.

If your application was relying on this behavior previously you can disable
the new default behavior by adding the `cleanDistDir: false` flag in
`next.config.js`.

Next.js 11 supports the `PORT` environment variable to set the port the
application runs on. Using `-p`/`--port` is still recommended but if you were
prohibited from using `-p` in any way you can now use `PORT` as an
alternative:

Example:

Next.js 11 supports static image imports with `next/image`. This new feature
relies on being able to process image imports. If you previously added the
`next-images` or `next-optimized-images` packages you can either move to the
new built-in support using `next/image` or disable the feature:

    
    
    module.exports = {
      images: {
        disableStaticImages: true,
      },
    };

The `next/app` component's `componentDidCatch` was deprecated in Next.js 9 as
it's no longer needed and has since been a no-op. In Next.js 11, it was
removed.

If your `pages/_app.js` has a custom `componentDidCatch` method you can remove
`super.componentDidCatch` as it is no longer needed.

This export was deprecated in Next.js 9 as it's no longer needed and has since
been a no-op with a warning during development. In Next.js 11 it was removed.

If your `pages/_app.js` imports `Container` from `next/app` you can remove
`Container` as it was removed. Learn more in the documentation.

This property was deprecated in Next.js 4 and has since shown a warning during
development. With the introduction of `getStaticProps` / `getServerSideProps`
these methods already disallowed the usage of `props.url`. In Next.js 11, it
was removed completely.

You can learn more in the documentation.

The `unsized` property on `next/image` was deprecated in Next.js 10.0.1. You
can use `layout="fill"` instead. In Next.js 11 `unsized` was removed.

The `modules` and `render` option for `next/dynamic` were deprecated in
Next.js 9.5. This was done in order to make the `next/dynamic` API closer to
`React.lazy`. In Next.js 11, the `modules` and `render` options were removed.

This option hasn't been mentioned in the documentation since Next.js 8 so it's
less likely that your application is using it.

If your application does use `modules` and `render` you can refer to the
documentation.

`Head.rewind` has been a no-op since Next.js 9.5, in Next.js 11 it was
removed. You can safely remove your usage of `Head.rewind`.

Moment.js includes translations for a lot of locales by default. Next.js now
automatically excludes these locales by default to optimize bundle size for
applications using Moment.js.

To load a specific locale use this snippet:

    
    
    import moment from 'moment';
    import 'moment/locale/ja';
     
    moment.locale('ja');

You can opt-out of this new default by adding `excludeDefaultMomentLocales:
false` to `next.config.js` if you do not want the new behavior, do note it's
highly recommended to not disable this new optimization as it significantly
reduces the size of Moment.js.

In case you're accessing `router.events` during rendering, in Next.js 11
`router.events` is no longer provided during pre-rendering. Ensure you're
accessing `router.events` in `useEffect`:

    
    
    useEffect(() => {
      const handleRouteChange = (url, { shallow }) => {
        console.log(
          `App is changing to ${url} ${
            shallow ? 'with' : 'without'
          } shallow routing`,
        );
      };
     
      router.events.on('routeChangeStart', handleRouteChange);
     
      // If the component is unmounted, unsubscribe
      // from the event with the `off` method:
      return () => {
        router.events.off('routeChangeStart', handleRouteChange);
      };
    }, [router]);

If your application uses `router.router.events` which was an internal property
that was not public please make sure to use `router.events` as well.

React 17 introduced a new JSX Transform that brings a long-time Next.js
feature to the wider React ecosystem: Not having to `import React from
'react'` when using JSX. When using React 17 Next.js will automatically use
the new transform. This transform does not make the `React` variable global,
which was an unintended side-effect of the previous Next.js implementation. A
codemod is available to automatically fix cases where you accidentally used
`React` without importing it.

Most applications already use the latest version of React, with Next.js 11 the
minimum React version has been updated to 17.0.2.

To upgrade you can run the following command:

    
    
    npm install react@latest react-dom@latest
    

Or using `yarn`:

    
    
    yarn add react@latest react-dom@latest
    



  
  
Using Pages Router

Features available in /pages





# Upgrading to Version 9

To upgrade to version 9, run the following command:

    
    
    npm install next@9
     
    yarn add next@9

If you previously configured `routes` in your `vercel.json` file for dynamic
routes, these rules can be removed when leveraging Next.js 9's new Dynamic
Routing feature.

Next.js 9's dynamic routes are **automatically configured onVercel** and do
not require any `vercel.json` customization.

You can read more about Dynamic Routing here.

If you previously copied the Custom `<App>` example, you may be able to remove
your `getInitialProps`.

Removing `getInitialProps` from `pages/_app.js` (when possible) is important
to leverage new Next.js features!

The following `getInitialProps` does nothing and may be removed:

    
    
    class MyApp extends App {
      // Remove me, I do nothing!
      static async getInitialProps({ Component, ctx }) {
        let pageProps = {};
     
        if (Component.getInitialProps) {
          pageProps = await Component.getInitialProps(ctx);
        }
     
        return { pageProps };
      }
     
      render() {
        // ... etc
      }
    }

Next.js will now ignore usage `@zeit/next-typescript` and warn you to remove
it. Please remove this plugin from your `next.config.js`.

Remove references to `@zeit/next-typescript/babel` from your custom `.babelrc`
(if present).

The usage of `fork-ts-checker-webpack-plugin` should also be removed from your
`next.config.js`.

TypeScript Definitions are published with the `next` package, so you need to
uninstall `@types/next` as they would conflict.

The following types are different:

> This list was created by the community to help you upgrade, if you find
> other differences please send a pull-request to this list to help other
> users.

From:

    
    
    import { NextContext } from 'next';
    import { NextAppContext, DefaultAppIProps } from 'next/app';
    import { NextDocumentContext, DefaultDocumentIProps } from 'next/document';

to

    
    
    import { NextPageContext } from 'next';
    import { AppContext, AppInitialProps } from 'next/app';
    import { DocumentContext, DocumentInitialProps } from 'next/document';

You may no longer export a custom variable named `config` from a page (i.e.
`export { config }` / `export const config ...`). This exported variable is
now used to specify page-level Next.js configuration like Opt-in AMP and API
Route features.

You must rename a non-Next.js-purposed `config` export to something different.

Dynamic components will not render anything by default while loading. You can
still customize this behavior by setting the `loading` property:

    
    
    import dynamic from 'next/dynamic';
     
    const DynamicComponentWithCustomLoading = dynamic(
      () => import('../components/hello2'),
      {
        loading: () => <p>Loading</p>,
      },
    );

Next.js now has the concept of page-level configuration, so the `withAmp`
higher-order component has been removed for consistency.

This change can be **automatically migrated by running the following commands
in the root of your Next.js project:**

    
    
    curl -L https://github.com/vercel/next-codemod/archive/master.tar.gz | tar -xz --strip=2 next-codemod-master/transforms/withamp-to-config.js npx jscodeshift -t ./withamp-to-config.js pages/**/*.js

To perform this migration by hand, or view what the codemod will produce, see
below:

**Before**

    
    
    import { withAmp } from 'next/amp'
     
    function Home() {
      return <h1>My AMP Page</h1>
    }
     
    export default withAmp(Home)
    // or
    export default withAmp(Home, { hybrid: true })

**After**

    
    
    export default function Home() {
      return <h1>My AMP Page</h1>;
    }
     
    export const config = {
      amp: true,
      // or
      amp: 'hybrid',
    };

Previously, exporting `pages/about.js` would result in `out/about/index.html`.
This behavior has been changed to result in `out/about.html`.

You can revert to the previous behavior by creating a `next.config.js` with
the following content:

    
    
    module.exports = {
      trailingSlash: true,
    };

Pages in `pages/api/` are now considered API Routes. Pages in this directory
will no longer contain a client-side bundle.

The ability to load multiple modules at once has been deprecated in
`next/dynamic` to be closer to React's implementation (`React.lazy` and
`Suspense`).

Updating code that relies on this behavior is relatively straightforward!
We've provided an example of a before/after to help you migrate your
application:

**Before**

    
    
    import dynamic from 'next/dynamic';
     
    const HelloBundle = dynamic({
      modules: () => {
        const components = {
          Hello1: () => import('../components/hello1').then((m) => m.default),
          Hello2: () => import('../components/hello2').then((m) => m.default),
        };
     
        return components;
      },
      render: (props, { Hello1, Hello2 }) => (
        <div>
          <h1>{props.title}</h1>
          <Hello1 />
          <Hello2 />
        </div>
      ),
    });
     
    function DynamicBundle() {
      return <HelloBundle title="Dynamic Bundle" />;
    }
     
    export default DynamicBundle;

**After**

    
    
    import dynamic from 'next/dynamic';
     
    const Hello1 = dynamic(() => import('../components/hello1'));
    const Hello2 = dynamic(() => import('../components/hello2'));
     
    function HelloBundle({ title }) {
      return (
        <div>
          <h1>{title}</h1>
          <Hello1 />
          <Hello2 />
        </div>
      );
    }
     
    function DynamicBundle() {
      return <HelloBundle title="Dynamic Bundle" />;
    }
     
    export default DynamicBundle;



  
  
Using Pages Router

Features available in /pages





# Font Module

This API reference will help you understand how to use `next/font/google` and
`next/font/local`. For features and usage, please see the Optimizing Fonts
page.

For usage, review Google Fonts and Local Fonts.

The path of the font file as a string or an array of objects (with type
`Array<{path: string, weight?: string, style?: string}>`) relative to the
directory where the font loader function is called.

Used in `next/font/local`

Examples:

  * `src:'./fonts/my-font.woff2'` where `my-font.woff2` is placed in a directory named `fonts` inside the `app` directory
  * `src:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]`
  * if the font loader function is called in `app/page.tsx` using `src:'../styles/fonts/my-font.ttf'`, then `my-font.ttf` is placed in `styles/fonts` at the root of the project

The font `weight` with the following possibilities:

  * A string with possible values of the weights available for the specific font or a range of values if it's a variable font
  * An array of weight values if the font is not a variable google font. It applies to `next/font/google` only.

Used in `next/font/google` and `next/font/local`

  * Required if the font being used is **not** variable

Examples:

  * `weight: '400'`: A string for a single weight value - for the font `Inter`, the possible values are `'100'`, `'200'`, `'300'`, `'400'`, `'500'`, `'600'`, `'700'`, `'800'`, `'900'` or `'variable'` where `'variable'` is the default)
  * `weight: '100 900'`: A string for the range between `100` and `900` for a variable font
  * `weight: ['100','400','900']`: An array of 3 possible values for a non variable font

The font `style` with the following possibilities:

  * A string value with default value of `'normal'`
  * An array of style values if the font is not a variable google font. It applies to `next/font/google` only.

Used in `next/font/google` and `next/font/local`

Examples:

  * `style: 'italic'`: A string - it can be `normal` or `italic` for `next/font/google`
  * `style: 'oblique'`: A string - it can take any value for `next/font/local` but is expected to come from standard font styles
  * `style: ['italic','normal']`: An array of 2 values for `next/font/google` \- the values are from `normal` and `italic`

The font `subsets` defined by an array of string values with the names of each
subset you would like to be preloaded. Fonts specified via `subsets` will have
a link preload tag injected into the head when the `preload` option is true,
which is the default.

Used in `next/font/google`

Examples:

  * `subsets: ['latin']`: An array with the subset `latin`

You can find a list of all subsets on the Google Fonts page for your font.

Some variable fonts have extra `axes` that can be included. By default, only
the font weight is included to keep the file size down. The possible values of
`axes` depend on the specific font.

Used in `next/font/google`

Examples:

  * `axes: ['slnt']`: An array with value `slnt` for the `Inter` variable font which has `slnt` as additional `axes` as shown here. You can find the possible `axes` values for your font by using the filter on the Google variable fonts page and looking for axes other than `wght`

The font `display` with possible string values of `'auto'`, `'block'`,
`'swap'`, `'fallback'` or `'optional'` with default value of `'swap'`.

Used in `next/font/google` and `next/font/local`

Examples:

  * `display: 'optional'`: A string assigned to the `optional` value

A boolean value that specifies whether the font should be preloaded or not.
The default is `true`.

Used in `next/font/google` and `next/font/local`

Examples:

The fallback font to use if the font cannot be loaded. An array of strings of
fallback fonts with no default.

Used in `next/font/google` and `next/font/local`

Examples:

  * `fallback: ['system-ui', 'arial']`: An array setting the fallback fonts to `system-ui` or `arial`

  * For `next/font/google`: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The default is `true`.
  * For `next/font/local`: A string or boolean `false` value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The possible values are `'Arial'`, `'Times New Roman'` or `false`. The default is `'Arial'`.

Used in `next/font/google` and `next/font/local`

Examples:

  * `adjustFontFallback: false`: for ``next/font/google`
  * `adjustFontFallback: 'Times New Roman'`: for `next/font/local`

A string value to define the CSS variable name to be used if the style is
applied with the CSS variable method.

Used in `next/font/google` and `next/font/local`

Examples:

  * `variable: '--my-font'`: The CSS variable `--my-font` is declared

An array of font face descriptor key-value pairs that define the generated
`@font-face` further.

Used in `next/font/local`

Examples:

  * `declarations: [{ prop: 'ascent-override', value: '90%' }]`

You can apply the font styles in three ways:

Returns a read-only CSS `className` for the loaded font to be passed to an
HTML element.

    
    
    <p className={inter.className}>Hello, Next.js!</p>

Returns a read-only CSS `style` object for the loaded font to be passed to an
HTML element, including `style.fontFamily` to access the font family name and
fallback fonts.

    
    
    <p style={inter.style}>Hello World</p>

If you would like to set your styles in an external style sheet and specify
additional options there, use the CSS variable method.

In addition to importing the font, also import the CSS file where the CSS
variable is defined and set the variable option of the font loader object as
follows:

    
    
    import { Inter } from 'next/font/google';
    import styles from '../styles/component.module.css';
     
    const inter = Inter({
      variable: '--font-inter',
    });

To use the font, set the `className` of the parent container of the text you
would like to style to the font loader's `variable` value and the `className`
of the text to the `styles` property from the external CSS file.

    
    
    <main className={inter.variable}>
      <p className={styles.text}>Hello World</p>
    </main>

Define the `text` selector class in the `component.module.css` CSS file as
follows:

    
    
    .text {
      font-family: var(--font-inter);
      font-weight: 200;
      font-style: italic;
    }

In the example above, the text `Hello World` is styled using the `Inter` font
and the generated font fallback with `font-weight: 200` and `font-style:
italic`.

Every time you call the `localFont` or Google font function, that font will be
hosted as one instance in your application. Therefore, if you need to use the
same font in multiple places, you should load it in one place and import the
related font object where you need it. This is done using a font definitions
file.

For example, create a `fonts.ts` file in a `styles` folder at the root of your
app directory.

Then, specify your font definitions as follows:

    
    
    import { Inter, Lora, Source_Sans_Pro } from 'next/font/google';
    import localFont from 'next/font/local';
     
    // define your variable fonts
    const inter = Inter();
    const lora = Lora();
    // define 2 weights of a non-variable font
    const sourceCodePro400 = Source_Sans_Pro({ weight: '400' });
    const sourceCodePro700 = Source_Sans_Pro({ weight: '700' });
    // define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder
    const greatVibes = localFont({ src: './GreatVibes-Regular.ttf' });
     
    export { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes };

You can now use these definitions in your code as follows:

    
    
    import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts';
     
    export default function Page() {
      return (
        <div>
          <p className={inter.className}>Hello world using Inter font</p>
          <p style={lora.style}>Hello world using Lora font</p>
          <p className={sourceCodePro700.className}>
            Hello world using Source_Sans_Pro font with weight 700
          </p>
          <p className={greatVibes.className}>My title in Great Vibes font</p>
        </div>
      );
    }

To make it easier to access the font definitions in your code, you can define
a path alias in your `tsconfig.json` or `jsconfig.json` files as follows:

    
    
    {
      "compilerOptions": {
        "paths": {
          "@/fonts": ["./styles/fonts"]
        }
      }
    }

You can now import any font definition as follows:

    
    
    import { greatVibes, sourceCodePro400 } from '@/fonts';

Version| Changes  
---|---  
`v13.2.0`| `@next/font` renamed to `next/font`. Installation no longer
required.  
`v13.0.0`| `@next/font` was added.




    
    
    import Head from 'next/head';
     
    function IndexPage() {
      return (
        <div>
          <Head>
            <title>My page title</title>
            <meta property="og:title" content="My page title" key="title" />
          </Head>
          <Head>
            <meta property="og:title" content="My new title" key="title" />
          </Head>
          <p>Hello world!</p>
        </div>
      );
    }
     
    export default IndexPage;

> The contents of `head` get cleared upon unmounting the component, so make
> sure each page completely defines what it needs in `head`, without making
> assumptions about what other pages added.

> We recommend using next/script in your component instead of manually
> creating a `<script>` in `next/head`.





# <Image>

 **Examples**

> **Note** : If you are using a version of Next.js prior to 13, you'll want to
> use the next/legacy/image documentation since the component was renamed.

This API reference will help you understand how to use props and configuration
options available for the Image Component. For features and usage, please see
the Image Component page.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <Image
          src="/profile.png"
          width={500}
          height={500}
          alt="Picture of the author"
        />
      );
    }

Here's a summary of the props available for the Image Component:

Prop| Example| Type| Required  
---|---|---|---  
`src`| `src="/profile.png"`| String| Yes  
`width`| `width={500}`| Integer (px)| Yes  
`height`| `height={500}`| Integer (px)| Yes  
`alt`| `alt="Picture of the author"`| String| Yes  
`loader`| `loader={imageLoader}`| Function| -  
`fill`| `fill={true}`| Boolean| -  
`sizes`| `sizes="(max-width: 768px) 100vw"`| String| -  
`quality`| `quality={80}`| Integer (1-100)| -  
`priority`| `priority={true}`| Boolean| -  
`placeholder`| `placeholder="blur"`| String| -  
`style`| `style={{objectFit: "contain"}}`| Object| -  
`onLoadingComplete`| `onLoadingComplete={img => done())}`| Function| -  
`onLoad`| `onLoad={event => done())}`| Function| -  
`onError`| `onError(event => fail()}`| Function| -  
`loading`| `loading="lazy"`| String| -  
`blurDataURL`| `blurDataURL="data:image/jpeg..."`| String| -  
  
The Image Component requires the following properties: `src`, `width`,
`height`, and `alt`.

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <div>
          <Image
            src="/profile.png"
            width={500}
            height={500}
            alt="Picture of the author"
          />
        </div>
      );
    }

Must be one of the following:

  * A statically imported image file
  * A path string. This can be either an absolute external URL, or an internal path depending on the loader prop.

When using an external URL, you must add it to remotePatterns in
`next.config.js`.

The `width` property represents the _rendered_ width in pixels, so it will
affect how large the image appears.

Required, except for statically imported images or images with the `fill`
property.

The `height` property represents the _rendered_ height in pixels, so it will
affect how large the image appears.

Required, except for statically imported images or images with the `fill`
property.

The `alt` property is used to describe the image for screen readers and search
engines. It is also the fallback text if images have been disabled or an error
occurs while loading the image.

It should contain text that could replace the image without changing the
meaning of the page. It is not meant to supplement the image and should not
repeat information that is already provided in the captions above or below the
image.

If the image is purely decorative or not intended for the user, the `alt`
property should be an empty string (`alt=""`).

Learn more

The `<Image />` component accepts a number of additional properties beyond
those which are required. This section describes the most commonly-used
properties of the Image component. Find details about more rarely-used
properties in the Advanced Props section.

A custom function used to resolve image URLs.

A `loader` is a function returning a URL string for the image, given the
following parameters:

Here is an example of using a custom loader:

    
    
    import Image from 'next/image';
     
    const imageLoader = ({ src, width, quality }) => {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    };
     
    export default function Page() {
      return (
        <Image
          loader={imageLoader}
          src="me.png"
          alt="Picture of the author"
          width={500}
          height={500}
        />
      );
    }

Alternatively, you can use the loaderFile configuration in `next.config.js` to
configure every instance of `next/image` in your application, without passing
a prop.

    
    
    fill={true} // {true} | {false}

A boolean that causes the image to fill the parent element instead of setting
`width` and `height`.

The parent element _must_ assign `position: "relative"`, `position: "fixed"`,
or `position: "absolute"` style.

By default, the img element will automatically be assigned the `position:
"absolute"` style.

The default image fit behavior will stretch the image to fit the container.
You may prefer to set `object-fit: "contain"` for an image which is
letterboxed to fit the container and preserve aspect ratio.

Alternatively, `object-fit: "cover"` will cause the image to fill the entire
container and be cropped to preserve aspect ratio. For this to look correct,
the `overflow: "hidden"` style should be assigned to the parent element.

For more information, see also:

A string that provides information about how wide the image will be at
different breakpoints. The value of `sizes` will greatly affect performance
for images using `fill` or which are styled to have a responsive size.

The `sizes` property serves two important purposes related to image
performance:

  * First, the value of `sizes` is used by the browser to determine which size of the image to download, from `next/image`'s automatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. The `sizes` property allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify a `sizes` value in an image with the `fill` property, a default value of `100vw` (full screen width) is used.
  * Second, the `sizes` property configures how `next/image` automatically generates an image source set. If no `sizes` value is present, a small source set is generated, suitable for a fixed-size image. If `sizes` is defined, a large source set is generated, suitable for a responsive image. If the `sizes` property includes sizes such as `50vw`, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which are too small to ever be necessary.

For example, if you know your styling will cause an image to be full-width on
mobile devices, in a 2-column layout on tablets, and a 3-column layout on
desktop displays, you should include a sizes property such as the following:

    
    
    import Image from 'next/image';
     
    export default function Page() {
      return (
        <div className="grid-element">
          <Image
            fill
            src="/example.png"
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        </div>
      );
    }

This example `sizes` could have a dramatic effect on performance metrics.
Without the `33vw` sizes, the image selected from the server would be 3 times
as wide as it needs to be. Because file size is proportional to the square of
the width, without `sizes` the user would download an image that's 9 times
larger than necessary.

Learn more about `srcset` and `sizes`:

    
    
    quality={75} // {number 1-100}

The quality of the optimized image, an integer between `1` and `100`, where
`100` is the best quality and therefore largest file size. Defaults to `75`.

    
    
    priority={false} // {false} | {true}

When true, the image will be considered high priority and preload. Lazy
loading is automatically disabled for images using `priority`.

You should use the `priority` property on any image detected as the Largest
Contentful Paint (LCP) element. It may be appropriate to have multiple
priority images, as different images may be the LCP element for different
viewport sizes.

Should only be used when the image is visible above the fold. Defaults to
`false`.

    
    
    placeholder = 'empty'; // {empty} | {blur}

A placeholder to use while the image is loading. Possible values are `blur` or
`empty`. Defaults to `empty`.

When `blur`, the `blurDataURL` property will be used as the placeholder. If
`src` is an object from a static import and the imported image is `.jpg`,
`.png`, `.webp`, or `.avif`, then `blurDataURL` will be automatically
populated.

For dynamic images, you must provide the `blurDataURL` property. Solutions
such as Plaiceholder can help with `base64` generation.

When `empty`, there will be no placeholder while the image is loading, only
empty space.

Try it out:

In some cases, you may need more advanced usage. The `<Image />` component
optionally accepts the following advanced properties.

Allows passing CSS styles to the underlying image element.

    
    
    const imageStyle = {
      borderRadius: '50%',
      border: '1px solid #fff',
    };
     
    export default function ProfileImage() {
      return <Image src="..." style={imageStyle} />;
    }

Remember that the required width and height props can interact with your
styling. If you use styling to modify an image's width, you should also style
its height to `auto` to preserve its intrinsic aspect ratio, or your image
will be distorted.

    
    
    <Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />

A callback function that is invoked once the image is completely loaded and
the placeholder has been removed.

The callback function will be called with one argument, a reference to the
underlying `<img>` element.

    
    
    <Image onLoad={(e) => console.log(e.target.naturalWidth)} />

A callback function that is invoked when the image is loaded.

Note that the load event might occur before the placeholder is removed and the
image is fully decoded.

Instead, use `onLoadingComplete`.

    
    
    <Image onError={(e) => console.error(e.target.id)} />

A callback function that is invoked if the image fails to load.

> **Recommendation** : This property is only meant for advanced use cases.
> Switching an image to load with `eager` will normally **hurt performance**.
> We recommend using the `priority` property instead, which will eagerly
> preload the image.
    
    
    loading = 'lazy'; // {lazy} | {eager}

The loading behavior of the image. Defaults to `lazy`.

When `lazy`, defer loading the image until it reaches a calculated distance
from the viewport.

When `eager`, load the image immediately.

Learn more about the `loading` attribute.

A Data URL to be used as a placeholder image before the `src` image
successfully loads. Only takes effect when combined with `placeholder="blur"`.

Must be a base64-encoded image. It will be enlarged and blurred, so a very
small image (10px or less) is recommended. Including larger images as
placeholders may harm your application performance.

Try it out:

You can also generate a solid color Data URL to match the image.

    
    
    unoptimized = {false} // {false} | {true}

When true, the source image will be served as-is instead of changing quality,
size, or format. Defaults to `false`.

    
    
    import Image from 'next/image';
     
    const UnoptimizedImage = (props) => {
      return <Image {...props} unoptimized />;
    };

Since Next.js 12.3.0, this prop can be assigned to all images by updating
`next.config.js` with the following configuration:

    
    
    module.exports = {
      images: {
        unoptimized: true,
      },
    };

Other properties on the `<Image />` component will be passed to the underlying
`img` element with the exception of the following:

  * `srcSet`. Use Device Sizes instead.
  * `decoding`. It is always `"async"`.

In addition to props, you can configure the Image Component in
`next.config.js`. The following options are available:

To protect your application from malicious users, configuration is required in
order to use external images. This ensures that only external images from your
account can be served from the Next.js Image Optimization API. These external
images can be configured with the `remotePatterns` property in your
`next.config.js` file, as shown below:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 'example.com',
            port: '',
            pathname: '/account123/**',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of `next/image`
> must start with `https://example.com/account123/`. Any other protocol,
> hostname, port, or unmatched path will respond with 400 Bad Request.

Below is another example of the `remotePatterns` property in the
`next.config.js` file:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: '**.example.com',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of `next/image`
> must start with `https://img1.example.com` or
> `https://me.avatar.example.com` or any number of subdomains. Any other
> protocol or unmatched hostname will respond with 400 Bad Request.

Wildcard patterns can be used for both `pathname` and `hostname` and have the
following syntax:

  * `*` match a single path segment or subdomain
  * `**` match any number of path segments at the end or subdomains at the beginning

The `**` syntax does not work in the middle of the pattern.

> **Warning** : We recommend configuring strict `remotePatterns` instead of
> `domains` in order to protect your application from malicious users. Only
> use `domains` if you own all the content served from the domain.

Similar to `remotePatterns`, the `domains` configuration can be used to
provide a list of allowed hostnames for external images.

However, the `domains` configuration does not support wildcard pattern
matching and it cannot restrict protocol, port, or pathname.

Below is an example of the `domains` property in the `next.config.js` file:

    
    
    module.exports = {
      images: {
        domains: ['assets.acme.com'],
      },
    };

If you want to use a cloud provider to optimize images instead of using the
Next.js built-in Image Optimization API, you can configure the `loaderFile` in
your `next.config.js` like the following:

    
    
    module.exports = {
      images: {
        loader: 'custom',
        loaderFile: './my/image/loader.js',
      },
    };

This must point to a file relative to the root of your Next.js application.
The file must export a default function that returns a string, for example:

    
    
    export default function myImageLoader({ src, width, quality }) {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    }

Alternatively, you can use the `loader` prop to configure each instance of
`next/image`.

Examples:

The following configuration is for advanced use cases and is usually not
necessary. If you choose to configure the properties below, you will override
any changes to the Next.js defaults in future updates.

If you know the expected device widths of your users, you can specify a list
of device width breakpoints using the `deviceSizes` property in
`next.config.js`. These widths are used when the `next/image` component uses
`sizes` prop to ensure the correct image is served for user's device.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
      },
    };

You can specify a list of image widths using the `images.imageSizes` property
in your `next.config.js` file. These widths are concatenated with the array of
device sizes to form the full array of sizes used to generate image srcsets.

The reason there are two separate lists is that imageSizes is only used for
images which provide a `sizes` prop, which indicates that the image is less
than the full width of the screen. **Therefore, the sizes in imageSizes should
all be smaller than the smallest size in deviceSizes.**

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
      },
    };

The default Image Optimization API will automatically detect the browser's
supported image formats via the request's `Accept` header.

If the `Accept` head matches more than one of the configured formats, the
first match in the array is used. Therefore, the array order matters. If there
is no match (or the source image is animated), the Image Optimization API will
fallback to the original image's format.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        formats: ['image/webp'],
      },
    };

You can enable AVIF support with the following configuration.

    
    
    module.exports = {
      images: {
        formats: ['image/avif', 'image/webp'],
      },
    };

> **Note** : AVIF generally takes 20% longer to encode but it compresses 20%
> smaller compared to WebP. This means that the first time an image is
> requested, it will typically be slower and then subsequent requests that are
> cached will be faster.

> **Note** : If you self-host with a Proxy/CDN in front of Next.js, you must
> configure the Proxy to forward the `Accept` header.

The following describes the caching algorithm for the default loader. For all
other loaders, please refer to your cloud provider's documentation.

Images are optimized dynamically upon request and stored in the
`<distDir>/cache/images` directory. The optimized image file will be served
for subsequent requests until the expiration is reached. When a request is
made that matches a cached but expired file, the expired image is served stale
immediately. Then the image is optimized again in the background (also called
revalidation) and saved to the cache with the new expiration date.

The cache status of an image can be determined by reading the value of the
`x-nextjs-cache` response header. The possible values are the following:

  * `MISS` \- the path is not in the cache (occurs at most once, on the first visit)
  * `STALE` \- the path is in the cache but exceeded the revalidate time so it will be updated in the background
  * `HIT` \- the path is in the cache and has not exceeded the revalidate time

The expiration (or rather Max Age) is defined by either the `minimumCacheTTL`
configuration or the upstream image `Cache-Control` header, whichever is
larger. Specifically, the `max-age` value of the `Cache-Control` header is
used. If both `s-maxage` and `max-age` are found, then `s-maxage` is
preferred. The `max-age` is also passed-through to any downstream clients
including CDNs and browsers.

  * You can configure `minimumCacheTTL` to increase the cache duration when the upstream image does not include `Cache-Control` header or the value is very low.
  * You can configure `deviceSizes` and `imageSizes` to reduce the total number of possible generated images.
  * You can configure formats to disable multiple formats in favor of a single image format.

You can configure the Time to Live (TTL) in seconds for cached optimized
images. In many cases, it's better to use a Static Image Import which will
automatically hash the file contents and cache the image forever with a
`Cache-Control` header of `immutable`.

    
    
    module.exports = {
      images: {
        minimumCacheTTL: 60,
      },
    };

The expiration (or rather Max Age) of the optimized image is defined by either
the `minimumCacheTTL` or the upstream image `Cache-Control` header, whichever
is larger.

If you need to change the caching behavior per image, you can configure
`headers` to set the `Cache-Control` header on the upstream image (e.g.
`/some-asset.jpg`, not `/_next/image` itself).

There is no mechanism to invalidate the cache at this time, so its best to
keep `minimumCacheTTL` low. Otherwise you may need to manually change the
`src` prop or delete `<distDir>/cache/images`.

The default behavior allows you to import static files such as `import icon
from './icon.png` and then pass that to the `src` property.

In some cases, you may wish to disable this feature if it conflicts with other
plugins that expect the import to behave differently.

You can disable static image imports inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        disableStaticImages: true,
      },
    };

The default loader does not optimize SVG images for a few reasons. First, SVG
is a vector format meaning it can be resized losslessly. Second, SVG has many
of the same features as HTML/CSS, which can lead to vulnerabilities without
proper Content Security Policy (CSP) headers.

If you need to serve SVG images with the default Image Optimization API, you
can set `dangerouslyAllowSVG` inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        dangerouslyAllowSVG: true,
        contentDispositionType: 'attachment',
        contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
      },
    };

In addition, it is strongly recommended to also set `contentDispositionType`
to force the browser to download the image, as well as `contentSecurityPolicy`
to prevent scripts embedded in the image from executing.

The default loader will automatically bypass Image Optimization for animated
images and serve the image as-is.

Auto-detection for animated files is best-effort and supports GIF, APNG, and
WebP. If you want to explicitly bypass Image Optimization for a given animated
image, use the unoptimized prop.

This `next/image` component uses browser native lazy loading, which may
fallback to eager loading for older browsers before Safari 15.4. When using
the blur-up placeholder, older browsers before Safari 12 will fallback to
empty placeholder. When using styles with `width`/`height` of `auto`, it is
possible to cause Layout Shift on older browsers before Safari 15 that don't
preserve the aspect ratio. For more details, see this MDN video.

  * Safari 15 and 16 display a gray border while loading. Safari 16.4 fixed this issue. Possible solutions: 
    * Use CSS `@supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading="lazy"] { clip-path: inset(0.6px) } }`
    * Use `priority` if the image is above the fold
  * Firefox 67+ displays a white background while loading. Possible solutions: 

Version| Changes  
---|---  
`v13.2.0`| `contentDispositionType` configuration added.  
`v13.0.6`| `ref` prop added.  
`v13.0.0`| The `next/image` import was renamed to `next/legacy/image`. The
`next/future/image` import was renamed to `next/image`. A codemod is available
to safely and automatically rename your imports. `<span>` wrapper removed.
`layout`, `objectFit`, `objectPosition`, `lazyBoundary`, `lazyRoot` props
removed. `alt` is required. `onLoadingComplete` receives reference to `img`
element. Built-in loader config removed.  
`v12.3.0`| `remotePatterns` and `unoptimized` configuration is stable.  
`v12.2.0`| Experimental `remotePatterns` and experimental `unoptimized`
configuration added. `layout="raw"` removed.  
`v12.1.1`| `style` prop added. Experimental support for `layout="raw"` added.  
`v12.1.0`| `dangerouslyAllowSVG` and `contentSecurityPolicy` configuration
added.  
`v12.0.9`| `lazyRoot` prop added.  
`v12.0.0`| `formats` configuration added.  
AVIF support added.  
Wrapper `<div>` changed to `<span>`.  
`v11.1.0`| `onLoadingComplete` and `lazyBoundary` props added.  
`v11.0.0`| `src` prop support for static import.  
`placeholder` prop added.  
`blurDataURL` prop added.  
`v10.0.5`| `loader` prop added.  
`v10.0.1`| `layout` prop added.  
`v10.0.0`| `next/image` introduced.





# <Image> (Legacy)

 **Examples**

Starting with Next.js 13, the `next/image` component was rewritten to improve
both the performance and developer experience. In order to provide a backwards
compatible upgrade solution, the old `next/image` was renamed to
`next/legacy/image`.

View the **new** `next/image` API Reference

Compared to `next/legacy/image`, the new `next/image` component has the
following changes:

  * Removes `<span>` wrapper around `<img>` in favor of native computed aspect ratio
  * Adds support for canonical `style` prop 
    * Removes `layout` prop in favor of `style` or `className`
    * Removes `objectFit` prop in favor of `style` or `className`
    * Removes `objectPosition` prop in favor of `style` or `className`
  * Removes `IntersectionObserver` implementation in favor of native lazy loading
    * Removes `lazyBoundary` prop since there is no native equivalent
    * Removes `lazyRoot` prop since there is no native equivalent
  * Removes `loader` config in favor of `loader` prop
  * Changed `alt` prop from optional to required
  * Changed `onLoadingComplete` callback to receive reference to `<img>` element

The `<Image />` component requires the following properties.

Must be one of the following:

When using an external URL, you must add it to remotePatterns in
`next.config.js`.

The `width` property can represent either the _rendered_ width or _original_
width in pixels, depending on the `layout` and `sizes` properties.

When using `layout="intrinsic"` or `layout="fixed"` the `width` property
represents the _rendered_ width in pixels, so it will affect how large the
image appears.

When using `layout="responsive"`, `layout="fill"`, the `width` property
represents the _original_ width in pixels, so it will only affect the aspect
ratio.

The `width` property is required, except for statically imported images, or
those with `layout="fill"`.

The `height` property can represent either the _rendered_ height or _original_
height in pixels, depending on the `layout` and `sizes` properties.

When using `layout="intrinsic"` or `layout="fixed"` the `height` property
represents the _rendered_ height in pixels, so it will affect how large the
image appears.

When using `layout="responsive"`, `layout="fill"`, the `height` property
represents the _original_ height in pixels, so it will only affect the aspect
ratio.

The `height` property is required, except for statically imported images, or
those with `layout="fill"`.

The `<Image />` component accepts a number of additional properties beyond
those which are required. This section describes the most commonly-used
properties of the Image component. Find details about more rarely-used
properties in the Advanced Props section.

The layout behavior of the image as the viewport changes size.

`layout`| Behavior| `srcSet`| `sizes`| Has wrapper and sizer  
---|---|---|---|---  
`intrinsic` (default)| Scale _down_ to fit width of container, up to image
size| `1x`, `2x` (based on imageSizes)| N/A| yes  
`fixed`| Sized to `width` and `height` exactly| `1x`, `2x` (based on
imageSizes)| N/A| yes  
`responsive`| Scale to fit width of container| `640w`, `750w`, ... `2048w`,
`3840w` (based on imageSizes and deviceSizes)| `100vw`| yes  
`fill`| Grow in both X and Y axes to fill container| `640w`, `750w`, ...
`2048w`, `3840w` (based on imageSizes and deviceSizes)| `100vw`| yes  
  
  * Demo the `intrinsic` layout (default)
    * When `intrinsic`, the image will scale the dimensions down for smaller viewports, but maintain the original dimensions for larger viewports.
  * Demo the `fixed` layout
    * When `fixed`, the image dimensions will not change as the viewport changes (no responsiveness) similar to the native `img` element.
  * Demo the `responsive` layout
    * When `responsive`, the image will scale the dimensions down for smaller viewports and scale up for larger viewports.
    * Ensure the parent element uses `display: block` in their stylesheet.
  * Demo the `fill` layout
    * When `fill`, the image will stretch both width and height to the dimensions of the parent element, provided the parent element is relative.
    * This is usually paired with the `objectFit` property.
    * Ensure the parent element has `position: relative` in their stylesheet.
  * Demo background image

A custom function used to resolve URLs. Setting the loader as a prop on the
Image component overrides the default loader defined in the `images` section
of `next.config.js`.

A `loader` is a function returning a URL string for the image, given the
following parameters:

Here is an example of using a custom loader:

    
    
    import Image from 'next/legacy/image';
     
    const myLoader = ({ src, width, quality }) => {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    };
     
    const MyImage = (props) => {
      return (
        <Image
          loader={myLoader}
          src="me.png"
          alt="Picture of the author"
          width={500}
          height={500}
        />
      );
    };

A string that provides information about how wide the image will be at
different breakpoints. The value of `sizes` will greatly affect performance
for images using `layout="responsive"` or `layout="fill"`. It will be ignored
for images using `layout="intrinsic"` or `layout="fixed"`.

The `sizes` property serves two important purposes related to image
performance:

First, the value of `sizes` is used by the browser to determine which size of
the image to download, from `next/legacy/image`'s automatically-generated
source set. When the browser chooses, it does not yet know the size of the
image on the page, so it selects an image that is the same size or larger than
the viewport. The `sizes` property allows you to tell the browser that the
image will actually be smaller than full screen. If you don't specify a
`sizes` value, a default value of `100vw` (full screen width) is used.

Second, the `sizes` value is parsed and used to trim the values in the
automatically-created source set. If the `sizes` property includes sizes such
as `50vw`, which represent a percentage of the viewport width, then the source
set is trimmed to not include any values which are too small to ever be
necessary.

For example, if you know your styling will cause an image to be full-width on
mobile devices, in a 2-column layout on tablets, and a 3-column layout on
desktop displays, you should include a sizes property such as the following:

    
    
    import Image from 'next/legacy/image';
    const Example = () => (
      <div className="grid-element">
        <Image
          src="/example.png"
          layout="fill"
          sizes="(max-width: 768px) 100vw,
                  (max-width: 1200px) 50vw,
                  33vw"
        />
      </div>
    );

This example `sizes` could have a dramatic effect on performance metrics.
Without the `33vw` sizes, the image selected from the server would be 3 times
as wide as it needs to be. Because file size is proportional to the square of
the width, without `sizes` the user would download an image that's 9 times
larger than necessary.

Learn more about `srcset` and `sizes`:

The quality of the optimized image, an integer between `1` and `100` where
`100` is the best quality. Defaults to `75`.

When true, the image will be considered high priority and preload. Lazy
loading is automatically disabled for images using `priority`.

You should use the `priority` property on any image detected as the Largest
Contentful Paint (LCP) element. It may be appropriate to have multiple
priority images, as different images may be the LCP element for different
viewport sizes.

Should only be used when the image is visible above the fold. Defaults to
`false`.

A placeholder to use while the image is loading. Possible values are `blur` or
`empty`. Defaults to `empty`.

When `blur`, the `blurDataURL` property will be used as the placeholder. If
`src` is an object from a static import and the imported image is `.jpg`,
`.png`, `.webp`, or `.avif`, then `blurDataURL` will be automatically
populated.

For dynamic images, you must provide the `blurDataURL` property. Solutions
such as Plaiceholder can help with `base64` generation.

When `empty`, there will be no placeholder while the image is loading, only
empty space.

Try it out:

In some cases, you may need more advanced usage. The `<Image />` component
optionally accepts the following advanced properties.

Allows passing CSS styles to the underlying image element.

Note that all `layout` modes apply their own styles to the image element, and
these automatic styles take precedence over the `style` prop.

Also keep in mind that the required `width` and `height` props can interact
with your styling. If you use styling to modify an image's `width`, you must
set the `height="auto"` style as well, or your image will be distorted.

Defines how the image will fit into its parent container when using
`layout="fill"`.

This value is passed to the object-fit CSS property for the `src` image.

Defines how the image is positioned within its parent element when using
`layout="fill"`.

This value is passed to the object-position CSS property applied to the image.

A callback function that is invoked once the image is completely loaded and
the placeholder has been removed.

The `onLoadingComplete` function accepts one parameter, an object with the
following properties:

> **Attention** : This property is only meant for advanced usage. Switching an
> image to load with `eager` will normally **hurt performance**.
>
> We recommend using the `priority` property instead, which properly loads the
> image eagerly for nearly all use cases.

The loading behavior of the image. Defaults to `lazy`.

When `lazy`, defer loading the image until it reaches a calculated distance
from the viewport.

When `eager`, load the image immediately.

Learn more

A Data URL to be used as a placeholder image before the `src` image
successfully loads. Only takes effect when combined with `placeholder="blur"`.

Must be a base64-encoded image. It will be enlarged and blurred, so a very
small image (10px or less) is recommended. Including larger images as
placeholders may harm your application performance.

Try it out:

You can also generate a solid color Data URL to match the image.

A string (with similar syntax to the margin property) that acts as the
bounding box used to detect the intersection of the viewport with the image
and trigger lazy loading. Defaults to `"200px"`.

If the image is nested in a scrollable parent element other than the root
document, you will also need to assign the lazyRoot prop.

Learn more

A React Ref pointing to the scrollable parent element. Defaults to `null` (the
document viewport).

The Ref must point to a DOM element or a React component that forwards the Ref
to the underlying DOM element.

**Example pointing to a DOM element**

    
    
    import Image from 'next/legacy/image';
    import React from 'react';
     
    const Example = () => {
      const lazyRoot = React.useRef(null);
     
      return (
        <div ref={lazyRoot} style={{ overflowX: 'scroll', width: '500px' }}>
          <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
          <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
        </div>
      );
    };

**Example pointing to a React component**

    
    
    import Image from 'next/legacy/image';
    import React from 'react';
     
    const Container = React.forwardRef((props, ref) => {
      return (
        <div ref={ref} style={{ overflowX: 'scroll', width: '500px' }}>
          {props.children}
        </div>
      );
    });
     
    const Example = () => {
      const lazyRoot = React.useRef(null);
     
      return (
        <Container ref={lazyRoot}>
          <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
          <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
        </Container>
      );
    };

Learn more

When true, the source image will be served as-is instead of changing quality,
size, or format. Defaults to `false`.

    
    
    import Image from 'next/image';
     
    const UnoptimizedImage = (props) => {
      return <Image {...props} unoptimized />;
    };

Since Next.js 12.3.0, this prop can be assigned to all images by updating
`next.config.js` with the following configuration:

    
    
    module.exports = {
      images: {
        unoptimized: true,
      },
    };

Other properties on the `<Image />` component will be passed to the underlying
`img` element with the exception of the following:

To protect your application from malicious users, configuration is required in
order to use external images. This ensures that only external images from your
account can be served from the Next.js Image Optimization API. These external
images can be configured with the `remotePatterns` property in your
`next.config.js` file, as shown below:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 'example.com',
            port: '',
            pathname: '/account123/**',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of
> `next/legacy/image` must start with `https://example.com/account123/`. Any
> other protocol, hostname, port, or unmatched path will respond with 400 Bad
> Request.

Below is another example of the `remotePatterns` property in the
`next.config.js` file:

    
    
    module.exports = {
      images: {
        remotePatterns: [
          {
            protocol: 'https',
            hostname: '**.example.com',
          },
        ],
      },
    };

> **Note** : The example above will ensure the `src` property of
> `next/legacy/image` must start with `https://img1.example.com` or
> `https://me.avatar.example.com` or any number of subdomains. Any other
> protocol or unmatched hostname will respond with 400 Bad Request.

Wildcard patterns can be used for both `pathname` and `hostname` and have the
following syntax:

  * `*` match a single path segment or subdomain
  * `**` match any number of path segments at the end or subdomains at the beginning

The `**` syntax does not work in the middle of the pattern.

> **Warning** : We recommend configuring strict `remotePatterns` instead of
> `domains` in order to protect your application from malicious users. Only
> use `domains` if you own all the content served from the domain.

Similar to `remotePatterns`, the `domains` configuration can be used to
provide a list of allowed hostnames for external images.

However, the `domains` configuration does not support wildcard pattern
matching and it cannot restrict protocol, port, or pathname.

Below is an example of the `domains` property in the `next.config.js` file:

    
    
    module.exports = {
      images: {
        domains: ['assets.acme.com'],
      },
    };

If you want to use a cloud provider to optimize images instead of using the
Next.js built-in Image Optimization API, you can configure the `loader` and
`path` prefix in your `next.config.js` file. This allows you to use relative
URLs for the Image `src` and automatically generate the correct absolute URL
for your provider.

    
    
    module.exports = {
      images: {
        loader: 'imgix',
        path: 'https://example.com/myaccount/',
      },
    };

The following Image Optimization cloud providers are included:

  * Default: Works automatically with `next dev`, `next start`, or a custom server
  * Vercel: Works automatically when you deploy on Vercel, no configuration necessary. Learn more
  * Imgix: `loader: 'imgix'`
  * Cloudinary: `loader: 'cloudinary'`
  * Akamai: `loader: 'akamai'`
  * Custom: `loader: 'custom'` use a custom cloud provider by implementing the `loader` prop on the `next/legacy/image` component

If you need a different provider, you can use the `loader` prop with
`next/legacy/image`.

> Images can not be optimized at build time using `output: 'export'`, only on-
> demand. To use `next/legacy/image` with `output: 'export'`, you will need to
> use a different loader than the default. Read more in the discussion.

> The `next/legacy/image` component's default loader uses `squoosh` because it
> is quick to install and suitable for a development environment. When using
> `next start` in your production environment, it is strongly recommended that
> you install `sharp` by running `yarn add sharp` in your project directory.
> This is not necessary for Vercel deployments, as `sharp` is installed
> automatically.

The following configuration is for advanced use cases and is usually not
necessary. If you choose to configure the properties below, you will override
any changes to the Next.js defaults in future updates.

If you know the expected device widths of your users, you can specify a list
of device width breakpoints using the `deviceSizes` property in
`next.config.js`. These widths are used when the `next/legacy/image` component
uses `layout="responsive"` or `layout="fill"` to ensure the correct image is
served for user's device.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
      },
    };

You can specify a list of image widths using the `images.imageSizes` property
in your `next.config.js` file. These widths are concatenated with the array of
device sizes to form the full array of sizes used to generate image srcsets.

The reason there are two separate lists is that imageSizes is only used for
images which provide a `sizes` prop, which indicates that the image is less
than the full width of the screen. **Therefore, the sizes in imageSizes should
all be smaller than the smallest size in deviceSizes.**

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
      },
    };

The default Image Optimization API will automatically detect the browser's
supported image formats via the request's `Accept` header.

If the `Accept` head matches more than one of the configured formats, the
first match in the array is used. Therefore, the array order matters. If there
is no match (or the source image is animated), the Image Optimization API will
fallback to the original image's format.

If no configuration is provided, the default below is used.

    
    
    module.exports = {
      images: {
        formats: ['image/webp'],
      },
    };

You can enable AVIF support with the following configuration.

    
    
    module.exports = {
      images: {
        formats: ['image/avif', 'image/webp'],
      },
    };

> **Note** : AVIF generally takes 20% longer to encode but it compresses 20%
> smaller compared to WebP. This means that the first time an image is
> requested, it will typically be slower and then subsequent requests that are
> cached will be faster.

The following describes the caching algorithm for the default loader. For all
other loaders, please refer to your cloud provider's documentation.

Images are optimized dynamically upon request and stored in the
`<distDir>/cache/images` directory. The optimized image file will be served
for subsequent requests until the expiration is reached. When a request is
made that matches a cached but expired file, the expired image is served stale
immediately. Then the image is optimized again in the background (also called
revalidation) and saved to the cache with the new expiration date.

The cache status of an image can be determined by reading the value of the
`x-nextjs-cache` (`x-vercel-cache` when deployed on Vercel) response header.
The possible values are the following:

  * `MISS` \- the path is not in the cache (occurs at most once, on the first visit)
  * `STALE` \- the path is in the cache but exceeded the revalidate time so it will be updated in the background
  * `HIT` \- the path is in the cache and has not exceeded the revalidate time

The expiration (or rather Max Age) is defined by either the `minimumCacheTTL`
configuration or the upstream image `Cache-Control` header, whichever is
larger. Specifically, the `max-age` value of the `Cache-Control` header is
used. If both `s-maxage` and `max-age` are found, then `s-maxage` is
preferred. The `max-age` is also passed-through to any downstream clients
including CDNs and browsers.

  * You can configure `minimumCacheTTL` to increase the cache duration when the upstream image does not include `Cache-Control` header or the value is very low.
  * You can configure `deviceSizes` and `imageSizes` to reduce the total number of possible generated images.
  * You can configure formats to disable multiple formats in favor of a single image format.

You can configure the Time to Live (TTL) in seconds for cached optimized
images. In many cases, it's better to use a Static Image Import which will
automatically hash the file contents and cache the image forever with a
`Cache-Control` header of `immutable`.

    
    
    module.exports = {
      images: {
        minimumCacheTTL: 60,
      },
    };

The expiration (or rather Max Age) of the optimized image is defined by either
the `minimumCacheTTL` or the upstream image `Cache-Control` header, whichever
is larger.

If you need to change the caching behavior per image, you can configure
`headers` to set the `Cache-Control` header on the upstream image (e.g.
`/some-asset.jpg`, not `/_next/image` itself).

There is no mechanism to invalidate the cache at this time, so its best to
keep `minimumCacheTTL` low. Otherwise you may need to manually change the
`src` prop or delete `<distDir>/cache/images`.

The default behavior allows you to import static files such as `import icon
from './icon.png` and then pass that to the `src` property.

In some cases, you may wish to disable this feature if it conflicts with other
plugins that expect the import to behave differently.

You can disable static image imports inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        disableStaticImages: true,
      },
    };

The default loader does not optimize SVG images for a few reasons. First, SVG
is a vector format meaning it can be resized losslessly. Second, SVG has many
of the same features as HTML/CSS, which can lead to vulnerabilities without
proper Content Security Policy (CSP) headers.

If you need to serve SVG images with the default Image Optimization API, you
can set `dangerouslyAllowSVG` inside your `next.config.js`:

    
    
    module.exports = {
      images: {
        dangerouslyAllowSVG: true,
        contentDispositionType: 'attachment',
        contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
      },
    };

In addition, it is strongly recommended to also set `contentDispositionType`
to force the browser to download the image, as well as `contentSecurityPolicy`
to prevent scripts embedded in the image from executing.

The default loader will automatically bypass Image Optimization for animated
images and serve the image as-is.

Auto-detection for animated files is best-effort and supports GIF, APNG, and
WebP. If you want to explicitly bypass Image Optimization for a given animated
image, use the unoptimized prop.

Version| Changes  
---|---  
`v13.0.0`| `next/image` renamed to `next/legacy/image`





# <Link>

 **Examples**

`<Link>` is a React component that extends the HTML `<a>` element to provide
prefetching and client-side navigation between routes. It is the primary way
to navigate between routes in Next.js.

For an example, consider a `pages` directory with the following files:

  * `pages/index.js`
  * `pages/about.js`
  * `pages/blog/[slug].js`

We can have a link to each of these pages like so:

    
    
    import Link from 'next/link';
     
    function Home() {
      return (
        <ul>
          <li>
            <Link href="/">Home</Link>
          </li>
          <li>
            <Link href="/about">About Us</Link>
          </li>
          <li>
            <Link href="/blog/hello-world">Blog Post</Link>
          </li>
        </ul>
      );
    }
     
    export default Home;

Here's a summary of the props available for the Link Component:

Prop| Example| Type| Required  
---|---|---|---  
`href`| `href="/dashboard"`| String or Object| Yes  
`replace`| `replace={false}`| Boolean| -  
`prefetch`| `prefetch={false}`| Boolean| -  
  
> **Good to know** : `<a>` tag attributes such as `className` or
> `target="_blank"` can be added to `<Link>` as props and will be passed to
> the underlying `<a>` element.

The path or URL to navigate to.

    
    
    <Link href="/dashboard">Dashboard</Link>

`href` can also accept an object, for example:

    
    
    // Navigate to /about?name=test
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>

**Defaults to`false`.** When `true`, `next/link` will replace the current
history state instead of adding a new URL into the browser’s history stack.

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return (
        <Link href="/dashboard" replace>
          Dashboard
        </Link>
      );
    }

**Defaults to`true`.** When `true`, `next/link` will prefetch the page
(denoted by the `href`) in the background. This is useful for improving the
performance of client-side navigations. Any `<Link />` in the viewport
(initially or through scroll) will be preloaded.

Prefetch can be disabled by passing `prefetch={false}`. Prefetching is only
enabled in production.

    
    
    import Link from 'next/link';
     
    export default function Page() {
      return (
        <Link href="/dashboard" prefetch={false}>
          Dashboard
        </Link>
      );
    }

An `<a>` element is no longer required as a child of `<Link>`. Add the
`legacyBehavior` prop to use the legacy behavior or remove the `<a>` to
upgrade. A codemod is available to automatically upgrade your code.

> **Note** : when `legacyBehavior` is not set to `true`, all `anchor` tag
> properties can be passed to `next/link` as well such as, `className`,
> `onClick`, etc.

Forces `Link` to send the `href` property to its child. Defaults to `false`

Scroll to the top of the page after a navigation. Defaults to `true`

Update the path of the current page without rerunning `getStaticProps`,
`getServerSideProps` or `getInitialProps`. Defaults to `false`

The active locale is automatically prepended. `locale` allows for providing a
different locale. When `false` `href` has to include the locale as the default
behavior is disabled.

For dynamic routes, it can be handy to use template literals to create the
link's path.

For example, you can generate a list of links to the dynamic route
`pages/blog/[slug].js`

    
    
    import Link from 'next/link';
     
    function Posts({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/blog/${post.slug}`}>{post.title}</Link>
            </li>
          ))}
        </ul>
      );
    }
     
    export default Posts;

If the child of `Link` is a custom component that wraps an `<a>` tag, you must
add `passHref` to `Link`. This is necessary if you’re using libraries like
styled-components. Without this, the `<a>` tag will not have the `href`
attribute, which hurts your site's accessibility and might affect SEO. If
you're using ESLint, there is a built-in rule `next/link-passhref` to ensure
correct usage of `passHref`.

    
    
    import Link from 'next/link';
    import styled from 'styled-components';
     
    // This creates a custom component that wraps an <a> tag
    const RedLink = styled.a`
      color: red;
    `;
     
    function NavLink({ href, name }) {
      return (
        <Link href={href} passHref legacyBehavior>
          <RedLink>{name}</RedLink>
        </Link>
      );
    }
     
    export default NavLink;

  * If you’re using emotion’s JSX pragma feature (`@jsx jsx`), you must use `passHref` even if you use an `<a>` tag directly.
  * The component should support `onClick` property to trigger navigation correctly

If the child of `Link` is a functional component, in addition to using
`passHref` and `legacyBehavior`, you must wrap the component in
`React.forwardRef`:

    
    
    import Link from 'next/link';
     
    // `onClick`, `href`, and `ref` need to be passed to the DOM element
    // for proper handling
    const MyButton = React.forwardRef(({ onClick, href }, ref) => {
      return (
        <a href={href} onClick={onClick} ref={ref}>
          Click Me
        </a>
      );
    });
     
    function Home() {
      return (
        <Link href="/about" passHref legacyBehavior>
          <MyButton />
        </Link>
      );
    }
     
    export default Home;

`Link` can also receive a URL object and it will automatically format it to
create the URL string. Here's how to do it:

    
    
    import Link from 'next/link';
     
    function Home() {
      return (
        <ul>
          <li>
            <Link
              href={{
                pathname: '/about',
                query: { name: 'test' },
              }}
            >
              About us
            </Link>
          </li>
          <li>
            <Link
              href={{
                pathname: '/blog/[slug]',
                query: { slug: 'my-post' },
              }}
            >
              Blog Post
            </Link>
          </li>
        </ul>
      );
    }
     
    export default Home;

The above example has a link to:

  * A predefined route: `/about?name=test`
  * A dynamic route: `/blog/my-post`

You can use every property as defined in the Node.js URL module documentation.

The default behavior of the `Link` component is to `push` a new URL into the
`history` stack. You can use the `replace` prop to prevent adding a new entry,
as in the following example:

    
    
    <Link href="/about" replace>
      About us
    </Link>

The default behavior of `Link` is to scroll to the top of the page. When there
is a hash defined it will scroll to the specific id, like a normal `<a>` tag.
To prevent scrolling to the top / hash `scroll={false}` can be added to
`Link`:

    
    
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>

It's common to use Middleware for authentication or other purposes that
involve rewriting the user to a different page. In order for the `<Link />`
component to properly prefetch links with rewrites via Middleware, you need to
tell Next.js both the URL to display and the URL to prefetch. This is required
to avoid un-necessary fetches to middleware to know the correct route to
prefetch.

For example, if you have want to serve a `/dashboard` route that has
authenticated and visitor views, you may add something similar to the
following in your Middleware to redirect the user to the correct page:

    
    
    export function middleware(req) {
      const nextUrl = req.nextUrl;
      if (nextUrl.pathname === '/dashboard') {
        if (req.cookies.authToken) {
          return NextResponse.rewrite(new URL('/auth/dashboard', req.url));
        } else {
          return NextResponse.rewrite(new URL('/public/dashboard', req.url));
        }
      }
    }

In this case, you would want to use the following code in your `<Link />`
component:

    
    
    import Link from 'next/link';
    import useIsAuthed from './hooks/useIsAuthed';
     
    export default function Page() {
      const isAuthed = useIsAuthed();
      const path = isAuthed ? '/auth/dashboard' : '/dashboard';
      return (
        <Link as="/dashboard" href={path}>
          Dashboard
        </Link>
      );
    }

> **Note** : If you're using Dynamic Routes, you'll need to adapt your `as`
> and `href` props. For example, if you have a Dynamic Route like
> `/dashboard/[user]` that you want to present differently via middleware, you
> would write: `<Link href={{ pathname: '/dashboard/authed/[user]', query: {
> user: username } }} as="/dashboard/[user]">Profile</Link>`.



  
  
# <Script>

This API reference will help you understand how to use props available for the
Script Component. For features and usage, please see the Optimizing Scripts
page.

    
    
    import Script from 'next/script';
     
    export default function Dashboard() {
      return (
        <>
          <Script src="https://example.com/script.js" />
        </>
      );
    }

Here's a summary of the props available for the Script Component:

Prop| Example| Type| Required  
---|---|---|---  
`src`| `src="http://example.com/script"`| String| Required unless inline
script is used  
`strategy`| `strategy="lazyOnload"`| String| -  
`onLoad`| `onLoad={onLoadFunc}`| Function| -  
`onReady`| `onReady={onReadyFunc}`| Function| -  
`onError`| `onError={onErrorFunc}`| Function| -  
  
The `<Script />` component requires the following properties.

A path string specifying the URL of an external script. This can be either an
absolute external URL or an internal path. The `src` property is required
unless an inline script is used.

The `<Script />` component accepts a number of additional properties beyond
those which are required.

The loading strategy of the script. There are four different strategies that
can be used:

  * `beforeInteractive`: Load before any Next.js code and before any page hydration occurs.
  * `afterInteractive`: ( **default** ) Load early but after some hydration on the page occurs.
  * `lazyOnload`: Load during browser idle time.
  * `worker`: (experimental) Load in a web worker.

Scripts that load with the `beforeInteractive` strategy are injected into the
initial HTML from the server, downloaded before any Next.js module, and
executed in the order they are placed before _any_ hydration occurs on the
page.

Scripts denoted with this strategy are preloaded and fetched before any first-
party code, but their execution does not block page hydration from occurring.

`beforeInteractive` scripts must be placed inside the root layout
(`app/layout.tsx)` and are designed to load scripts that are needed by the
entire site (i.e. the script will load when any page in the application has
been loaded server-side).

**This strategy should only be used for critical scripts that need to be
fetched before any part of the page becomes interactive.**

    
    
    import { Html, Head, Main, NextScript } from 'next/document';
    import Script from 'next/script';
     
    export default function Document() {
      return (
        <Html>
          <Head />
          <body>
            <Main />
            <NextScript />
            <Script
              src="https://example.com/script.js"
              strategy="beforeInteractive"
            />
          </body>
        </Html>
      );
    }

> **Good to know** : Scripts with `beforeInteractive` will always be injected
> inside the `head` of the HTML document regardless of where it's placed in
> the component.

Some examples of scripts that should be loaded as soon as possible with
`beforeInteractive` include:

  * Bot detectors
  * Cookie consent managers

Scripts that use the `afterInteractive` strategy are injected into the HTML
client-side and will load after some (or all) hydration occurs on the page.
**This is the default strategy** of the Script component and should be used
for any script that needs to load as soon as possible but not before any
first-party Next.js code.

`afterInteractive` scripts can be placed inside of any page or layout and will
only load and execute when that page (or group of pages) is opened in the
browser.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="afterInteractive" />
        </>
      );
    }

Some examples of scripts that are good candidates for `afterInteractive`
include:

Scripts that use the `lazyOnload` strategy are injected into the HTML client-
side during browser idle time and will load after all resources on the page
have been fetched. This strategy should be used for any background or low
priority scripts that do not need to load early.

`lazyOnload` scripts can be placed inside of any page or layout and will only
load and execute when that page (or group of pages) is opened in the browser.

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="lazyOnload" />
        </>
      );
    }

Examples of scripts that do not need to load immediately and can be fetched
with `lazyOnload` include:

  * Chat support plugins
  * Social media widgets

> **Warning:** The `worker` strategy is not yet stable and does not yet work
> with the `app` directory. Use with caution.

Scripts that use the `worker` strategy are off-loaded to a web worker in order
to free up the main thread and ensure that only critical, first-party
resources are processed on it. While this strategy can be used for any script,
it is an advanced use case that is not guaranteed to support all third-party
scripts.

To use `worker` as a stratgy, the `nextScriptWorkers` flag must be enabled in
`next.config.js`:

    
    
    module.exports = {
      experimental: {
        nextScriptWorkers: true,
      },
    };

`worker` scripts can **only currently be used in the`pages/` directory**:

    
    
    import Script from 'next/script';
     
    export default function Home() {
      return (
        <>
          <Script src="https://example.com/script.js" strategy="worker" />
        </>
      );
    }

> **Warning:** `onLoad` does not yet work with Server Components and can only
> be used in Client Components. Further, `onLoad` can't be used with
> `beforeInteractive` – consider using `onReady` instead.

Some third-party scripts require users to run JavaScript code once after the
script has finished loading in order to instantiate content or call a
function. If you are loading a script with either afterInteractive or
lazyOnload as a loading strategy, you can execute code after it has loaded
using the onLoad property.

Here's an example of executing a lodash method only after the library has been
loaded.

    
    
    'use client';
     
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"
            onLoad={() => {
              console.log(_.sample([1, 2, 3, 4]));
            }}
          />
        </>
      );
    }

> **Warning:** `onReady` does not yet work with Server Components and can only
> be used in Client Components.

Some third-party scripts require users to run JavaScript code after the script
has finished loading and every time the component is mounted (after a route
navigation for example). You can execute code after the script's load event
when it first loads and then after every subsequent component re-mount using
the onReady property.

Here's an example of how to re-instantiate a Google Maps JS embed every time
the component is mounted:

    
    
    import { useRef } from 'react';
    import Script from 'next/script';
     
    export default function Page() {
      const mapRef = useRef();
     
      return (
        <PagesOnly>
          <div ref={mapRef}></div>
          <Script
            id="google-maps"
            src="https://maps.googleapis.com/maps/api/js"
            onReady={() => {
              new google.maps.Map(mapRef.current, {
                center: { lat: -34.397, lng: 150.644 },
                zoom: 8,
              });
            }}
          />
        </>
      );
    }

> **Warning:** `onError` does not yet work with Server Components and can only
> be used in Client Components. `onError` cannot be used with the
> `beforeInteractive` loading strategy.

Sometimes it is helpful to catch when a script fails to load. These errors can
be handled with the onError property:

    
    
    import Script from 'next/script';
     
    export default function Page() {
      return (
        <>
          <Script
            src="https://example.com/script.js"
            onError={(e: Error) => {
              console.error('Script failed to load', e);
            }}
          />
        </>
      );
    }

Version| Changes  
---|---  
`v13.0.0`| `beforeInteractive` and `afterInteractive` is modified to support
`app`  
`v12.2.4`| `onReady` prop added.  
`v12.2.2`| Allow `next/script` with `beforeInteractive` to be placed in
`_document`.  
`v11.0.0`| `next/script` introduced.



  
  
Using Pages Router

Features available in /pages



  
  
Using Pages Router

Features available in /pages



  
  
# getServerSideProps

When exporting a function called `getServerSideProps` (Server-Side Rendering)
from a page, Next.js will pre-render this page on each request using the data
returned by `getServerSideProps`. This is useful if you want to fetch data
that changes often, and have the page update to show the most current data.

    
    
    import type { InferGetServerSidePropsType, GetServerSideProps } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getServerSideProps: GetServerSideProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetServerSidePropsType<typeof getServerSideProps>) {
      return repo.stargazers_count;
    }

You can import modules in top-level scope for use in `getServerSideProps`.
Imports used will **not be bundled for the client-side**. This means you can
write **server-side code directly in`getServerSideProps`**, including fetching
data from your database.

The `context` parameter is an object containing the following keys:

Name| Description  
---|---  
`params`| If this page uses a dynamic route, `params` contains the route
parameters. If the page name is `[id].js`, then `params` will look like `{ id:
... }`.  
`req`| The `HTTP` IncomingMessage object, with an additional `cookies` prop,
which is an object with string keys mapping to string values of cookies.  
`res`| The `HTTP` response object.  
`query`| An object representing the query string, including dynamic route
parameters.  
`preview`| (Deprecated for `draftMode`) `preview` is `true` if the page is in
the Preview Mode and `false` otherwise.  
`previewData`| (Deprecated for `draftMode`) The preview data set by
`setPreviewData`.  
`draftMode`| `draftMode` is `true` if the page is in the Draft Mode and
`false` otherwise.  
`resolvedUrl`| A normalized version of the request `URL` that strips the
`_next/data` prefix for client transitions and includes original query values.  
`locale`| Contains the active locale (if enabled).  
`locales`| Contains all supported locales (if enabled).  
`defaultLocale`| Contains the configured default locale (if enabled).  
  
The `getServerSideProps` function should return an object with **any one of
the following** properties:

The `props` object is a key-value pair, where each value is received by the
page component. It should be a serializable object so that any props passed,
could be serialized with `JSON.stringify`.

    
    
    export async function getServerSideProps(context) {
      return {
        props: { message: `Next.js is awesome` }, // will be passed to the page component as props
      };
    }

The `notFound` boolean allows the page to return a `404` status and 404 Page.
With `notFound: true`, the page will return a `404` even if there was a
successfully generated page before. This is meant to support use cases like
user-generated content getting removed by its author.

    
    
    export async function getServerSideProps(context) {
      const res = await fetch(`https://.../data`);
      const data = await res.json();
     
      if (!data) {
        return {
          notFound: true,
        };
      }
     
      return {
        props: { data }, // will be passed to the page component as props
      };
    }

The `redirect` object allows redirecting to internal and external resources.
It should match the shape of `{ destination: string, permanent: boolean }`. In
some rare cases, you might need to assign a custom status code for older
`HTTP` clients to properly redirect. In these cases, you can use the
`statusCode` property instead of the `permanent` property, but not both.

    
    
    export async function getServerSideProps(context) {
      const res = await fetch(`https://.../data`);
      const data = await res.json();
     
      if (!data) {
        return {
          redirect: {
            destination: '/',
            permanent: false,
          },
        };
      }
     
      return {
        props: {}, // will be passed to the page component as props
      };
    }

Version| Changes  
---|---  
`v13.4.0`| App Router is now stable with simplifed data fetching  
`v10.0.0`| `locale`, `locales`, `defaultLocale`, and `notFound` options added.  
`v9.3.0`| `getServerSideProps` introduced.





# getStaticPaths

When exporting a function called `getStaticPaths` from a page that uses
Dynamic Routes, Next.js will statically pre-render all the paths specified by
`getStaticPaths`.

    
    
    import type {
      InferGetStaticPropsType,
      GetStaticProps,
      GetStaticPaths,
    } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getStaticPaths: GetStaticPaths = async () => {
      return {
        paths: [
          {
            params: {
              name: 'next.js',
            },
          }, // See the "paths" section below
        ],
        fallback: true, // false or "blocking"
      };
    };
     
    export const getStaticProps: GetStaticProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetStaticPropsType<typeof getStaticProps>) {
      return repo.stargazers_count;
    }

The `getStaticPaths` function should return an object with the following
**required** properties:

The `paths` key determines which paths will be pre-rendered. For example,
suppose that you have a page that uses Dynamic Routes named
`pages/posts/[id].js`. If you export `getStaticPaths` from this page and
return the following for `paths`:

    
    
    return {
      paths: [
        { params: { id: '1' }},
        {
          params: { id: '2' },
          // with i18n configured the locale for the path can be returned as well
          locale: "en",
        },
      ],
      fallback: ...
    }

Then, Next.js will statically generate `/posts/1` and `/posts/2` during `next
build` using the page component in `pages/posts/[id].js`.

The value for each `params` object must match the parameters used in the page
name:

  * If the page name is `pages/posts/[postId]/[commentId]`, then `params` should contain `postId` and `commentId`.
  * If the page name uses catch-all routes like `pages/[...slug]`, then `params` should contain `slug` (which is an array). If this array is `['hello', 'world']`, then Next.js will statically generate the page at `/hello/world`.
  * If the page uses an optional catch-all route, use `null`, `[]`, `undefined` or `false` to render the root-most route. For example, if you supply `slug: false` for `pages/[[...slug]]`, Next.js will statically generate the page `/`.

The `params` strings are **case-sensitive** and ideally should be normalized
to ensure the paths are generated correctly. For example, if `WoRLD` is
returned for a param it will only match if `WoRLD` is the actual path visited,
not `world` or `World`.

Separate of the `params` object a `locale` field can be returned when i18n is
configured, which configures the locale for the path being generated.

If `fallback` is `false`, then any paths not returned by `getStaticPaths` will
result in a **404 page**.

When `next build` is run, Next.js will check if `getStaticPaths` returned
`fallback: false`, it will then build **only** the paths returned by
`getStaticPaths`. This option is useful if you have a small number of paths to
create, or new page data is not added often. If you find that you need to add
more paths, and you have `fallback: false`, you will need to run `next build`
again so that the new paths can be generated.

The following example pre-renders one blog post per page called
`pages/posts/[id].js`. The list of blog posts will be fetched from a CMS and
returned by `getStaticPaths`. Then, for each page, it fetches the post data
from a CMS using `getStaticProps`.

    
    
    function Post({ post }) {
      // Render post...
    }
     
    // This function gets called at build time
    export async function getStaticPaths() {
      // Call an external API endpoint to get posts
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      // Get the paths we want to pre-render based on posts
      const paths = posts.map((post) => ({
        params: { id: post.id },
      }));
     
      // We'll pre-render only these paths at build time.
      // { fallback: false } means other routes should 404.
      return { paths, fallback: false };
    }
     
    // This also gets called at build time
    export async function getStaticProps({ params }) {
      // params contains the post `id`.
      // If the route is like /posts/1, then params.id is 1
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      // Pass post data to the page via props
      return { props: { post } };
    }
     
    export default Post;

**Examples**

If `fallback` is `true`, then the behavior of `getStaticProps` changes in the
following ways:

  * The paths returned from `getStaticPaths` will be rendered to `HTML` at build time by `getStaticProps`.
  * The paths that have not been generated at build time will **not** result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path. Web crawlers, such as Google, won't be served a fallback and instead the path will behave as in `fallback: 'blocking'`.
  * When a page with `fallback: true` is navigated to through `next/link` or `next/router` (client-side) Next.js will _not_ serve a fallback and instead the page will behave as `fallback: 'blocking'`.
  * In the background, Next.js will statically generate the requested path `HTML` and `JSON`. This includes running `getStaticProps`.
  * When complete, the browser receives the `JSON` for the generated path. This will be used to automatically render the page with the required props. From the user’s perspective, the page will be swapped from the fallback page to the full page.
  * At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time.

> **Note** : `fallback: true` is not supported when using `output: 'export'`.

`fallback: true` is useful if your app has a very large number of static pages
that depend on data (such as a very large e-commerce site). If you want to
pre-render all product pages, the builds would take a very long time.

Instead, you may statically generate a small subset of pages and use
`fallback: true` for the rest. When someone requests a page that is not
generated yet, the user will see the page with a loading indicator or skeleton
component.

Shortly after, `getStaticProps` finishes and the page will be rendered with
the requested data. From now on, everyone who requests the same page will get
the statically pre-rendered page.

This ensures that users always have a fast experience while preserving fast
builds and the benefits of Static Generation.

`fallback: true` will not _update_ generated pages, for that take a look at
Incremental Static Regeneration.

If `fallback` is `'blocking'`, new paths not returned by `getStaticPaths` will
wait for the `HTML` to be generated, identical to SSR (hence why _blocking_ ),
and then be cached for future requests so it only happens once per path.

`getStaticProps` will behave as follows:

  * The paths returned from `getStaticPaths` will be rendered to `HTML` at build time by `getStaticProps`.
  * The paths that have not been generated at build time will **not** result in a 404 page. Instead, Next.js will SSR on the first request and return the generated `HTML`.
  * When complete, the browser receives the `HTML` for the generated path. From the user’s perspective, it will transition from "the browser is requesting the page" to "the full page is loaded". There is no flash of loading/fallback state.
  * At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time.

`fallback: 'blocking'` will not _update_ generated pages by default. To update
generated pages, use Incremental Static Regeneration in conjunction with
`fallback: 'blocking'`.

> **Note** : `fallback: 'blocking'` is not supported when using `output:
> 'export'`.

In the “fallback” version of a page:

  * The page’s props will be empty.
  * Using the router, you can detect if the fallback is being rendered, `router.isFallback` will be `true`.

The following example showcases using `isFallback`:

    
    
    import { useRouter } from 'next/router';
     
    function Post({ post }) {
      const router = useRouter();
     
      // If the page is not yet generated, this will be displayed
      // initially until getStaticProps() finishes running
      if (router.isFallback) {
        return <div>Loading...</div>;
      }
     
      // Render post...
    }
     
    // This function gets called at build time
    export async function getStaticPaths() {
      return {
        // Only `/posts/1` and `/posts/2` are generated at build time
        paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
        // Enable statically generating additional pages
        // For example: `/posts/3`
        fallback: true,
      };
    }
     
    // This also gets called at build time
    export async function getStaticProps({ params }) {
      // params contains the post `id`.
      // If the route is like /posts/1, then params.id is 1
      const res = await fetch(`https://.../posts/${params.id}`);
      const post = await res.json();
     
      // Pass post data to the page via props
      return {
        props: { post },
        // Re-generate the post at most once per second
        // if a request comes in
        revalidate: 1,
      };
    }
     
    export default Post;





# getStaticProps

Exporting a function called `getStaticProps` will pre-render a page at build
time using the props returned from the function:

    
    
    import type { InferGetStaticPropsType, GetStaticProps } from 'next';
     
    type Repo = {
      name: string;
      stargazers_count: number;
    };
     
    export const getStaticProps: GetStaticProps<{
      repo: Repo;
    }> = async () => {
      const res = await fetch('https://api.github.com/repos/vercel/next.js');
      const repo = await res.json();
      return { props: { repo } };
    };
     
    export default function Page({
      repo,
    }: InferGetStaticPropsType<typeof getStaticProps>) {
      return repo.stargazers_count;
    }

You can import modules in top-level scope for use in `getStaticProps`. Imports
used will **not be bundled for the client-side**. This means you can write
**server-side code directly in`getStaticProps`**, including fetching data from
your database.

The `context` parameter is an object containing the following keys:

Name| Description  
---|---  
`params`| Contains the route parameters for pages using dynamic routes. For
example, if the page name is `[id].js`, then `params` will look like `{ id:
... }`. You should use this together with `getStaticPaths`, which we'll
explain later.  
`preview`| (Deprecated for `draftMode`) `preview` is `true` if the page is in
the Preview Mode and `false` otherwise.  
`previewData`| (Deprecated for `draftMode`) The preview data set by
`setPreviewData`.  
`draftMode`| `draftMode` is `true` if the page is in the Draft Mode and
`false` otherwise.  
`locale`| Contains the active locale (if enabled).  
`locales`| Contains all supported locales (if enabled).  
`defaultLocale`| Contains the configured default locale (if enabled).  
  
The `getStaticProps` function should return an object containing either
`props`, `redirect`, or `notFound` followed by an **optional** `revalidate`
property.

The `props` object is a key-value pair, where each value is received by the
page component. It should be a serializable object so that any props passed,
could be serialized with `JSON.stringify`.

    
    
    export async function getStaticProps(context) {
      return {
        props: { message: `Next.js is awesome` }, // will be passed to the page component as props
      };
    }

The `revalidate` property is the amount in seconds after which a page re-
generation can occur (defaults to `false` or no revalidation).

    
    
    // This function gets called at build time on server-side.
    // It may be called again, on a serverless function, if
    // revalidation is enabled and a new request comes in
    export async function getStaticProps() {
      const res = await fetch('https://.../posts');
      const posts = await res.json();
     
      return {
        props: {
          posts,
        },
        // Next.js will attempt to re-generate the page:
        // - When a request comes in
        // - At most once every 10 seconds
        revalidate: 10, // In seconds
      };
    }

Learn more about Incremental Static Regeneration.

The cache status of a page leveraging ISR can be determined by reading the
value of the `x-nextjs-cache` response header. The possible values are the
following:

  * `MISS` \- the path is not in the cache (occurs at most once, on the first visit)
  * `STALE` \- the path is in the cache but exceeded the revalidate time so it will be updated in the background
  * `HIT` \- the path is in the cache and has not exceeded the revalidate time

The `notFound` boolean allows the page to return a `404` status and 404 Page.
With `notFound: true`, the page will return a `404` even if there was a
successfully generated page before. This is meant to support use cases like
user-generated content getting removed by its author. Note, `notFound` follows
the same `revalidate` behavior described here.

    
    
    export async function getStaticProps(context) {
      const res = await fetch(`https://.../data`);
      const data = await res.json();
     
      if (!data) {
        return {
          notFound: true,
        };
      }
     
      return {
        props: { data }, // will be passed to the page component as props
      };
    }

> **Note** : `notFound` is not needed for `fallback: false` mode as only paths
> returned from `getStaticPaths` will be pre-rendered.

The `redirect` object allows redirecting to internal or external resources. It
should match the shape of `{ destination: string, permanent: boolean }`.

In some rare cases, you might need to assign a custom status code for older
`HTTP` clients to properly redirect. In these cases, you can use the
`statusCode` property instead of the `permanent` property, **but not both**.
You can also set `basePath: false` similar to redirects in `next.config.js`.

    
    
    export async function getStaticProps(context) {
      const res = await fetch(`https://...`);
      const data = await res.json();
     
      if (!data) {
        return {
          redirect: {
            destination: '/',
            permanent: false,
            // statusCode: 301
          },
        };
      }
     
      return {
        props: { data }, // will be passed to the page component as props
      };
    }

If the redirects are known at build-time, they should be added in
`next.config.js` instead.

Files can be read directly from the filesystem in `getStaticProps`.

In order to do so you have to get the full path to a file.

Since Next.js compiles your code into a separate directory you can't use
`__dirname` as the path it returns will be different from the Pages Router.

Instead you can use `process.cwd()` which gives you the directory where
Next.js is being executed.

    
    
    import { promises as fs } from 'fs';
    import path from 'path';
     
    // posts will be populated at build time by getStaticProps()
    function Blog({ posts }) {
      return (
        <ul>
          {posts.map((post) => (
            <li>
              <h3>{post.filename}</h3>
              <p>{post.content}</p>
            </li>
          ))}
        </ul>
      );
    }
     
    // This function gets called at build time on server-side.
    // It won't be called on client-side, so you can even do
    // direct database queries.
    export async function getStaticProps() {
      const postsDirectory = path.join(process.cwd(), 'posts');
      const filenames = await fs.readdir(postsDirectory);
     
      const posts = filenames.map(async (filename) => {
        const filePath = path.join(postsDirectory, filename);
        const fileContents = await fs.readFile(filePath, 'utf8');
     
        // Generally you would parse/transform the contents
        // For example you can transform markdown to HTML here
     
        return {
          filename,
          content: fileContents,
        };
      });
      // By returning { props: { posts } }, the Blog component
      // will receive `posts` as a prop at build time
      return {
        props: {
          posts: await Promise.all(posts),
        },
      };
    }
     
    export default Blog;





# NextRequest and NextResponse

`next/server` provides server-only helpers for use in Middleware and Edge API
Routes.

The `NextRequest` object is an extension of the native `Request` interface,
with the following added methods and properties:

  * `cookies` \- A RequestCookies instance with cookies from the `Request`. It reads/mutates the `Cookie` header of the request. See also Using cookies in Middleware.

    * `get` \- A method that takes a cookie `name` and returns an object with `name` and `value`. If a cookie with `name` isn't found, it returns `undefined`. If multiple cookies match, it will only return the first match.
    * `getAll` \- A method that is similar to `get`, but returns a list of all the cookies with a matching `name`. If `name` is unspecified, it returns all the available cookies.
    * `set` \- A method that takes an object with properties of `CookieListItem` as defined in the W3C CookieStore API spec.
    * `delete` \- A method that takes either a cookie `name` or a list of names. and removes the cookies matching the name(s). Returns `true` for deleted and `false` for undeleted cookies.
    * `has` \- A method that takes a cookie `name` and returns a `boolean` based on if the cookie exists (`true`) or not (`false`).
    * `clear` \- A method that takes no argument and will effectively remove the `Cookie` header.
  * `nextUrl`: Includes an extended, parsed, URL object that gives you access to Next.js specific properties such as `pathname`, `basePath`, `trailingSlash` and `i18n`. Includes the following properties:

    * `basePath` (`string`)
    * `buildId` (`string || undefined`)
    * `defaultLocale` (`string || undefined`)
    * `domainLocale`
      * `defaultLocale`: (`string`)
      * `domain`: (`string`)
      * `http`: (`boolean || undefined`)
      * `locales`: (`string[] || undefined`)
    * `locale` (`string || undefined`)
    * `url` (`URL`)
  * `ip`: (`string || undefined`) - Has the IP address of the `Request`. This information is provided by your hosting platform.

  * `geo` \- Has the geographic location from the `Request`. This information is provided by your hosting platform. Includes the following properties:

    * `city` (`string || undefined`)
    * `country` (`string || undefined`)
    * `region` (`string || undefined`)
    * `latitude` (`string || undefined`)
    * `longitude` (`string || undefined`)

You can use the `NextRequest` object as a direct replacement for the native
`Request` interface, giving you more control over how you manipulate the
request.

`NextRequest` can be imported from `next/server`:

    
    
    import type { NextRequest } from 'next/server';

The `NextFetchEvent` object extends the native `FetchEvent` object, and
includes the `waitUntil()` method.

The `waitUntil()` method can be used to prolong the execution of the function
if you have other background work to make.

    
    
    import { NextResponse } from 'next/server';
    import type { NextFetchEvent, NextRequest } from 'next/server';
     
    export function middleware(req: NextRequest, event: NextFetchEvent) {
      event.waitUntil(
        fetch('https://my-analytics-platform.com', {
          method: 'POST',
          body: JSON.stringify({ pathname: req.nextUrl.pathname }),
        }),
      );
     
      return NextResponse.next();
    }

The `NextFetchEvent` object can be imported from `next/server`:

    
    
    import type { NextFetchEvent } from 'next/server';

The `NextResponse` class extends the native `Response` interface, with the
following:

Public methods are available on an instance of the `NextResponse` class.
Depending on your use case, you can create an instance and assign to a
variable, then access the following public methods:

  * `cookies` \- A ResponseCookies instance with the cookies from the `Response`. It reads/mutates the `Set-Cookie` header of the response. See also Using cookies in Middleware. 
    * `get` \- A method that takes a cookie `name` and returns an object with `name` and `value`. If a cookie with `name` isn't found, it returns `undefined`. If multiple cookies match, it will only return the first match.
    * `getAll` \- A method that is similar to `get`, but returns a list of all the cookies with a matching `name`. If `name` is unspecified, it returns all the available cookies.
    * `set` \- A method that takes an object with properties of `CookieListItem` as defined in the W3C CookieStore API spec.
    * `delete` \- A method that takes either a cookie `name` or a list of names. and removes the cookies matching the name(s). Returns `true` for deleted and `false` for undeleted cookies.

The following static methods are available on the `NextResponse` class
directly:

  * `redirect()` \- Returns a `NextResponse` with a redirect set
  * `rewrite()` \- Returns a `NextResponse` with a rewrite set
  * `next()` \- Returns a `NextResponse` that will continue the middleware chain

To use the methods above, **you must return the`NextResponse` object**
returned. `NextResponse` can be imported from `next/server`:

    
    
    import { NextResponse } from 'next/server';

The `userAgent` helper allows you to interact with the user agent object from
the request. It is abstracted from the native `Request` object, and is an opt
in feature. It has the following properties:

  * `isBot`: (`boolean`) Whether the request comes from a known bot
  * `browser`
    * `name`: (`string || undefined`) The name of the browser
    * `version`: (`string || undefined`) The version of the browser, determined dynamically
  * `device`
    * `model`: (`string || undefined`) The model of the device, determined dynamically
    * `type`: (`string || undefined`) The type of the browser, can be one of the following values: `console`, `mobile`, `tablet`, `smarttv`, `wearable`, `embedded`, or `undefined`
    * `vendor`: (`string || undefined`) The vendor of the device, determined dynamically
  * `engine`
    * `name`: (`string || undefined`) The name of the browser engine, could be one of the following values: `Amaya`, `Blink`, `EdgeHTML`, `Flow`, `Gecko`, `Goanna`, `iCab`, `KHTML`, `Links`, `Lynx`, `NetFront`, `NetSurf`, `Presto`, `Tasman`, `Trident`, `w3m`, `WebKit` or `undefined`
    * `version`: (`string || undefined`) The version of the browser engine, determined dynamically, or `undefined`
  * `os`
    * `name`: (`string || undefined`) The name of the OS, could be `undefined`
    * `version`: (`string || undefined`) The version of the OS, determined dynamically, or `undefined`
  * `cpu`
    * `architecture`: (`string || undefined`) The architecture of the CPU, could be one of the following values: `68k`, `amd64`, `arm`, `arm64`, `armhf`, `avr`, `ia32`, `ia64`, `irix`, `irix64`, `mips`, `mips64`, `pa-risc`, `ppc`, `sparc`, `sparc64` or `undefined`

`userAgent` can be imported from `next/server`:

    
    
    import { userAgent } from 'next/server';
    
    
    import { NextRequest, NextResponse, userAgent } from 'next/server';
     
    export function middleware(request: NextRequest) {
      const url = request.nextUrl;
      const { device } = userAgent(request);
      const viewport = device.type === 'mobile' ? 'mobile' : 'desktop';
      url.searchParams.set('viewport', viewport);
      return NextResponse.rewrite(url);
    }

When using `redirect()` you may notice that the status codes used are `307`
for a temporary redirect, and `308` for a permanent redirect. While
traditionally a `302` was used for a temporary redirect, and a `301` for a
permanent redirect, many browsers changed the request method of the redirect,
from a `POST` to `GET` request when using a `302`, regardless of the origins
request method.

Taking the following example of a redirect from `/users` to `/people`, if you
make a `POST` request to `/users` to create a new user, and are conforming to
a `302` temporary redirect, the request method will be changed from a `POST`
to a `GET` request. This doesn't make sense, as to create a new user, you
should be making a `POST` request to `/people`, and not a `GET` request.

The introduction of the `307` status code means that the request method is
preserved as `POST`.

  * `302` \- Temporary redirect, will change the request method from `POST` to `GET`
  * `307` \- Temporary redirect, will preserve the request method as `POST`

The `redirect()` method uses a `307` by default, instead of a `302` temporary
redirect, meaning your requests will _always_ be preserved as `POST` requests.

If you want to cause a `GET` response to a `POST` request, use `303`.

Learn more about HTTP Redirects.

`process.env` can be used to access Environment Variables from Edge
Middleware. They are evaluated during `next build`:

Works| Does **not** work  
---|---  
`console.log(process.env.MY_ENV_VARIABLE)`| `const getEnv = name =>
process.env[name]`  
`const { MY_ENV_VARIABLE } = process.env`|  
`const { "MY-ENV-VARIABLE": MY_ENV_VARIABLE } = process.env`|





# useAmp

 **Examples**

> AMP support is one of our advanced features, you can read more about AMP
> here.

To enable AMP, add the following config to your page:

    
    
    export const config = { amp: true };

The `amp` config accepts the following values:

  * `true` \- The page will be AMP-only
  * `'hybrid'` \- The page will have two versions, one with AMP and another one with HTML

To learn more about the `amp` config, read the sections below.

Take a look at the following example:

    
    
    export const config = { amp: true };
     
    function About(props) {
      return <h3>My AMP About Page!</h3>;
    }
     
    export default About;

The page above is an AMP-only page, which means:

  * The page has no Next.js or React client-side runtime
  * The page is automatically optimized with AMP Optimizer, an optimizer that applies the same transformations as AMP caches (improves performance by up to 42%)
  * The page has a user-accessible (optimized) version of the page and a search-engine indexable (unoptimized) version of the page

Take a look at the following example:

    
    
    import { useAmp } from 'next/amp';
     
    export const config = { amp: 'hybrid' };
     
    function About(props) {
      const isAmp = useAmp();
     
      return (
        <div>
          <h3>My AMP About Page!</h3>
          {isAmp ? (
            <amp-img
              width="300"
              height="300"
              src="/my-img.jpg"
              alt="a cool image"
              layout="responsive"
            />
          ) : (
            <img width="300" height="300" src="/my-img.jpg" alt="a cool image" />
          )}
        </div>
      );
    }
     
    export default About;

The page above is a hybrid AMP page, which means:

  * The page is rendered as traditional HTML (default) and AMP HTML (by adding `?amp=1` to the URL)
  * The AMP version of the page only has valid optimizations applied with AMP Optimizer so that it is indexable by search-engines

The page uses `useAmp` to differentiate between modes, it's a React Hook that
returns `true` if the page is using AMP, and `false` otherwise.





# useReportWebVitals

The `useReportWebVitals` hook allows you to report Core Web Vitals, and can be
used in combination with your analytics service.

    
    
    import { useReportWebVitals } from 'next/web-vitals';
     
    function MyApp({ Component, pageProps }) {
      useReportWebVitals((metric) => {
        console.log(metric);
      });
     
      return <Component {...pageProps} />;
    }

The `metric` object passed as the hook's argument consists of a number of
properties:

  * `id`: Unique identifier for the metric in the context of the current page load
  * `name`: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.
  * `delta`: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.
  * `entries`: An array of Performance Entries associated with the metric. These entries provide detailed information about the performance events related to the metric.
  * `navigationType`: Indicates the type of navigation that triggered the metric collection. Possible values include `"navigate"`, `"reload"`, `"back_forward"`, and `"prerender"`.
  * `rating`: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are `"good"`, `"needs-improvement"`, and `"poor"`. The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.
  * `value`: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from various Performance APIs.

Web Vitals are a set of useful metrics that aim to capture the user experience
of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the `name` property.

    
    
    import { useReportWebVitals } from 'next/web-vitals';
     
    function MyApp({ Component, pageProps }) {
      useReportWebVitals((metric) => {
        switch (metric.name) {
          case 'FCP': {
            // handle FCP results
          }
          case 'LCP': {
            // handle LCP results
          }
          // ...
        }
      });
     
      return <Component {...pageProps} />;
    }

In addition to the core metrics listed above, there are some additional custom
metrics that measure the time it takes for the page to hydrate and render:

  * `Next.js-hydration`: Length of time it takes for the page to start and finish hydrating (in ms)
  * `Next.js-route-change-to-render`: Length of time it takes for a page to start rendering after a route change (in ms)
  * `Next.js-render`: Length of time it takes for a page to finish render after a route change (in ms)

You can handle all the results of these metrics separately:

    
    
    export function reportWebVitals(metric) {
      switch (metric.name) {
        case 'Next.js-hydration':
          // handle hydration results
          break;
        case 'Next.js-route-change-to-render':
          // handle route-change to render results
          break;
        case 'Next.js-render':
          // handle render results
          break;
        default:
          break;
      }
    }

These metrics work in all browsers that support the User Timing API.

Vercel Speed Insights are automatically configured on Vercel deployments, and
don't require the use of `useReportWebVitals`. This hook is useful in local
development, or if you're using a different analytics service.

You can send results to any endpoint to measure and track real user
performance on your site. For example:

    
    
    useReportWebVitals((metric) => {
      const body = JSON.stringify(metric);
      const url = 'https://example.com/analytics';
     
      // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url, body);
      } else {
        fetch(url, { body, method: 'POST', keepalive: true });
      }
    });

> **Note** : If you use Google Analytics, using the `id` value can allow you
> to construct metric distributions manually (to calculate percentiles, etc.)

>
>     useReportWebVitals(metric => {
>       // Use `window.gtag` if you initialized Google Analytics as this
> example:
>       // https://github.com/vercel/next.js/blob/canary/examples/with-google-
> analytics/pages/_app.js
>       window.gtag('event', metric.name, {
>         value: Math.round(metric.name === 'CLS' ? metric.value * 1000 :
> metric.value), // values must be integers
>         event_label: metric.id, // id unique to current page load
>         non_interaction: true, // avoids affecting bounce rate.
>       });
>     }
>
> Read more about sending results to Google Analytics.





# useRouter

If you want to access the `router` object inside any function component in
your app, you can use the `useRouter` hook, take a look at the following
example:

    
    
    import { useRouter } from 'next/router';
     
    function ActiveLink({ children, href }) {
      const router = useRouter();
      const style = {
        marginRight: 10,
        color: router.asPath === href ? 'red' : 'black',
      };
     
      const handleClick = (e) => {
        e.preventDefault();
        router.push(href);
      };
     
      return (
        <a href={href} onClick={handleClick} style={style}>
          {children}
        </a>
      );
    }
     
    export default ActiveLink;

> `useRouter` is a React Hook, meaning it cannot be used with classes. You can
> either use withRouter or wrap your class in a function component.

The following is the definition of the `router` object returned by both
`useRouter` and `withRouter`:

  * `pathname`: `String` \- The path for current route file that comes after `/pages`. Therefore, `basePath`, `locale` and trailing slash (`trailingSlash: true`) are not included.
  * `query`: `Object` \- The query string parsed to an object, including dynamic route parameters. It will be an empty object during prerendering if the page doesn't use Server-side Rendering. Defaults to `{}`
  * `asPath`: `String` \- The path as shown in the browser including the search params and respecting the `trailingSlash` configuration. `basePath` and `locale` are not included.
  * `isFallback`: `boolean` \- Whether the current page is in fallback mode.
  * `basePath`: `String` \- The active basePath (if enabled).
  * `locale`: `String` \- The active locale (if enabled).
  * `locales`: `String[]` \- All supported locales (if enabled).
  * `defaultLocale`: `String` \- The current default locale (if enabled).
  * `domainLocales`: `Array<{domain, defaultLocale, locales}>` \- Any configured domain locales.
  * `isReady`: `boolean` \- Whether the router fields are updated client-side and ready for use. Should only be used inside of `useEffect` methods and not for conditionally rendering on the server. See related docs for use case with automatically statically optimized pages
  * `isPreview`: `boolean` \- Whether the application is currently in preview mode.

> Using the `asPath` field may lead to a mismatch between client and server if
> the page is rendered using server-side rendering or automatic static
> optimization. Avoid using `asPath` until the `isReady` field is `true`.

The following methods are included inside `router`:

**Examples**

Handles client-side transitions, this method is useful for cases where
`next/link` is not enough.

    
    
    router.push(url, as, options);

  * `url`: `UrlObject | String` \- The URL to navigate to (see Node.JS URL module documentation for `UrlObject` properties).
  * `as`: `UrlObject | String` \- Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this was used for dynamic routes.
  * `options` \- Optional object with the following configuration options: 
    * `scroll` \- Optional boolean, controls scrolling to the top of the page after navigation. Defaults to `true`
    * `shallow`: Update the path of the current page without rerunning `getStaticProps`, `getServerSideProps` or `getInitialProps`. Defaults to `false`
    * `locale` \- Optional string, indicates locale of the new page

> You don't need to use `router.push` for external URLs. window.location is
> better suited for those cases.

Navigating to `pages/about.js`, which is a predefined route:

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.push('/about')}>
          Click me
        </button>
      );
    }

Navigating `pages/post/[pid].js`, which is a dynamic route:

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.push('/post/abc')}>
          Click me
        </button>
      );
    }

Redirecting the user to `pages/login.js`, useful for pages behind
authentication:

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    // Here you would fetch and return the user
    const useUser = () => ({ user: null, loading: false });
     
    export default function Page() {
      const { user, loading } = useUser();
      const router = useRouter();
     
      useEffect(() => {
        if (!(user || loading)) {
          router.push('/login');
        }
      }, [user, loading]);
     
      return <p>Redirecting...</p>;
    }

When navigating to the same page in Next.js, the page's state **will not** be
reset by default as React does not unmount unless the parent component has
changed.

    
    
    import Link from 'next/link';
    import { useState } from 'react';
    import { useRouter } from 'next/router';
     
    export default function Page(props) {
      const router = useRouter();
      const [count, setCount] = useState(0);
      return (
        <div>
          <h1>Page: {router.query.slug}</h1>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>Increase count</button>
          <Link href="/one">one</Link> <Link href="/two">two</Link>
        </div>
      );
    }

In the above example, navigating between `/one` and `/two` **will not** reset
the count . The `useState` is maintained between renders because the top-level
React component, `Page`, is the same.

If you do not want this behavior, you have a couple of options:

  * Manually ensure each state is updated using `useEffect`. In the above example, that could look like:
    
        useEffect(() => {
      setCount(0);
    }, [router.query.slug]);

  * Use a React `key` to tell React to remount the component. To do this for all pages, you can use a custom app:
    
        import { useRouter } from 'next/router';
     
    export default function MyApp({ Component, pageProps }) {
      const router = useRouter();
      return <Component key={router.asPath} {...pageProps} />;
    }

You can use a URL object in the same way you can use it for `next/link`. Works
for both the `url` and `as` parameters:

    
    
    import { useRouter } from 'next/router';
     
    export default function ReadMore({ post }) {
      const router = useRouter();
     
      return (
        <button
          type="button"
          onClick={() => {
            router.push({
              pathname: '/post/[pid]',
              query: { pid: post.id },
            });
          }}
        >
          Click here to read more
        </button>
      );
    }

Similar to the `replace` prop in `next/link`, `router.replace` will prevent
adding a new URL entry into the `history` stack.

    
    
    router.replace(url, as, options);

  * The API for `router.replace` is exactly the same as the API for `router.push`.

Take a look at the following example:

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.replace('/home')}>
          Click me
        </button>
      );
    }

Prefetch pages for faster client-side transitions. This method is only useful
for navigations without `next/link`, as `next/link` takes care of prefetching
pages automatically.

> This is a production only feature. Next.js doesn't prefetch pages in
> development.
    
    
    router.prefetch(url, as, options);

  * `url` \- The URL to prefetch, including explicit routes (e.g. `/dashboard`) and dynamic routes (e.g. `/product/[id]`)
  * `as` \- Optional decorator for `url`. Before Next.js 9.5.3 this was used to prefetch dynamic routes.
  * `options` \- Optional object with the following allowed fields: 
    * `locale` \- allows providing a different locale from the active one. If `false`, `url` has to include the locale as the active locale won't be used.

Let's say you have a login page, and after a login, you redirect the user to
the dashboard. For that case, we can prefetch the dashboard to make a faster
transition, like in the following example:

    
    
    import { useCallback, useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    export default function Login() {
      const router = useRouter();
      const handleSubmit = useCallback((e) => {
        e.preventDefault();
     
        fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            /* Form data */
          }),
        }).then((res) => {
          // Do a fast client-side transition to the already prefetched dashboard page
          if (res.ok) router.push('/dashboard');
        });
      }, []);
     
      useEffect(() => {
        // Prefetch the dashboard page
        router.prefetch('/dashboard');
      }, [router]);
     
      return (
        <form onSubmit={handleSubmit}>
          {/* Form fields */}
          <button type="submit">Login</button>
        </form>
      );
    }

In some cases (for example, if using a Custom Server), you may wish to listen
to popstate and do something before the router acts on it.

    
    
    router.beforePopState(cb);

  * `cb` \- The function to run on incoming `popstate` events. The function receives the state of the event as an object with the following props: 
    * `url`: `String` \- the route for the new state. This is usually the name of a `page`
    * `as`: `String` \- the url that will be shown in the browser
    * `options`: `Object` \- Additional options sent by router.push

If `cb` returns `false`, the Next.js router will not handle `popstate`, and
you'll be responsible for handling it in that case. See Disabling file-system
routing.

You could use `beforePopState` to manipulate the request, or force a SSR
refresh, as in the following example:

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      useEffect(() => {
        router.beforePopState(({ url, as, options }) => {
          // I only want to allow these two routes!
          if (as !== '/' && as !== '/other') {
            // Have SSR render bad routes as a 404.
            window.location.href = as;
            return false;
          }
     
          return true;
        });
      }, [router]);
     
      return <p>Welcome to the page</p>;
    }

Navigate back in history. Equivalent to clicking the browser’s back button. It
executes `window.history.back()`.

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.back()}>
          Click here to go back
        </button>
      );
    }

Reload the current URL. Equivalent to clicking the browser’s refresh button.
It executes `window.location.reload()`.

    
    
    import { useRouter } from 'next/router';
     
    export default function Page() {
      const router = useRouter();
     
      return (
        <button type="button" onClick={() => router.reload()}>
          Click here to reload
        </button>
      );
    }

**Examples**

You can listen to different events happening inside the Next.js Router. Here's
a list of supported events:

  * `routeChangeStart(url, { shallow })` \- Fires when a route starts to change
  * `routeChangeComplete(url, { shallow })` \- Fires when a route changed completely
  * `routeChangeError(err, url, { shallow })` \- Fires when there's an error when changing routes, or a route load is cancelled 
    * `err.cancelled` \- Indicates if the navigation was cancelled
  * `beforeHistoryChange(url, { shallow })` \- Fires before changing the browser's history
  * `hashChangeStart(url, { shallow })` \- Fires when the hash will change but not the page
  * `hashChangeComplete(url, { shallow })` \- Fires when the hash has changed but not the page

> **Note** : Here `url` is the URL shown in the browser, including the
> `basePath`.

For example, to listen to the router event `routeChangeStart`, open or create
`pages/_app.js` and subscribe to the event, like so:

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    export default function MyApp({ Component, pageProps }) {
      const router = useRouter();
     
      useEffect(() => {
        const handleRouteChange = (url, { shallow }) => {
          console.log(
            `App is changing to ${url} ${
              shallow ? 'with' : 'without'
            } shallow routing`,
          );
        };
     
        router.events.on('routeChangeStart', handleRouteChange);
     
        // If the component is unmounted, unsubscribe
        // from the event with the `off` method:
        return () => {
          router.events.off('routeChangeStart', handleRouteChange);
        };
      }, [router]);
     
      return <Component {...pageProps} />;
    }

> We use a Custom App (`pages/_app.js`) for this example to subscribe to the
> event because it's not unmounted on page navigations, but you can subscribe
> to router events on any component in your application.

Router events should be registered when a component mounts (useEffect or
componentDidMount / componentWillUnmount) or imperatively when an event
happens.

If a route load is cancelled (for example, by clicking two links rapidly in
succession), `routeChangeError` will fire. And the passed `err` will contain a
`cancelled` property set to `true`, as in the following example:

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    export default function MyApp({ Component, pageProps }) {
      const router = useRouter();
     
      useEffect(() => {
        const handleRouteChangeError = (err, url) => {
          if (err.cancelled) {
            console.log(`Route to ${url} was cancelled!`);
          }
        };
     
        router.events.on('routeChangeError', handleRouteChangeError);
     
        // If the component is unmounted, unsubscribe
        // from the event with the `off` method:
        return () => {
          router.events.off('routeChangeError', handleRouteChangeError);
        };
      }, [router]);
     
      return <Component {...pageProps} />;
    }

Certain methods accessible on the `router` object return a Promise. If you
have the ESLint rule, no-floating-promises enabled, consider disabling it
either globally, or for the affected line.

If your application needs this rule, you should either `void` the promise – or
use an `async` function, `await` the Promise, then void the function call.
**This is not applicable when the method is called from inside an`onClick`
handler**.

The affected methods are:

  * `router.push`
  * `router.replace`
  * `router.prefetch`

    
    
    import { useEffect } from 'react';
    import { useRouter } from 'next/router';
     
    // Here you would fetch and return the user
    const useUser = () => ({ user: null, loading: false });
     
    export default function Page() {
      const { user, loading } = useUser();
      const router = useRouter();
     
      useEffect(() => {
        // disable the linting on the next line - This is the cleanest solution
        // eslint-disable-next-line no-floating-promises
        router.push('/login');
     
        // void the Promise returned by router.push
        if (!(user || loading)) {
          void router.push('/login');
        }
        // or use an async function, await the Promise, then void the function call
        async function handleRouteChange() {
          if (!(user || loading)) {
            await router.push('/login');
          }
        }
        void handleRouteChange();
      }, [user, loading]);
     
      return <p>Redirecting...</p>;
    }

If `useRouter` is not the best fit for you, `withRouter` can also add the same
`router` object to any component.

    
    
    import { withRouter } from 'next/router';
     
    function Page({ router }) {
      return <p>{router.pathname}</p>;
    }
     
    export default withRouter(Page);

To use class components with `withRouter`, the component needs to accept a
router prop:

    
    
    import React from 'react';
    import { withRouter, NextRouter } from 'next/router';
     
    interface WithRouterProps {
      router: NextRouter;
    }
     
    interface MyComponentProps extends WithRouterProps {}
     
    class MyComponent extends React.Component<MyComponentProps> {
      render() {
        return <p>{this.props.router.pathname}</p>;
      }
    }
     
    export default withRouter(MyComponent);





Using Pages Router

Features available in /pages





# assetPrefix

> **Attention** : Deploying to Vercel automatically configures a global CDN
> for your Next.js project. You do not need to manually setup an Asset Prefix.

> **Note** : Next.js 9.5+ added support for a customizable Base Path, which is
> better suited for hosting your application on a sub-path like `/docs`. We do
> not suggest you use a custom Asset Prefix for this use case.

To set up a CDN, you can set up an asset prefix and configure your CDN's
origin to resolve to the domain that Next.js is hosted on.

Open `next.config.js` and add the `assetPrefix` config:

    
    
    const isProd = process.env.NODE_ENV === 'production';
     
    module.exports = {
      // Use the CDN in production and localhost for development.
      assetPrefix: isProd ? 'https://cdn.mydomain.com' : undefined,
    };

Next.js will automatically use your asset prefix for the JavaScript and CSS
files it loads from the `/_next/` path (`.next/static/` folder). For example,
with the above configuration, the following request for a JS chunk:

    
    
    /_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
    

Would instead become:

    
    
    https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
    

The exact configuration for uploading your files to a given CDN will depend on
your CDN of choice. The only folder you need to host on your CDN is the
contents of `.next/static/`, which should be uploaded as `_next/static/` as
the above URL request indicates. **Do not upload the rest of your`.next/`
folder**, as you should not expose your server code and other configuration to
the public.

While `assetPrefix` covers requests to `_next/static`, it does not influence
the following paths:

  * Files in the public folder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself
  * `/_next/data/` requests for `getServerSideProps` pages. These requests will always be made against the main domain since they're not static.
  * `/_next/data/` requests for `getStaticProps` pages. These requests will always be made against the main domain to support Incremental Static Generation, even if you're not using it (for consistency).





# basePath

To deploy a Next.js application under a sub-path of a domain you can use the
`basePath` config option.

`basePath` allows you to set a path prefix for the application. For example,
to use `/docs` instead of `''` (an empty string, the default), open
`next.config.js` and add the `basePath` config:

    
    
    module.exports = {
      basePath: '/docs',
    };

> **Note** : This value must be set at build time and cannot be changed
> without re-building as the value is inlined in the client-side bundles.

When linking to other pages using `next/link` and `next/router` the `basePath`
will be automatically applied.

For example, using `/about` will automatically become `/docs/about` when
`basePath` is set to `/docs`.

    
    
    export default function HomePage() {
      return (
        <>
          <Link href="/about">About Page</Link>
        </>
      );
    }

Output html:

    
    
    <a href="/docs/about">About Page</a>

This makes sure that you don't have to change all links in your application
when changing the `basePath` value.

When using the `next/image` component, you will need to add the `basePath` in
front of `src`.

For example, using `/docs/me.png` will properly serve your image when
`basePath` is set to `/docs`.

    
    
    import Image from 'next/image';
     
    function Home() {
      return (
        <>
          <h1>My Homepage</h1>
          <Image
            src="/docs/me.png"
            alt="Picture of the author"
            width={500}
            height={500}
          />
          <p>Welcome to my homepage!</p>
        </>
      );
    }
     
    export default Home;





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





# exportPathMap

> This feature is exclusive to `next export` and currently **deprecated** in
> favor of `getStaticPaths` with `pages` or `generateStaticParams` with `app`.

**Examples**

`exportPathMap` allows you to specify a mapping of request paths to page
destinations, to be used during export. Paths defined in `exportPathMap` will
also be available when using `next dev`.

Let's start with an example, to create a custom `exportPathMap` for an app
with the following pages:

  * `pages/index.js`
  * `pages/about.js`
  * `pages/post.js`

Open `next.config.js` and add the following `exportPathMap` config:

    
    
    module.exports = {
      exportPathMap: async function (
        defaultPathMap,
        { dev, dir, outDir, distDir, buildId },
      ) {
        return {
          '/': { page: '/' },
          '/about': { page: '/about' },
          '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },
          '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },
          '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },
        };
      },
    };

> **Note** : the `query` field in `exportPathMap` cannot be used with
> automatically statically optimized pages or `getStaticProps` pages as they
> are rendered to HTML files at build-time and additional query information
> cannot be provided during `next export`.

The pages will then be exported as HTML files, for example, `/about` will
become `/about.html`.

`exportPathMap` is an `async` function that receives 2 arguments: the first
one is `defaultPathMap`, which is the default map used by Next.js. The second
argument is an object with:

  * `dev` \- `true` when `exportPathMap` is being called in development. `false` when running `next export`. In development `exportPathMap` is used to define routes.
  * `dir` \- Absolute path to the project directory
  * `outDir` \- Absolute path to the `out/` directory (configurable with `-o`). When `dev` is `true` the value of `outDir` will be `null`.
  * `distDir` \- Absolute path to the `.next/` directory (configurable with the `distDir` config)
  * `buildId` \- The generated build id

The returned object is a map of pages where the `key` is the `pathname` and
the `value` is an object that accepts the following fields:

  * `page`: `String` \- the page inside the `pages` directory to render
  * `query`: `Object` \- the `query` object passed to `getInitialProps` when prerendering. Defaults to `{}`

> The exported `pathname` can also be a filename (for example, `/readme.md`),
> but you may need to set the `Content-Type` header to `text/html` when
> serving its content if it is different than `.html`.

It is possible to configure Next.js to export pages as `index.html` files and
require trailing slashes, `/about` becomes `/about/index.html` and is routable
via `/about/`. This was the default behavior prior to Next.js 9.

To switch back and add a trailing slash, open `next.config.js` and enable the
`trailingSlash` config:

    
    
    module.exports = {
      trailingSlash: true,
    };

`next export` will use `out` as the default output directory, you can
customize this using the `-o` argument, like so:

> **Warning** : Using `exportPathMap` is deprecated and is overridden by
> `getStaticPaths` inside `pages`. We don't recommend using them together.





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





# headers

Headers allow you to set custom HTTP headers on the response to an incoming
request on a given path.

To set custom HTTP headers you can use the `headers` key in `next.config.js`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/about',
            headers: [
              {
                key: 'x-custom-header',
                value: 'my custom header value',
              },
              {
                key: 'x-another-custom-header',
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

`headers` is an async function that expects an array to be returned holding
objects with `source` and `headers` properties:

  * `source` is the incoming request path pattern.
  * `headers` is an array of response header objects, with `key` and `value` properties.
  * `basePath`: `false` or `undefined` \- if false the basePath won't be included when matching, can be used for external rewrites only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

Headers are checked before the filesystem which includes pages and `/public`
files.

If two headers match the same path and set the same header key, the last
header key will override the first. Using the below headers, the path `/hello`
will result in the header `x-hello` being `world` due to the last header value
set being `world`.

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/:path*',
            headers: [
              {
                key: 'x-hello',
                value: 'there',
              },
            ],
          },
          {
            source: '/hello',
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
        ];
      },
    };

Path matches are allowed, for example `/blog/:slug` will match `/blog/hello-
world` (no nested paths):

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:slug',
            headers: [
              {
                key: 'x-slug',
                value: ':slug', // Matched parameters can be used in the value
              },
              {
                key: 'x-slug-:slug', // Matched parameters can be used in the key
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:slug*',
            headers: [
              {
                key: 'x-slug',
                value: ':slug*', // Matched parameters can be used in the value
              },
              {
                key: 'x-slug-:slug*', // Matched parameters can be used in the key
                value: 'my other custom header value',
              },
            ],
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parenthesis after a parameter,
for example `/blog/:slug(\\d{1,})` will match `/blog/123` but not `/blog/abc`:

    
    
    module.exports = {
      async headers() {
        return [
          {
            source: '/blog/:post(\\d{1,})',
            headers: [
              {
                key: 'x-post',
                value: ':post',
              },
            ],
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async headers() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            headers: [
              {
                key: 'x-header',
                value: 'value',
              },
            ],
          },
        ];
      },
    };

To only apply a header when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
header to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async headers() {
        return [
          // if the header `x-add-header` is present,
          // the `x-another-header` header will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-add-header',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: 'hello',
              },
            ],
          },
          // if the header `x-no-header` is not present,
          // the `x-another-header` header will be applied
          {
            source: '/:path*',
            missing: [
              {
                type: 'header',
                key: 'x-no-header',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: 'hello',
              },
            ],
          },
          // if the source, query, and cookie are matched,
          // the `x-authorized` header will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // header key/values since value is provided and
                // doesn't use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            headers: [
              {
                key: 'x-authorized',
                value: ':authorized',
              },
            ],
          },
          // if the header `x-authorized` is present and
          // contains a matching value, the `x-another-header` will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: ':authorized',
              },
            ],
          },
          // if the host is `example.com`,
          // this header will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            headers: [
              {
                key: 'x-another-header',
                value: ':authorized',
              },
            ],
          },
        ];
      },
    };

When leveraging `basePath` support with headers each `source` is automatically
prefixed with the `basePath` unless you add `basePath: false` to the header:

    
    
    module.exports = {
      basePath: '/docs',
     
      async headers() {
        return [
          {
            source: '/with-basePath', // becomes /docs/with-basePath
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            source: '/without-basePath', // is not modified since basePath: false is set
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
            basePath: false,
          },
        ];
      },
    };

When leveraging `i18n` support with headers each `source` is automatically
prefixed to handle the configured `locales` unless you add `locale: false` to
the header. If `locale: false` is used you must prefix the `source` with a
locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async headers() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            locale: false,
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            locale: false,
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            headers: [
              {
                key: 'x-hello',
                value: 'world',
              },
            ],
          },
        ];
      },
    };

You can set the `Cache-Control` header in your Next.js API Routes by using the
`res.setHeader` method:

    
    
    export default function handler(req, res) {
      res.setHeader('Cache-Control', 's-maxage=86400');
      res.status(200).json({ name: 'John Doe' });
    }

You cannot set `Cache-Control` headers in `next.config.js` file as these will
be overwritten in production to ensure that API Routes and static assets are
cached effectively.

If you need to revalidate the cache of a page that has been statically
generated, you can do so by setting the `revalidate` prop in the page's
`getStaticProps` function.

This header controls DNS prefetching, allowing browsers to proactively perform
domain name resolution on external links, images, CSS, JavaScript, and more.
This prefetching is performed in the background, so the DNS is more likely to
be resolved by the time the referenced items are needed. This reduces latency
when the user clicks a link.

    
    
    {
      key: 'X-DNS-Prefetch-Control',
      value: 'on'
    }

This header informs browsers it should only be accessed using HTTPS, instead
of using HTTP. Using the configuration below, all present and future
subdomains will use HTTPS for a `max-age` of 2 years. This blocks access to
pages or subdomains that can only be served over HTTP.

If you're deploying to Vercel, this header is not necessary as it's
automatically added to all deployments unless you declare `headers` in your
`next.config.js`.

    
    
    {
      key: 'Strict-Transport-Security',
      value: 'max-age=63072000; includeSubDomains; preload'
    }

This header stops pages from loading when they detect reflected cross-site
scripting (XSS) attacks. Although this protection is not necessary when sites
implement a strong `Content-Security-Policy` disabling the use of inline
JavaScript (`'unsafe-inline'`), it can still provide protection for older web
browsers that don't support CSP.

    
    
    {
      key: 'X-XSS-Protection',
      value: '1; mode=block'
    }

This header indicates whether the site should be allowed to be displayed
within an `iframe`. This can prevent against clickjacking attacks. This header
has been superseded by CSP's `frame-ancestors` option, which has better
support in modern browsers.

    
    
    {
      key: 'X-Frame-Options',
      value: 'SAMEORIGIN'
    }

This header allows you to control which features and APIs can be used in the
browser. It was previously named `Feature-Policy`. You can view the full list
of permission options here.

    
    
    {
      key: 'Permissions-Policy',
      value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'
    }

This header prevents the browser from attempting to guess the type of content
if the `Content-Type` header is not explicitly set. This can prevent XSS
exploits for websites that allow users to upload and share files. For example,
a user trying to download an image, but having it treated as a different
`Content-Type` like an executable, which could be malicious. This header also
applies to downloading browser extensions. The only valid value for this
header is `nosniff`.

    
    
    {
      key: 'X-Content-Type-Options',
      value: 'nosniff'
    }

This header controls how much information the browser includes when navigating
from the current website (origin) to another. You can read about the different
options here.

    
    
    {
      key: 'Referrer-Policy',
      value: 'origin-when-cross-origin'
    }

This header helps prevent cross-site scripting (XSS), clickjacking and other
code injection attacks. Content Security Policy (CSP) can specify allowed
origins for content including scripts, stylesheets, images, fonts, objects,
media (audio, video), iframes, and more.

You can read about the many different CSP options here.

You can add Content Security Policy directives using a template string.

    
    
    // Before defining your Security Headers
    // add Content Security Policy directives using a template string.
     
    const ContentSecurityPolicy = `
      default-src 'self';
      script-src 'self';
      child-src example.com;
      style-src 'self' example.com;
      font-src 'self';
    `;

When a directive uses a keyword such as `self`, wrap it in single quotes `''`.

In the header's value, replace the new line with a space.

    
    
    {
      key: 'Content-Security-Policy',
      value: ContentSecurityPolicy.replace(/\s{2,}/g, ' ').trim()
    }

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| Headers added.





Using Pages Router

Features available in /pages





# images

If you want to use a cloud provider to optimize images instead of using the
Next.js built-in Image Optimization API, you can configure `next.config.js`
with the following:

    
    
    module.exports = {
      images: {
        loader: 'custom',
        loaderFile: './my/image/loader.js',
      },
    };

This `loaderFile` must point to a file relative to the root of your Next.js
application. The file must export a default function that returns a string,
for example:

    
    
    export default function myImageLoader({ src, width, quality }) {
      return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
    }

Alternatively, you can use the `loader` prop to pass the function to each
instance of `next/image`.

    
    
    // Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand
    export default function akamaiLoader({ src, width, quality }) {
      return `https://example.com/${src}?imwidth=${width}`;
    }
    
    
    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg
    export default function cloudinaryLoader({ src, width, quality }) {
      const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
      return `https://example.com/${params.join(',')}${src}`;
    }
    
    
    // Docs: https://developers.cloudflare.com/images/url-format
    export default function cloudflareLoader({ src, width, quality }) {
      const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto'];
      return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`;
    }
    
    
    // Docs: https://www.contentful.com/developers/docs/references/images-api/
    export default function contentfulLoader({ src, quality, width }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('fm', 'webp');
      url.searchParams.set('w', width.toString());
      url.searchParams.set('q', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://developer.fastly.com/reference/io/
    export default function fastlyLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('auto', 'webp');
      url.searchParams.set('width', width.toString());
      url.searchParams.set('quality', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://docs.gumlet.com/reference/image-transform-size
    export default function gumletLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      url.searchParams.set('format', 'auto');
      url.searchParams.set('w', width.toString());
      url.searchParams.set('q', quality.toString() || '75');
      return url.href;
    }
    
    
    // Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives
    export default function imageengineLoader({ src, width, quality }) {
      const compression = 100 - (quality || 50)
      const params = [`w_${width}`, `cmpr_${compression}`)]
      return `https://example.com${src}?imgeng=/${params.join('/')`
    }
    
    
    // Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300
    export default function imgixLoader({ src, width, quality }) {
      const url = new URL(`https://example.com${src}`);
      const params = url.searchParams;
      params.set('auto', params.getAll('auto').join(',') || 'format');
      params.set('fit', params.get('fit') || 'max');
      params.set('w', params.get('w') || width.toString());
      params.set('q', quality.toString() || '50');
      return url.href;
    }
    
    
    // Docs: https://thumbor.readthedocs.io/en/latest/
    export default function thumborLoader({ src, width, quality }) {
      const params = [`${width}x0`, `filters:quality(${quality || 75})`];
      return `https://example.com${params.join('/')}${src}`;
    }





Using Pages Router

Features available in /pages





# output

During a build, Next.js will automatically trace each page and its
dependencies to determine all of the files that are needed for deploying a
production version of your application.

This feature helps reduce the size of deployments drastically. Previously,
when deploying with Docker you would need to have all files from your
package's `dependencies` installed to run `next start`. Starting with Next.js
12, you can leverage Output File Tracing in the `.next/` directory to only
include the necessary files.

Furthermore, this removes the need for the deprecated `serverless` target
which can cause various issues and also creates unnecessary duplication.

During `next build`, Next.js will use `@vercel/nft` to statically analyze
`import`, `require`, and `fs` usage to determine all files that a page might
load.

Next.js' production server is also traced for its needed files and output at
`.next/next-server.js.nft.json` which can be leveraged in production.

To leverage the `.nft.json` files emitted to the `.next` output directory, you
can read the list of files in each trace that are relative to the `.nft.json`
file and then copy them to your deployment location.

Next.js can automatically create a `standalone` folder that copies only the
necessary files for a production deployment including select files in
`node_modules`.

To leverage this automatic copying you can enable it in your `next.config.js`:

    
    
    module.exports = {
      output: 'standalone',
    };

This will create a folder at `.next/standalone` which can then be deployed on
its own without installing `node_modules`.

Additionally, a minimal `server.js` file is also output which can be used
instead of `next start`. This minimal server does not copy the `public` or
`.next/static` folders by default as these should ideally be handled by a CDN
instead, although these folders can be copied to the `standalone/public` and
`standalone/.next/static` folders manually, after which `server.js` file will
serve these automatically.

> **Note** : `next.config.js` is read during `next build` and serialized into
> the `server.js` output file. If the legacy `serverRuntimeConfig` or
> `publicRuntimeConfig` options are being used, the values will be specific to
> values at build time.

> **Note** : If your project uses Image Optimization with the default
> `loader`, you must install `sharp` as a dependency:

  * While tracing in monorepo setups, the project directory is used for tracing by default. For `next build packages/web-app`, `packages/web-app` would be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can set `experimental.outputFileTracingRoot` in your `next.config.js`.

    
    
    module.exports = {
      experimental: {
        // this includes files from the monorepo base two directories up
        outputFileTracingRoot: path.join(__dirname, '../../'),
      },
    };

  * There are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverage `experimental.outputFileTracingExcludes` and `experimental.outputFileTracingIncludes` respectively in `next.config.js`. Each config accepts an object with minimatch globs for the key to match specific pages and a value of an array with globs relative to the project's root to either include or exclude in the trace.

    
    
    module.exports = {
      experimental: {
        outputFileTracingExcludes: {
          '/api/hello': ['./un-necessary-folder/**/*'],
        },
        outputFileTracingIncludes: {
          '/api/another': ['./necessary-folder/**/*'],
        },
      },
    };

  * Currently, Next.js does not do anything with the emitted `.nft.json` files. The files must be read by your deployment platform, for example Vercel, to create a minimal deployment. In a future release, a new command is planned to utilize these `.nft.json` files.

Tracing dependencies can be slow because it requires very complex computations
and analysis. We created `turbotrace` in Rust as a faster and smarter
alternative to the JavaScript implementation.

To enable it, you can add the following configuration to your
`next.config.js`:

    
    
    module.exports = {
      experimental: {
        turbotrace: {
          // control the log level of the turbotrace, default is `error`
          logLevel?:
          | 'bug'
          | 'fatal'
          | 'error'
          | 'warning'
          | 'hint'
          | 'note'
          | 'suggestions'
          | 'info',
          // control if the log of turbotrace should contain the details of the analysis, default is `false`
          logDetail?: boolean
          // show all log messages without limit
          // turbotrace only show 1 log message for each categories by default
          logAll?: boolean
          // control the context directory of the turbotrace
          // files outside of the context directory will not be traced
          // set the `experimental.outputFileTracingRoot` has the same effect
          // if the `experimental.outputFileTracingRoot` and this option are both set, the `experimental.turbotrace.contextDirectory` will be used
          contextDirectory?: string
          // if there is `process.cwd()` expression in your code, you can set this option to tell `turbotrace` the value of `process.cwd()` while tracing.
          // for example the require(process.cwd() + '/package.json') will be traced as require('/path/to/cwd/package.json')
          processCwd?: string
          // control the maximum memory usage of the `turbotrace`, in `MB`, default is `6000`.
          memoryLimit?: number
        },
      },
    }





# pageExtensions

You can extend the default Page extensions (`.tsx`, `.ts`, `.jsx`, `.js`) used
by Next.js. Inside `next.config.js`, add the `pageExtensions` config:

    
    
    module.exports = {
      pageExtensions: ['mdx', 'md', 'jsx', 'js', 'tsx', 'ts'],
    };

Changing these values affects _all_ Next.js pages, including the following:

  * `middleware.js`
  * `pages/_document.js`
  * `pages/_app.js`
  * `pages/api/`

For example, if you reconfigure `.ts` page extensions to `.page.ts`, you would
need to rename pages like `_app.page.ts`.

You can colocate test files or other files used by components in the `pages`
directory. Inside `next.config.js`, add the `pageExtensions` config:

    
    
    module.exports = {
      pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],
    };

Then, rename your pages to have a file extension that includes `.page` (e.g.
rename `MyPage.tsx` to `MyPage.page.tsx`). Ensure you rename _all_ Next.js
pages, including the files mentioned above.





Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages



  
  
Using Pages Router

Features available in /pages





# redirects

Redirects allow you to redirect an incoming request path to a different
destination path.

To use redirects you can use the `redirects` key in `next.config.js`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/about',
            destination: '/',
            permanent: true,
          },
        ];
      },
    };

`redirects` is an async function that expects an array to be returned holding
objects with `source`, `destination`, and `permanent` properties:

  * `source` is the incoming request path pattern.
  * `destination` is the path you want to route to.
  * `permanent` `true` or `false` \- if `true` will use the 308 status code which instructs clients/search engines to cache the redirect forever, if `false` will use the 307 status code which is temporary and is not cached.

> **Why does Next.js use 307 and 308?** Traditionally a 302 was used for a
> temporary redirect, and a 301 for a permanent redirect, but many browsers
> changed the request method of the redirect to `GET`, regardless of the
> original method. For example, if the browser made a request to `POST
> /v1/users` which returned status code `302` with location `/v2/users`, the
> subsequent request might be `GET /v2/users` instead of the expected `POST
> /v2/users`. Next.js uses the 307 temporary redirect, and 308 permanent
> redirect status codes to explicitly preserve the request method used.

  * `basePath`: `false` or `undefined` \- if false the `basePath` won't be included when matching, can be used for external redirects only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

Redirects are checked before the filesystem which includes pages and `/public`
files.

Redirects are not applied to client-side routing (`Link`, `router.push`),
unless Middleware is present and matches the path.

When a redirect is applied, any query values provided in the request will be
passed through to the redirect destination. For example, see the following
redirect configuration:

    
    
    {
      source: '/old-blog/:path*',
      destination: '/blog/:path*',
      permanent: false
    }

When `/old-blog/post-1?hello=world` is requested, the client will be
redirected to `/blog/post-1?hello=world`.

Path matches are allowed, for example `/old-blog/:slug` will match `/old-
blog/hello-world` (no nested paths):

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/old-blog/:slug',
            destination: '/news/:slug', // Matched parameters can be used in the destination
            permanent: true,
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/blog/:slug*',
            destination: '/news/:slug*', // Matched parameters can be used in the destination
            permanent: true,
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parentheses after a parameter,
for example `/post/:slug(\\d{1,})` will match `/post/123` but not `/post/abc`:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            source: '/post/:slug(\\d{1,})',
            destination: '/news/:slug', // Matched parameters can be used in the destination
            permanent: false,
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async redirects() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            destination: '/en-us/:slug',
            permanent: false,
          },
        ];
      },
    };

To only match a redirect when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
redirect to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async redirects() {
        return [
          // if the header `x-redirect-me` is present,
          // this redirect will be applied
          {
            source: '/:path((?!another-page$).*)',
            has: [
              {
                type: 'header',
                key: 'x-redirect-me',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
          // if the header `x-dont-redirect` is present,
          // this redirect will NOT be applied
          {
            source: '/:path((?!another-page$).*)',
            missing: [
              {
                type: 'header',
                key: 'x-do-not-redirect',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
          // if the source, query, and cookie are matched,
          // this redirect will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // destination since value is provided and doesn't
                // use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            permanent: false,
            destination: '/another/:path*',
          },
          // if the header `x-authorized` is present and
          // contains a matching value, this redirect will be applied
          {
            source: '/',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            permanent: false,
            destination: '/home?authorized=:authorized',
          },
          // if the host is `example.com`,
          // this redirect will be applied
          {
            source: '/:path((?!another-page$).*)',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            permanent: false,
            destination: '/another-page',
          },
        ];
      },
    };

When leveraging `basePath` support with redirects each `source` and
`destination` is automatically prefixed with the `basePath` unless you add
`basePath: false` to the redirect:

    
    
    module.exports = {
      basePath: '/docs',
     
      async redirects() {
        return [
          {
            source: '/with-basePath', // automatically becomes /docs/with-basePath
            destination: '/another', // automatically becomes /docs/another
            permanent: false,
          },
          {
            // does not add /docs since basePath: false is set
            source: '/without-basePath',
            destination: 'https://example.com',
            basePath: false,
            permanent: false,
          },
        ];
      },
    };

When leveraging `i18n` support with redirects each `source` and `destination`
is automatically prefixed to handle the configured `locales` unless you add
`locale: false` to the redirect. If `locale: false` is used you must prefix
the `source` and `destination` with a locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async redirects() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            destination: '/another', // automatically passes the locale on
            permanent: false,
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            destination: '/nl/another',
            locale: false,
            permanent: false,
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            destination: '/en/another',
            locale: false,
            permanent: false,
          },
          // it's possible to match all locales even when locale: false is set
          {
            source: '/:locale/page',
            destination: '/en/newpage',
            permanent: false,
            locale: false,
          }
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            destination: '/another',
            permanent: false,
          },
        ]
      },
    }

In some rare cases, you might need to assign a custom status code for older
HTTP Clients to properly redirect. In these cases, you can use the
`statusCode` property instead of the `permanent` property, but not both. To to
ensure IE11 compatibility, a `Refresh` header is automatically added for the
308 status code.

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| `redirects` added.





# rewrites

Rewrites allow you to map an incoming request path to a different destination
path.

Rewrites act as a URL proxy and mask the destination path, making it appear
the user hasn't changed their location on the site. In contrast, redirects
will reroute to a new page and show the URL changes.

To use rewrites you can use the `rewrites` key in `next.config.js`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/about',
            destination: '/',
          },
        ];
      },
    };

Rewrites are applied to client-side routing, a `<Link href="/about">` will
have the rewrite applied in the above example.

`rewrites` is an async function that expects to return either an array or an
object of arrays (see below) holding objects with `source` and `destination`
properties:

  * `source`: `String` \- is the incoming request path pattern.
  * `destination`: `String` is the path you want to route to.
  * `basePath`: `false` or `undefined` \- if false the basePath won't be included when matching, can be used for external rewrites only.
  * `locale`: `false` or `undefined` \- whether the locale should not be included when matching.
  * `has` is an array of has objects with the `type`, `key` and `value` properties.
  * `missing` is an array of missing objects with the `type`, `key` and `value` properties.

When the `rewrites` function returns an array, rewrites are applied after
checking the filesystem (pages and `/public` files) and before dynamic routes.
When the `rewrites` function returns an object of arrays with a specific
shape, this behavior can be changed and more finely controlled, as of `v10.1`
of Next.js:

    
    
    module.exports = {
      async rewrites() {
        return {
          beforeFiles: [
            // These rewrites are checked after headers/redirects
            // and before all files including _next/public files which
            // allows overriding page files
            {
              source: '/some-page',
              destination: '/somewhere-else',
              has: [{ type: 'query', key: 'overrideMe' }],
            },
          ],
          afterFiles: [
            // These rewrites are checked after pages/public files
            // are checked but before dynamic routes
            {
              source: '/non-existent',
              destination: '/somewhere-else',
            },
          ],
          fallback: [
            // These rewrites are checked after both pages/public files
            // and dynamic routes are checked
            {
              source: '/:path*',
              destination: `https://my-old-site.com/:path*`,
            },
          ],
        };
      },
    };

> **Note** : rewrites in `beforeFiles` do not check the filesystem/dynamic
> routes immediately after matching a source, they continue until all
> `beforeFiles` have been checked.

The order Next.js routes are checked is:

  1. headers are checked/applied
  2. redirects are checked/applied
  3. `beforeFiles` rewrites are checked/applied
  4. static files from the public directory, `_next/static` files, and non-dynamic pages are checked/served
  5. `afterFiles` rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match
  6. `fallback` rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in `getStaticPaths`, the fallback `rewrites` defined in your `next.config.js` will _not_ be run.

When using parameters in a rewrite the parameters will be passed in the query
by default when none of the parameters are used in the `destination`.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/old-about/:path*',
            destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query
          },
        ];
      },
    };

If a parameter is used in the destination none of the parameters will be
automatically passed in the query.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/docs/:path*',
            destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query
          },
        ];
      },
    };

You can still pass the parameters manually in the query if one is already used
in the destination by specifying the query in the `destination`.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/:first/:second',
            destination: '/:first?second=:second',
            // Since the :first parameter is used in the destination the :second parameter
            // will not automatically be added in the query although we can manually add it
            // as shown above
          },
        ];
      },
    };

> **Note** : Static pages from Automatic Static Optimization or prerendering
> params from rewrites will be parsed on the client after hydration and
> provided in the query.

Path matches are allowed, for example `/blog/:slug` will match `/blog/hello-
world` (no nested paths):

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog/:slug',
            destination: '/news/:slug', // Matched parameters can be used in the destination
          },
        ];
      },
    };

To match a wildcard path you can use `*` after a parameter, for example
`/blog/:slug*` will match `/blog/a/b/c/d/hello-world`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog/:slug*',
            destination: '/news/:slug*', // Matched parameters can be used in the destination
          },
        ];
      },
    };

To match a regex path you can wrap the regex in parenthesis after a parameter,
for example `/blog/:slug(\\d{1,})` will match `/blog/123` but not `/blog/abc`:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/old-blog/:post(\\d{1,})',
            destination: '/blog/:post', // Matched parameters can be used in the destination
          },
        ];
      },
    };

The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for
regex path matching, so when used in the `source` as non-special values they
must be escaped by adding `\\` before them:

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            // this will match `/english(default)/something` being requested
            source: '/english\\(default\\)/:slug',
            destination: '/en-us/:slug',
          },
        ];
      },
    };

To only match a rewrite when header, cookie, or query values also match the
`has` field or don't match the `missing` field can be used. Both the `source`
and all `has` items must match and all `missing` items must not match for the
rewrite to be applied.

`has` and `missing` items can have the following fields:

  * `type`: `String` \- must be either `header`, `cookie`, `host`, or `query`.
  * `key`: `String` \- the key from the selected type to match against.
  * `value`: `String` or `undefined` \- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

    
    
    module.exports = {
      async rewrites() {
        return [
          // if the header `x-rewrite-me` is present,
          // this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-rewrite-me',
              },
            ],
            destination: '/another-page',
          },
          // if the header `x-rewrite-me` is not present,
          // this rewrite will be applied
          {
            source: '/:path*',
            missing: [
              {
                type: 'header',
                key: 'x-rewrite-me',
              },
            ],
            destination: '/another-page',
          },
          // if the source, query, and cookie are matched,
          // this rewrite will be applied
          {
            source: '/specific/:path*',
            has: [
              {
                type: 'query',
                key: 'page',
                // the page value will not be available in the
                // destination since value is provided and doesn't
                // use a named capture group e.g. (?<page>home)
                value: 'home',
              },
              {
                type: 'cookie',
                key: 'authorized',
                value: 'true',
              },
            ],
            destination: '/:path*/home',
          },
          // if the header `x-authorized` is present and
          // contains a matching value, this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'header',
                key: 'x-authorized',
                value: '(?<authorized>yes|true)',
              },
            ],
            destination: '/home?authorized=:authorized',
          },
          // if the host is `example.com`,
          // this rewrite will be applied
          {
            source: '/:path*',
            has: [
              {
                type: 'host',
                value: 'example.com',
              },
            ],
            destination: '/another-page',
          },
        ];
      },
    };

**Examples**

Rewrites allow you to rewrite to an external url. This is especially useful
for incrementally adopting Next.js. The following is an example rewrite for
redirecting the `/blog` route of your main app to an external site.

    
    
    module.exports = {
      async rewrites() {
        return [
          {
            source: '/blog',
            destination: 'https://example.com/blog',
          },
          {
            source: '/blog/:slug',
            destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination
          },
        ];
      },
    };

If you're using `trailingSlash: true`, you also need to insert a trailing
slash in the `source` parameter. If the destination server is also expecting a
trailing slash it should be included in the `destination` parameter as well.

    
    
    module.exports = {
      trailingSlash: true,
      async rewrites() {
        return [
          {
            source: '/blog/',
            destination: 'https://example.com/blog/',
          },
          {
            source: '/blog/:path*/',
            destination: 'https://example.com/blog/:path*/',
          },
        ];
      },
    };

You can also have Next.js fall back to proxying to an existing website after
checking all Next.js routes.

This way you don't have to change the rewrites configuration when migrating
more pages to Next.js

    
    
    module.exports = {
      async rewrites() {
        return {
          fallback: [
            {
              source: '/:path*',
              destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,
            },
          ],
        };
      },
    };

When leveraging `basePath` support with rewrites each `source` and
`destination` is automatically prefixed with the `basePath` unless you add
`basePath: false` to the rewrite:

    
    
    module.exports = {
      basePath: '/docs',
     
      async rewrites() {
        return [
          {
            source: '/with-basePath', // automatically becomes /docs/with-basePath
            destination: '/another', // automatically becomes /docs/another
          },
          {
            // does not add /docs to /without-basePath since basePath: false is set
            // Note: this can not be used for internal rewrites e.g. `destination: '/another'`
            source: '/without-basePath',
            destination: 'https://example.com',
            basePath: false,
          },
        ];
      },
    };

When leveraging `i18n` support with rewrites each `source` and `destination`
is automatically prefixed to handle the configured `locales` unless you add
`locale: false` to the rewrite. If `locale: false` is used you must prefix the
`source` and `destination` with a locale for it to be matched correctly.

    
    
    module.exports = {
      i18n: {
        locales: ['en', 'fr', 'de'],
        defaultLocale: 'en',
      },
     
      async rewrites() {
        return [
          {
            source: '/with-locale', // automatically handles all locales
            destination: '/another', // automatically passes the locale on
          },
          {
            // does not handle locales automatically since locale: false is set
            source: '/nl/with-locale-manual',
            destination: '/nl/another',
            locale: false,
          },
          {
            // this matches '/' since `en` is the defaultLocale
            source: '/en',
            destination: '/en/another',
            locale: false,
          },
          {
            // it's possible to match all locales even when locale: false is set
            source: '/:locale/api-alias/:path*',
            destination: '/api/:path*',
            locale: false,
          },
          {
            // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
            // `/` or `/fr` routes like /:path* would
            source: '/(.*)',
            destination: '/another',
          },
        ];
      },
    };

Version| Changes  
---|---  
`v13.3.0`| `missing` added.  
`v10.2.0`| `has` added.  
`v9.5.0`| Headers added.





Using Pages Router

Features available in /pages



  
  
Using Pages Router

Features available in /pages





Using Pages Router

Features available in /pages





# turbo (experimental)

> **Warning** : These features are experimental and will only work with `next
> --turbo`.

Currently, Turbopack supports a subset of webpack's loader API, allowing you
to use some webpack loaders to transform code in Turbopack.

To configure loaders, add the names of the loaders you've installed and any
options in `next.config.js`, mapping file extensions to a list of loaders:

    
    
    module.exports = {
      experimental: {
        turbo: {
          loaders: {
            // Option format
            '.md': [
              {
                loader: '@mdx-js/loader',
                options: {
                  format: 'md',
                },
              },
            ],
            // Option-less format
            '.mdx': ['@mdx-js/loader'],
          },
        },
      },
    };

Then, given the above configuration, you can use transformed code from your
app:

    
    
    import MyDoc from './my-doc.mdx';
     
    export default function Home() {
      return <MyDoc />;
    }

Through `next.config.js`, Turbopack can be configured to modify module
resolution through aliases, similar to webpack's `resolve.alias`
configuration.

To configure resolve aliases, map imported patterns to their new destination
in `next.config.js`:

    
    
    module.exports = {
      experimental: {
        turbo: {
          resolveAlias: {
            underscore: 'lodash',
            mocha: { browser: 'mocha/browser-entry.js' },
          },
        },
      },
    };

This aliases imports of the `underscore` package to the `lodash` package. In
other words, `import underscore from 'underscore'` will load the `lodash`
module instead of `underscore`.

Turbopack also supports conditional aliasing through this field, similar to
Node.js's conditional exports. At the moment only the `browser` condition is
supported. In the case above, imports of the `mocha` module will be aliased to
`mocha/browser-entry.js` when Turbopack targets browser environments.

For more information and guidance for how to migrate your app to Turbopack
from webpack, see Turbopack's documentation on webpack compatibility.





Using Pages Router

Features available in /pages





# urlImports

URL imports are an experimental feature that allows you to import modules
directly from external servers (instead of from the local disk).

> **Warning** : This feature is experimental. Only use domains that you trust
> to download and execute on your machine. Please exercise discretion, and
> caution until the feature is flagged as stable.

To opt-in, add the allowed URL prefixes inside `next.config.js`:

    
    
    module.exports = {
      experimental: {
        urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],
      },
    };

Then, you can import modules directly from URLs:

    
    
    import { a, b, c } from 'https://example.com/assets/some/module.js';

URL Imports can be used everywhere normal package imports can be used.

This feature is being designed with **security as the top priority**. To
start, we added an experimental flag forcing you to explicitly allow the
domains you accept URL imports from. We're working to take this further by
limiting URL imports to execute in the browser sandbox using the Edge Runtime.

When using URL imports, Next.js will create a `next.lock` directory containing
a lockfile and fetched assets. This directory **must be committed to Git** ,
not ignored by `.gitignore`.

  * When running `next dev`, Next.js will download and add all newly discovered URL Imports to your lockfile
  * When running `next build`, Next.js will use only the lockfile to build the application for production

Typically, no network requests are needed and any outdated lockfile will cause
the build to fail. One exception is resources that respond with `Cache-
Control: no-cache`. These resources will have a `no-cache` entry in the
lockfile and will always be fetched from the network on each build.

    
    
    import confetti from 'https://cdn.skypack.dev/canvas-confetti';
    import { useEffect } from 'react';
     
    export default () => {
      useEffect(() => {
        confetti();
      });
      return <p>Hello</p>;
    };
    
    
    import Image from 'next/image';
    import logo from 'https://example.com/assets/logo.png';
     
    export default () => (
      <div>
        <Image src={logo} placeholder="blur" />
      </div>
    );
    
    
    .className {
      background: url('https://example.com/assets/hero.jpg');
    }
    
    
    const logo = new URL('https://example.com/assets/file.txt', import.meta.url);
     
    console.log(logo.pathname);
     
    // prints "/_next/static/media/file.a9727b5d.txt"



  
  
# Custom Webpack Config

> **Note** : changes to webpack config are not covered by semver so proceed at
> your own risk

Before continuing to add custom webpack configuration to your application make
sure Next.js doesn't already support your use-case:

Some commonly asked for features are available as plugins:

In order to extend our usage of `webpack`, you can define a function that
extends its config inside `next.config.js`, like so:

    
    
    module.exports = {
      webpack: (
        config,
        { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack },
      ) => {
        // Important: return the modified config
        return config;
      },
    };

> The `webpack` function is executed twice, once for the server and once for
> the client. This allows you to distinguish between client and server
> configuration using the `isServer` property.

The second argument to the `webpack` function is an object with the following
properties:

  * `buildId`: `String` \- The build id, used as a unique identifier between builds
  * `dev`: `Boolean` \- Indicates if the compilation will be done in development
  * `isServer`: `Boolean` \- It's `true` for server-side compilation, and `false` for client-side compilation
  * `nextRuntime`: `String | undefined` \- The target runtime for server-side compilation; either `"edge"` or `"nodejs"`, it's `undefined` for client-side compilation.
  * `defaultLoaders`: `Object` \- Default loaders used internally by Next.js: 
    * `babel`: `Object` \- Default `babel-loader` configuration

Example usage of `defaultLoaders.babel`:

    
    
    // Example config for adding a loader that depends on babel-loader
    // This source was taken from the @next/mdx plugin source:
    // https://github.com/vercel/next.js/tree/canary/packages/next-mdx
    module.exports = {
      webpack: (config, options) => {
        config.module.rules.push({
          test: /\.mdx/,
          use: [
            options.defaultLoaders.babel,
            {
              loader: '@mdx-js/loader',
              options: pluginOptions.options,
            },
          ],
        });
     
        return config;
      },
    };

Notice that `isServer` is `true` when `nextRuntime` is `"edge"` or `"nodejs"`,
nextRuntime "`edge`" is currently for middleware and Server Components in edge
runtime only.





Using Pages Router

Features available in /pages





# create-next-app

The easiest way to get started with Next.js is by using `create-next-app`.
This CLI tool enables you to quickly start building a new Next.js application,
with everything set up for you. You can create a new app using the default
Next.js template, or by using one of the official Next.js examples. To get
started, use the following command:

You can create a new project interactively by running:

    
    
    npx create-next-app@latest
     
    yarn create next-app
     
    pnpm create next-app

You will then be asked the following prompts:

    
    
    What is your project named?  my-app
    Would you like to add TypeScript with this project?  Y/N
    Would you like to use ESLint with this project?  Y/N
    Would you like to use Tailwind CSS with this project? Y/N
    Would you like to use the `src/ directory` with this project? Y/N
    What import alias would you like configured? `@/*`

Once you've answered the prompts, a new project will be created with the
correct configuration depending on your answers.

You can also pass command line arguments to set up a new project non-
interactively.

Further, you can negate default options by prefixing them with `--no-` (e.g.
`--no-eslint`).

See `create-next-app --help`:

    
    
    Usage: create-next-app <project-directory> [options]
     
    Options:
      -V, --version                        output the version number
      --ts, --typescript
     
        Initialize as a TypeScript project. (default)
     
      --js, --javascript
     
        Initialize as a JavaScript project.
     
      --tailwind
     
        Initialize with Tailwind CSS config. (default)
     
      --eslint
     
        Initialize with ESLint config.
     
      --src-dir
     
        Initialize inside a `src/` directory.
     
      --import-alias <alias-to-configure>
     
        Specify import alias to use (default "@/*").
     
      --use-npm
     
        Explicitly tell the CLI to bootstrap the app using npm
     
      --use-pnpm
     
        Explicitly tell the CLI to bootstrap the app using pnpm
     
      -e, --example [name]|[github-url]
     
        An example to bootstrap the app with. You can use an example name
        from the official Next.js repo or a GitHub URL. The URL can use
        any branch and/or subdirectory
     
      --example-path <path-to-example>
     
        In a rare case, your GitHub URL might contain a branch name with
        a slash (e.g. bug/fix-1) and the path to the example (e.g. foo/bar).
        In this case, you must specify the path to the example separately:
        --example-path foo/bar
     
      --reset-preferences
     
        Explicitly tell the CLI to reset any stored preferences
     
      -h, --help                           output usage information

`create-next-app` allows you to create a new Next.js app within seconds. It is
officially maintained by the creators of Next.js, and includes a number of
benefits:

  * **Interactive Experience** : Running `npx create-next-app@latest` (with no arguments) launches an interactive experience that guides you through setting up a project.
  * **Zero Dependencies** : Initializing a project is as quick as one second. Create Next App has zero dependencies.
  * **Offline Support** : Create Next App will automatically detect if you're offline and bootstrap your project using your local package cache.
  * **Support for Examples** : Create Next App can bootstrap your application using an example from the Next.js examples collection (e.g. `npx create-next-app --example api-routes`).
  * **Tested** : The package is part of the Next.js monorepo and tested using the same integration test suite as Next.js itself, ensuring it works as expected with every release.





# Next.js CLI

The Next.js CLI allows you to start, build, and export your application.

To get a list of the available CLI commands, run the following command inside
your project directory:

_(npx comes with npm 5.2+ and higher)_

The output should look like this:

    
    
    Usage
      $ next <command>
     
    Available commands
      build, start, export, dev, lint, telemetry, info
     
    Options
      --version, -v   Version number
      --help, -h      Displays this message
     
    For more information run a command with the --help flag
      $ next build --help

You can pass any node arguments to `next` commands:

    
    
    NODE_OPTIONS='--throw-deprecation' next
    NODE_OPTIONS='-r esm' next
    NODE_OPTIONS='--inspect' next

> **Note** : Running `next` without a command is the same as running `next
> dev`

`next build` creates an optimized production build of your application. The
output displays information about each route.

  * **Size** – The number of assets downloaded when navigating to the page client-side. The size for each route only includes its dependencies.
  * **First Load JS** – The number of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown as a separate metric.

Both of these values are **compressed with gzip**. The first load is indicated
by green, yellow, or red. Aim for green for performant applications.

You can enable production profiling for React with the `--profile` flag in
`next build`. This requires Next.js 9.5:

After that, you can use the profiler in the same way as you would in
development.

You can enable more verbose build output with the `--debug` flag in `next
build`. This requires Next.js 9.5.3:

With this flag enabled additional build output like rewrites, redirects, and
headers will be shown.

`next dev` starts the application in development mode with hot-code reloading,
error reporting, and more:

The application will start at `http://localhost:3000` by default. The default
port can be changed with `-p`, like so:

Or using the `PORT` environment variable:

> **Note** : `PORT` cannot be set in `.env` as booting up the HTTP server
> happens before any other code is initialized.

You can also set the hostname to be different from the default of `0.0.0.0`,
this can be useful for making the application available for other devices on
the network. The default hostname can be changed with `-H`, like so:

    
    
    npx next dev -H 192.168.1.2

`next start` starts the application in production mode. The application should
be compiled with `next build` first.

The application will start at `http://localhost:3000` by default. The default
port can be changed with `-p`, like so:

Or using the `PORT` environment variable:

> **Note** : `PORT` cannot be set in `.env` as booting up the HTTP server
> happens before any other code is initialized.

> **Note** : `next start` cannot be used with `output: 'standalone'` or
> `output: 'export'`.

When deploying Next.js behind a downstream proxy (e.g. a load-balancer like
AWS ELB/ALB) it's important to configure Next's underlying HTTP server with
keep-alive timeouts that are _larger_ than the downstream proxy's timeouts.
Otherwise, once a keep-alive timeout is reached for a given TCP connection,
Node.js will immediately terminate that connection without notifying the
downstream proxy. This results in a proxy error whenever it attempts to reuse
a connection that Node.js has already terminated.

To configure the timeout values for the production Next.js server, pass
`--keepAliveTimeout` (in milliseconds) to `next start`, like so:

    
    
    npx next start --keepAliveTimeout 70000

`next lint` runs ESLint for all files in the `pages/`, `app` (only if the
experimental `appDir` feature is enabled), `components/`, `lib/`, and `src/`
directories. It also provides a guided setup to install any required
dependencies if ESLint is not already configured in your application.

If you have other directories that you would like to lint, you can specify
them using the `--dir` flag:

Next.js collects **completely anonymous** telemetry data about general usage.
Participation in this anonymous program is optional, and you may opt-out if
you'd not like to share any information.

To learn more about Telemetry, please read this document.

`next info` prints relevant details about the current system which can be used
to report Next.js bugs. This information includes Operating System
platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm) and npm package
versions (`next`, `react`, `react-dom`).

Running the following in your project's root directory:

will give you information like this example:

    
    
     
        Operating System:
          Platform: linux
          Arch: x64
          Version: #22-Ubuntu SMP Fri Nov 5 13:21:36 UTC 2021
        Binaries:
          Node: 16.13.0
          npm: 8.1.0
          Yarn: 1.22.17
          pnpm: 6.24.2
        Relevant packages:
          next: 12.0.8
          react: 17.0.2
          react-dom: 17.0.2
     

This information should then be pasted into GitHub Issues.





`AbortController`| Allows you to abort one or more DOM requests as and when
desired  
`DOMException`| Represents an error that occurs in the DOM  
`structuredClone`| Creates a deep copy of a value  
`URLPattern`| Represents a URL pattern  
`Array`| Represents an array of values  
`ArrayBuffer`| Represents a generic, fixed-length raw binary data buffer  
`Atomics`| Provides atomic operations as static methods  
`BigInt`| Represents a whole number with arbitrary precision  
`BigInt64Array`| Represents a typed array of 64-bit signed integers  
`BigUint64Array`| Represents a typed array of 64-bit unsigned integers  
`Boolean`| Represents a logical entity and can have two values: `true` and
`false`  
`clearInterval`| Cancels a timed, repeating action which was previously
established by a call to `setInterval()`  
`clearTimeout`| Cancels a timed, repeating action which was previously
established by a call to `setTimeout()`  
`console`| Provides access to the browser's debugging console  
`DataView`| Represents a generic view of an `ArrayBuffer`  
`Date`| Represents a single moment in time in a platform-independent format  
`decodeURI`| Decodes a Uniform Resource Identifier (URI) previously created by
`encodeURI` or by a similar routine  
`decodeURIComponent`| Decodes a Uniform Resource Identifier (URI) component
previously created by `encodeURIComponent` or by a similar routine  
`encodeURI`| Encodes a Uniform Resource Identifier (URI) by replacing each
instance of certain characters by one, two, three, or four escape sequences
representing the UTF-8 encoding of the character  
`encodeURIComponent`| Encodes a Uniform Resource Identifier (URI) component by
replacing each instance of certain characters by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character  
`Error`| Represents an error when trying to execute a statement or accessing a
property  
`EvalError`| Represents an error that occurs regarding the global function
`eval()`  
`Float32Array`| Represents a typed array of 32-bit floating point numbers  
`Float64Array`| Represents a typed array of 64-bit floating point numbers  
`Function`| Represents a function  
`Infinity`| Represents the mathematical Infinity value  
`Int8Array`| Represents a typed array of 8-bit signed integers  
`Int16Array`| Represents a typed array of 16-bit signed integers  
`Int32Array`| Represents a typed array of 32-bit signed integers  
`Intl`| Provides access to internationalization and localization functionality  
`isFinite`| Determines whether a value is a finite number  
`isNaN`| Determines whether a value is `NaN` or not  
`JSON`| Provides functionality to convert JavaScript values to and from the
JSON format  
`Map`| Represents a collection of values, where each value may occur only once  
`Math`| Provides access to mathematical functions and constants  
`Number`| Represents a numeric value  
`Object`| Represents the object that is the base of all JavaScript objects  
`parseFloat`| Parses a string argument and returns a floating point number  
`parseInt`| Parses a string argument and returns an integer of the specified
radix  
`Promise`| Represents the eventual completion (or failure) of an asynchronous
operation, and its resulting value  
`Proxy`| Represents an object that is used to define custom behavior for
fundamental operations (e.g. property lookup, assignment, enumeration,
function invocation, etc)  
`RangeError`| Represents an error when a value is not in the set or range of
allowed values  
`ReferenceError`| Represents an error when a non-existent variable is
referenced  
`Reflect`| Provides methods for interceptable JavaScript operations  
`RegExp`| Represents a regular expression, allowing you to match combinations
of characters  
`Set`| Represents a collection of values, where each value may occur only once  
`setInterval`| Repeatedly calls a function, with a fixed time delay between
each call  
`setTimeout`| Calls a function or evaluates an expression after a specified
number of milliseconds  
`SharedArrayBuffer`| Represents a generic, fixed-length raw binary data buffer  
`String`| Represents a sequence of characters  
`Symbol`| Represents a unique and immutable data type that is used as the key
of an object property  
`SyntaxError`| Represents an error when trying to interpret syntactically
invalid code  
`TypeError`| Represents an error when a value is not of the expected type  
`Uint8Array`| Represents a typed array of 8-bit unsigned integers  
`Uint8ClampedArray`| Represents a typed array of 8-bit unsigned integers
clamped to 0-255  
`Uint32Array`| Represents a typed array of 32-bit unsigned integers  
`URIError`| Represents an error when a global URI handling function was used
in a wrong way  
`URL`| Represents an object providing static methods used for creating object
URLs  
`URLSearchParams`| Represents a collection of key/value pairs  
`WeakMap`| Represents a collection of key/value pairs in which the keys are
weakly referenced  
`WeakSet`| Represents a collection of objects in which each object may occur
only once  
`WebAssembly`| Provides access to WebAssembly





# Accessibility

The Next.js team is committed to making Next.js accessible to all developers
(and their end-users). By adding accessibility features to Next.js by default,
we aim to make the Web more inclusive for everyone.

When transitioning between pages rendered on the server (e.g. using the `<a
href>` tag) screen readers and other assistive technology announce the page
title when the page loads so that users understand that the page has changed.

In addition to traditional page navigations, Next.js also supports client-side
transitions for improved performance (using `next/link`). To ensure that
client-side transitions are also announced to assistive technology, Next.js
includes a route announcer by default.

The Next.js route announcer looks for the page name to announce by first
inspecting `document.title`, then the `<h1>` element, and finally the URL
pathname. For the most accessible user experience, ensure that each page in
your application has a unique and descriptive title.

Next.js provides an integrated ESLint experience out of the box, including
custom rules for Next.js. By default, Next.js includes `eslint-plugin-
jsx-a11y` to help catch accessibility issues early, including warning on:

For example, this plugin helps ensure you add alt text to `img` tags, use
correct `aria-*` attributes, use correct `role` attributes, and more.



  
  
# Fast Refresh

 **Examples**

Fast Refresh is a Next.js feature that gives you instantaneous feedback on
edits made to your React components. Fast Refresh is enabled by default in all
Next.js applications on **9.4 or newer**. With Next.js Fast Refresh enabled,
most edits should be visible within a second, **without losing component
state**.

  * If you edit a file that **only exports React component(s)** , Fast Refresh will update the code only for that file, and re-render your component. You can edit anything in that file, including styles, rendering logic, event handlers, or effects.
  * If you edit a file with exports that _aren't_ React components, Fast Refresh will re-run both that file, and the other files importing it. So if both `Button.js` and `Modal.js` import `theme.js`, editing `theme.js` will update both components.
  * Finally, if you **edit a file** that's **imported by files outside of the React tree** , Fast Refresh **will fall back to doing a full reload**. You might have a file which renders a React component but also exports a value that is imported by a **non-React component**. For example, maybe your component also exports a constant, and a non-React utility file imports it. In that case, consider migrating the constant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be solved in a similar way.

If you make a syntax error during development, you can fix it and save the
file again. The error will disappear automatically, so you won't need to
reload the app. **You will not lose component state**.

If you make a mistake that leads to a runtime error inside your component,
you'll be greeted with a contextual overlay. Fixing the error will
automatically dismiss the overlay, without reloading the app.

Component state will be retained if the error did not occur during rendering.
If the error did occur during rendering, React will remount your application
using the updated code.

If you have error boundaries in your app (which is a good idea for graceful
failures in production), they will retry rendering on the next edit after a
rendering error. This means having an error boundary can prevent you from
always getting reset to the root app state. However, keep in mind that error
boundaries shouldn't be _too_ granular. They are used by React in production,
and should always be designed intentionally.

Fast Refresh tries to preserve local React state in the component you're
editing, but only if it's safe to do so. Here's a few reasons why you might
see local state being reset on every edit to a file:

  * Local state is not preserved for class components (only function components and Hooks preserve state).
  * The file you're editing might have _other_ exports in addition to a React component.
  * Sometimes, a file would export the result of calling a higher-order component like `HOC(WrappedComponent)`. If the returned component is a class, its state will be reset.
  * Anonymous arrow functions like `export default () => <div />;` cause Fast Refresh to not preserve local component state. For large codebases you can use our `name-default-component` codemod.

As more of your codebase moves to function components and Hooks, you can
expect state to be preserved in more cases.

  * Fast Refresh preserves React local state in function components (and Hooks) by default.
  * Sometimes you might want to _force_ the state to be reset, and a component to be remounted. For example, this can be handy if you're tweaking an animation that only happens on mount. To do this, you can add `// @refresh reset` anywhere in the file you're editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit.
  * You can put `console.log` or `debugger;` into the components you edit during development.

When possible, Fast Refresh attempts to preserve the state of your component
between edits. In particular, `useState` and `useRef` preserve their previous
values as long as you don't change their arguments or the order of the Hook
calls.

Hooks with dependencies—such as `useEffect`, `useMemo`, and `useCallback`—will
_always_ update during Fast Refresh. Their list of dependencies will be
ignored while Fast Refresh is happening.

For example, when you edit `useMemo(() => x * 2, [x])` to `useMemo(() => x *
10, [x])`, it will re-run even though `x` (the dependency) has not changed. If
React didn't do that, your edit wouldn't reflect on the screen!

Sometimes, this can lead to unexpected results. For example, even a
`useEffect` with an empty array of dependencies would still re-run once during
Fast Refresh.

However, writing code resilient to occasional re-running of `useEffect` is a
good practice even without Fast Refresh. It will make it easier for you to
introduce new dependencies to it later on and it's enforced by React Strict
Mode, which we highly recommend enabling.



  
  
# Next.js Compiler

The Next.js Compiler, written in Rust using SWC, allows Next.js to transform
and minify your JavaScript code for production. This replaces Babel for
individual files and Terser for minifying output bundles.

Compilation using the Next.js Compiler is 17x faster than Babel and enabled by
default since Next.js version 12. If you have an existing Babel configuration
or are using unsupported features, your application will opt-out of the
Next.js Compiler and continue using Babel.

SWC is an extensible Rust-based platform for the next generation of fast
developer tools.

SWC can be used for compilation, minification, bundling, and more – and is
designed to be extended. It's something you can call to perform code
transformations (either built-in or custom). Running those transformations
happens through higher-level tools like Next.js.

We chose to build on SWC for a few reasons:

  * **Extensibility:** SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.
  * **Performance:** We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.
  * **WebAssembly:** Rust's support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.
  * **Community:** The Rust community and ecosystem are amazing and still growing.

We're working to port `babel-plugin-styled-components` to the Next.js
Compiler.

First, update to the latest version of Next.js: `npm install next@latest`.
Then, update your `next.config.js` file:

    
    
    module.exports = {
      compiler: {
        // see https://styled-components.com/docs/tooling#babel-plugin for more info on the options.
        styledComponents: boolean | {
          // Enabled by default in development, disabled in production to reduce file size,
          // setting this will override the default for all environments.
          displayName?: boolean,
          // Enabled by default.
          ssr?: boolean,
          // Enabled by default.
          fileName?: boolean,
          // Empty by default.
          topLevelImportPaths?: string[],
          // Defaults to ["index"].
          meaninglessFileNames?: string[],
          // Enabled by default.
          cssProp?: boolean,
          // Empty by default.
          namespace?: string,
          // Not supported yet.
          minify?: boolean,
          // Not supported yet.
          transpileTemplateLiterals?: boolean,
          // Not supported yet.
          pure?: boolean,
        },
      },
    }

`minify`, `transpileTemplateLiterals` and `pure` are not yet implemented. You
can follow the progress here. `ssr` and `displayName` transforms are the main
requirement for using `styled-components` in Next.js.

The Next.js Compiler transpiles your tests and simplifies configuring Jest
together with Next.js including:

  * Auto mocking of `.css`, `.module.css` (and their `.scss` variants), and image imports
  * Automatically sets up `transform` using SWC
  * Loading `.env` (and all variants) into `process.env`
  * Ignores `node_modules` from test resolving and transforms
  * Ignoring `.next` from test resolving
  * Loads `next.config.js` for flags that enable experimental SWC transforms

First, update to the latest version of Next.js: `npm install next@latest`.
Then, update your `jest.config.js` file:

    
    
    const nextJest = require('next/jest');
     
    // Providing the path to your Next.js app which will enable loading next.config.js and .env files
    const createJestConfig = nextJest({ dir: './' });
     
    // Any custom config you want to pass to Jest
    const customJestConfig = {
      setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
    };
     
    // createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is async
    module.exports = createJestConfig(customJestConfig);

To enable Relay support:

    
    
    module.exports = {
      compiler: {
        relay: {
          // This should match relay.config.js
          src: './',
          artifactDirectory: './__generated__',
          language: 'typescript',
          eagerEsModules: false,
        },
      },
    };

> **Note:** In Next.js, all JavaScript files in `pages` directory are
> considered routes. So, for `relay-compiler` you'll need to specify
> `artifactDirectory` configuration settings outside of the `pages`, otherwise
> `relay-compiler` will generate files next to the source file in the
> `__generated__` directory, and this file will be considered a route, which
> will break production builds.

Allows to remove JSX properties. This is often used for testing. Similar to
`babel-plugin-react-remove-properties`.

To remove properties matching the default regex `^data-test`:

    
    
    module.exports = {
      compiler: {
        reactRemoveProperties: true,
      },
    };

To remove custom properties:

    
    
    module.exports = {
      compiler: {
        // The regexes defined here are processed in Rust so the syntax is different from
        // JavaScript `RegExp`s. See https://docs.rs/regex.
        reactRemoveProperties: { properties: ['^data-custom$'] },
      },
    };

This transform allows for removing all `console.*` calls in application code
(not `node_modules`). Similar to `babel-plugin-transform-remove-console`.

Remove all `console.*` calls:

    
    
    module.exports = {
      compiler: {
        removeConsole: true,
      },
    };

Remove `console.*` output except `console.error`:

    
    
    module.exports = {
      compiler: {
        removeConsole: {
          exclude: ['error'],
        },
      },
    };

Next.js will automatically detect `experimentalDecorators` in `jsconfig.json`
or `tsconfig.json`. Legacy decorators are commonly used with older versions of
libraries like `mobx`.

This flag is only supported for compatibility with existing applications. We
do not recommend using legacy decorators in new applications.

First, update to the latest version of Next.js: `npm install next@latest`.
Then, update your `jsconfig.json` or `tsconfig.json` file:

    
    
    {
      "compilerOptions": {
        "experimentalDecorators": true
      }
    }

Next.js will automatically detect `jsxImportSource` in `jsconfig.json` or
`tsconfig.json` and apply that. This is commonly used with libraries like
Theme UI.

First, update to the latest version of Next.js: `npm install next@latest`.
Then, update your `jsconfig.json` or `tsconfig.json` file:

    
    
    {
      "compilerOptions": {
        "jsxImportSource": "theme-ui"
      }
    }

We're working to port `@emotion/babel-plugin` to the Next.js Compiler.

First, update to the latest version of Next.js: `npm install next@latest`.
Then, update your `next.config.js` file:

    
    
     
    module.exports = {
      compiler: {
        emotion: boolean | {
          // default is true. It will be disabled when build type is production.
          sourceMap?: boolean,
          // default is 'dev-only'.
          autoLabel?: 'never' | 'dev-only' | 'always',
          // default is '[local]'.
          // Allowed values: `[local]` `[filename]` and `[dirname]`
          // This option only works when autoLabel is set to 'dev-only' or 'always'.
          // It allows you to define the format of the resulting label.
          // The format is defined via string where variable parts are enclosed in square brackets [].
          // For example labelFormat: "my-classname--[local]", where [local] will be replaced with the name of the variable the result is assigned to.
          labelFormat?: string,
          // default is undefined.
          // This option allows you to tell the compiler what imports it should
          // look at to determine what it should transform so if you re-export
          // Emotion's exports, you can still use transforms.
          importMap?: {
            [packageName: string]: {
              [exportName: string]: {
                canonicalImport?: [string, string],
                styledBaseImport?: [string, string],
              }
            }
          },
        },
      },
    }

Next.js' swc compiler is used for minification by default since v13. This is
7x faster than Terser.

If Terser is still needed for any reason this can be configured.

    
    
    module.exports = {
      swcMinify: false,
    };

Next.js can automatically transpile and bundle dependencies from local
packages (like monorepos) or from external dependencies (`node_modules`). This
replaces the `next-transpile-modules` package.

    
    
    module.exports = {
      transpilePackages: ['@acme/ui', 'lodash-es'],
    };

**Examples**

Allows to modularize imports, similar to babel-plugin-transform-imports.

Transforms member style imports of packages that use a “barrel file” (a single
file that re-exports other modules):

    
    
    import { Row, Grid as MyGrid } from 'react-bootstrap';
    import { merge } from 'lodash';

...into default style imports of each module. This prevents compilation of
unused modules:

    
    
    import Row from 'react-bootstrap/Row';
    import MyGrid from 'react-bootstrap/Grid';
    import merge from 'lodash/merge';

Config for the above transform:

    
    
    module.exports = {
      modularizeImports: {
        'react-bootstrap': {
          transform: 'react-bootstrap/{{member}}',
        },
        lodash: {
          transform: 'lodash/{{member}}',
        },
      },
    };

This transform uses handlebars to template the replacement import path in the
`transform` field. These variables and helper functions are available:

  1. `member`: Has type `string`. The name of the member import.
  2. `lowerCase`, `upperCase`, `camelCase`, `kebabCase`: Helper functions to convert a string to lower, upper, camel or kebab cases.
  3. `matches`: Has type `string[]`. All groups matched by the regular expression. `matches.[0]` is the full match.

For example, you can use the `kebabCase` helper like this:

    
    
    module.exports = {
      modularizeImports: {
        'my-library': {
          transform: 'my-library/{{ kebabCase member }}',
        },
      },
    };

The above config will transform your code as follows:

    
    
    // Before
    import { MyModule } from 'my-library';
     
    // After (`MyModule` was converted to `my-module`)
    import MyModule from 'my-library/my-module';

You can also use regular expressions using Rust regex crate’s syntax:

    
    
    module.exports = {
      modularizeImports: {
        'my-library/?(((\\w*)?/?)*)': {
          transform: 'my-library/{{ matches.[1] }}/{{member}}',
        },
      },
    };

The above config will transform your code as follows:

    
    
    // Before
    import { MyModule } from 'my-library';
    import { App } from 'my-library/components';
    import { Header, Footer } from 'my-library/components/app';
     
    // After
    import MyModule from 'my-library/my-module';
    import App from 'my-library/components/app';
    import Header from 'my-library/components/app/header';
    import Footer from 'my-library/components/app/footer';

By default, `modularizeImports` assumes that each module uses default exports.
However, this may not always be the case — named exports may be used.

    
    
    // Using named export instead of default export
    export const MyModule = {};
     
    // my-library/index.ts
    // The “barrel file” that re-exports `MyModule`
    export { MyModule } from './MyModule';

In this case, you can use the `skipDefaultConversion` option to use named
imports instead of default imports:

    
    
    module.exports = {
      modularizeImports: {
        'my-library': {
          transform: 'my-library/{{member}}',
          skipDefaultConversion: true,
        },
      },
    };

The above config will transform your code as follows:

    
    
    // Before
    import { MyModule } from 'my-library';
     
    // After (imports `MyModule` using named import)
    import { MyModule } from 'my-library/MyModule';

If you use the `preventFullImport` option, the compiler will throw an error if
you import a “barrel file” using default import. If you use the following
config:

    
    
    module.exports = {
      modularizeImports: {
        lodash: {
          transform: 'lodash/{{member}}',
          preventFullImport: true,
        },
      },
    };

The compiler will throw an error if you try to import the full `lodash`
library (instead of using named imports):

    
    
    // Compiler error
    import lodash from 'lodash';

You can generate SWC's internal transform traces as chromium's trace event
format.

    
    
    module.exports = {
      experimental: {
        swcTraceProfiling: true,
      },
    };

Once enabled, swc will generate trace named as `swc-trace-
profile-${timestamp}.json` under `.next/`. Chromium's trace viewer
(chrome://tracing/, https://ui.perfetto.dev/), or compatible flamegraph viewer
(https://www.speedscope.app/) can load & visualize generated traces.

You can configure swc's transform to use SWC's experimental plugin support
written in wasm to customize transformation behavior.

    
    
    module.exports = {
      experimental: {
        swcPlugins: [
          [
            'plugin',
            {
              ...pluginOptions,
            },
          ],
        ],
      },
    };

`swcPlugins` accepts an array of tuples for configuring plugins. A tuple for
the plugin contains the path to the plugin and an object for plugin
configuration. The path to the plugin can be an npm module package name or an
absolute path to the `.wasm` binary itself.

When your application has a `.babelrc` file, Next.js will automatically fall
back to using Babel for transforming individual files. This ensures backwards
compatibility with existing applications that leverage custom Babel plugins.

If you're using a custom Babel setup, please share your configuration. We're
working to port as many commonly used Babel transformations as possible, as
well as supporting plugins in the future.

Version| Changes  
---|---  
`v13.1.0`| Module Transpilation and Modularize Imports stable.  
`v13.0.0`| SWC Minifier enabled by default.  
`v12.3.0`| SWC Minifier stable.  
`v12.2.0`| SWC Plugins experimental support added.  
`v12.1.0`| Added support for Styled Components, Jest, Relay, Remove React
Properties, Legacy Decorators, Remove Console, and jsxImportSource.  
`v12.0.0`| Next.js Compiler introduced.





# Supported Browsers

Next.js supports **modern browsers** with zero configuration.

  * Chrome 64+
  * Edge 79+
  * Firefox 67+
  * Opera 51+
  * Safari 12+

If you would like to target specific browsers or features, Next.js supports
Browserslist configuration in your `package.json` file. Next.js uses the
following Browserslist configuration by default:

    
    
    {
      "browserslist": [
        "chrome 64",
        "edge 79",
        "firefox 67",
        "opera 51",
        "safari 12"
      ]
    }

We inject widely used polyfills, including:

If any of your dependencies includes these polyfills, they’ll be eliminated
automatically from the production build to avoid duplication.

In addition, to reduce bundle size, Next.js will only load these polyfills for
browsers that require them. The majority of the web traffic globally will not
download these polyfills.

If your own code or any external npm dependencies require features not
supported by your target browsers (such as IE 11), you need to add polyfills
yourself.

In this case, you should add a top-level import for the **specific polyfill**
you need in your Custom `<App>` or the individual component.

Next.js allows you to use the latest JavaScript features out of the box. In
addition to ES6 features, Next.js also supports:

In addition to `fetch()` on the client-side, Next.js polyfills `fetch()` in
the Node.js environment. You can use `fetch()` in your server code (such as
`getStaticProps`/`getServerSideProps`) without using polyfills such as
`isomorphic-unfetch` or `node-fetch`.

Next.js has built-in TypeScript support. Learn more here.

You can customize babel configuration. Learn more here.





Using App Router

Features available in /app





# Routing Fundamentals

The skeleton of every application is routing. This page will introduce you to
the **fundamental concepts** of routing for the web and how to handle routing
in Next.js.

First, you will see these terms being used throughout the documentation.
Here's a quick reference:

![Terminology for Component
Tree](/_next/image?url=%2Fdocs%2Flight%2Fterminology-component-
tree.png&w=3840&q=75)![Terminology for Component
Tree](/_next/image?url=%2Fdocs%2Fdark%2Fterminology-component-
tree.png&w=3840&q=75)

  * **Tree:** A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.
  * **Subtree:** Part of a tree, starting at a new root (first) and ending at the leaves (last).
  * **Root** : The first node in a tree or subtree, such as a root layout.
  * **Leaf:** Nodes in a subtree that have no children, such as the last segment in a URL path.

![Terminology for URL Anatomy](/_next/image?url=%2Fdocs%2Flight%2Fterminology-
url-anatomy.png&w=3840&q=75)![Terminology for URL
Anatomy](/_next/image?url=%2Fdocs%2Fdark%2Fterminology-url-
anatomy.png&w=3840&q=75)

  * **URL Segment:** Part of the URL path delimited by slashes.
  * **URL Path:** Part of the URL that comes after the domain (composed of segments).

In version 13, Next.js introduced a new **App Router** built on React Server
Components, which supports shared layouts, nested routing, loading states,
error handling, and more.

The App Router works in a new directory named `app`. The `app` directory works
alongside the `pages` directory to allow for incremental adoption. This allows
you to opt some routes of your application into the new behavior while keeping
other routes in the `pages` directory for previous behavior. If your
application uses the `pages` directory, please also see the Pages Router
documentation.

> **Good to know:** The App Router takes priority over the Pages Router.
> Routes across directories should not resolve to the same URL path and will
> cause a build-time error to prevent a conflict.

![Next.js App Directory](/_next/image?url=%2Fdocs%2Flight%2Fnext-router-
directories.png&w=3840&q=75)![Next.js App
Directory](/_next/image?url=%2Fdocs%2Fdark%2Fnext-router-
directories.png&w=3840&q=75)

By default, components inside `app` are React Server Components. This is a
performance optimization and allows you to easily adopt them, and you can also
use Client Components.

> **Recommendation:** Check out the Server and Client Components page if
> you're new to Server Components.

Next.js uses a file-system based router where:

  * **Folders** are used to define routes. A route is a single path of nested folders, following the file-system hierarchy from the **root folder** down to a final **leaf folder** that includes a `page.js` file. See Defining Routes.
  * **Files** are used to create UI that is shown for a route segment. See special files.

Each folder in a route represents a **route segment**. Each route segment is
mapped to a corresponding **segment** in a **URL path**.

![How Route Segments Map to URL
Segments](/_next/image?url=%2Fdocs%2Flight%2Froute-segments-to-path-
segments.png&w=3840&q=75)![How Route Segments Map to URL
Segments](/_next/image?url=%2Fdocs%2Fdark%2Froute-segments-to-path-
segments.png&w=3840&q=75)

To create a nested route, you can nest folders inside each other. For example,
you can add a new `/dashboard/settings` route by nesting two new folders in
the `app` directory.

The `/dashboard/settings` route is composed of three segments:

  * `/` (Root segment)
  * `dashboard` (Segment)
  * `settings` (Leaf segment)

Next.js provides a set of special files to create UI with specific behavior in
nested routes:

> **Good to know:** `.js`, `.jsx`, or `.tsx` file extensions can be used for
> special files.

The React components defined in special files of a route segment are rendered
in a specific hierarchy:

  * `layout.js`
  * `template.js`
  * `error.js` (React error boundary)
  * `loading.js` (React suspense boundary)
  * `not-found.js` (React error boundary)
  * `page.js` or nested `layout.js`

![Component Hierarchy for File
Conventions](/_next/image?url=%2Fdocs%2Flight%2Ffile-conventions-component-
hierarchy.png&w=3840&q=75)![Component Hierarchy for File
Conventions](/_next/image?url=%2Fdocs%2Fdark%2Ffile-conventions-component-
hierarchy.png&w=3840&q=75)

In a nested route, the components of a segment will be nested **inside** the
components of its parent segment.

![Nested File Conventions Component
Hierarchy](/_next/image?url=%2Fdocs%2Flight%2Fnested-file-conventions-
component-hierarchy.png&w=3840&q=75)![Nested File Conventions Component
Hierarchy](/_next/image?url=%2Fdocs%2Fdark%2Fnested-file-conventions-
component-hierarchy.png&w=3840&q=75)

In addition to special files, you have the option to colocate your own files
(e.g. components, styles, tests etc) inside folders in the `app` directory.

This is because while folders define routes, only the contents returned by
`page.js` or `route.js` are publically addressable.

![An example folder structure with colocated
files](/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-
colocation.png&w=3840&q=75)![An example folder structure with colocated
files](/_next/image?url=%2Fdocs%2Fdark%2Fproject-organization-
colocation.png&w=3840&q=75)

Learn more about Project Organization and Colocation.

Unlike the `pages` directory which uses client-side routing, the App Router
uses **server-centric routing** to align with Server Components and data
fetching on the server. With server-centric routing, the client does not have
to download a route map and the same request for Server Components can be used
to look up routes. This optimization is useful for all applications, but has a
larger impact on applications with many routes.

Although routing is server-centric, the router uses **client-side navigation**
with the Link Component \- resembling the behavior of a Single-Page
Application. This means when a user navigates to a new route, the browser will
not reload the page. Instead, the URL will be updated and Next.js will only
render the segments that change.

Additionally, as users navigate around the app, the router will store the
result of the React Server Component payload in an **in-memory client-side
cache**. The cache is split by route segments which allows invalidation at any
level and ensures consistency across React's concurrent renders. This means
that for certain cases, the cache of a previously fetched segment can be re-
used, further improving performance.

Learn more about Linking and Navigating.

When navigating between sibling routes (e.g. `/dashboard/settings` and
`/dashboard/analytics` below), Next.js will only fetch and render the layouts
and pages in routes that change. It will **not** re-fetch or re-render
anything above the segments in the subtree. This means that in routes that
share a layout, the layout will be preserved when a user navigates between
sibling pages.

![How partial rendering works](/_next/image?url=%2Fdocs%2Flight%2Fpartial-
rendering.png&w=3840&q=75)![How partial rendering
works](/_next/image?url=%2Fdocs%2Fdark%2Fpartial-rendering.png&w=3840&q=75)

Without partial rendering, each navigation would cause the full page to re-
render on the server. Rendering only the segment that’s updating reduces the
amount of data transferred and execution time, leading to improved
performance.

The App Router also provides a set conventions to help you implement more
advanced routing patterns. These include:

  * Parallel Routes: Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You can use them for split views that have their own sub-navigation. E.g. Dashboards.
  * Intercepting Routes: Allow you to intercept a route and show it in the context of another route. You can use these when keeping the context for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed.

These patterns allow you to build richer and more complex UIs, democratizing
features that were historically complex for small teams and individual
developers to implement.

Now that you understand the fundamentals of routing in Next.js, follow the
links below to create your first routes:





# Rendering

Rendering converts the code you write into user interfaces.

React 18 and Next.js 13 introduced new ways to render your application. This
page will help you understand the differences between rendering environments,
strategies, runtimes, and how to opt into them.

There are two environments where your application code can be rendered: the
client and the server.

![Client and Server Environemnts](/_next/image?url=%2Fdocs%2Flight%2Fclient-
and-server-environments.png&w=3840&q=75)![Client and Server
Environemnts](/_next/image?url=%2Fdocs%2Fdark%2Fclient-and-server-
environments.png&w=3840&q=75)

  * The **client** refers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.
  * The **server** refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

> **Note:** Server can refer to computers in regions where your application is
> deployed to, the Edge Network where your application code is distributed, or
> Content Delivery Networks (CDNs) where the result of the rendering work can
> be cached.

Before React 18, the primary way to render your application **using React**
was entirely on the client.

Next.js provided an easier way to break down your application into **pages**
and prerender on the server by generating HTML and sending it to the client to
be hydrated by React. However, this led to additional JavaScript needed on the
client to make the initial HTML interactive.

Now, with Server and Client Components, React can render on the client **and**
the server meaning you can choose the rendering environment at the component
level.

By default, the `app` router uses **Server Components**, allowing you to
easily render components on the server and reducing the amount of JavaScript
sent to the client.

In addition to client-side and server-side rendering with React components,
Next.js gives you the option to optimize rendering on the server with
**Static** and **Dynamic** Rendering.

With **Static Rendering** , both Server _and_ Client Components can be
prerendered on the server at **build time**. The result of the work is cached
and reused on subsequent requests. The cached result can also be revalidated.

> **Note:** This is equivalent to Static Site Generation (SSG) and Incremental
> Static Regeneration (ISR) in the Pages Router.

Server and Client Components are rendered differently during Static Rendering:

  * Client Components have their HTML and JSON prerendered and cached on the server. The cached result is then sent to the client for hydration.
  * Server Components are rendered on the server by React, and their payload is used to generate HTML. The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.

With Dynamic Rendering, both Server _and_ Client Components are rendered on
the server at **request time**. The result of the work is not cached.

> **Note:** This is equivalent to Server-Side Rendering
> (`getServerSideProps()`) in the Pages Router.

To learn more about static and dynamic behavior, see the Static and Dynamic
Rendering page. To learn more about caching, see the Caching sections.

On the server, there are two runtimes where your pages can be rendered:

  * The **Node.js Runtime** (default) has access to all Node.js APIs and compatible packages from the ecosystem.
  * The **Edge Runtime** is based on Web APIs.

Both runtimes support streaming from the server, depending on your deployment
infrastructure.

To learn how to switch between runtimes, see the Edge and Node.js Runtimes
page.

Now that you understand the fundamentals of rendering, you can learn more
about implementing the different rendering strategies and runtimes:





# Data Fetching

The Next.js App Router introduces a new, simplified data fetching system built
on React and the Web platform. This page will go through the fundamental
concepts and patterns to help you manage your data's lifecycle.

Here's a quick overview of the recommendations on this page:

  1. Fetch data on the server using Server Components.
  2. Fetch data in parallel to minimize waterfalls and reduce loading times.
  3. For Layouts and Pages, fetch data where it's used. Next.js will automatically dedupe requests in a tree.
  4. Use Loading UI, Streaming and Suspense to progressively render a page and show a result to the user while the rest of the content loads.

The new data fetching system is built on top of the native `fetch()` Web API
and makes use of `async` and `await` in Server Components.

Learn how to use `fetch` in Next.js.

Whenever possible, we recommend fetching data in Server Components. Server
Components **always fetch data on the server**. This allows you to:

  * Have direct access to backend data resources (e.g. databases).
  * Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.
  * Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.
  * Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.
  * Reduce client-server waterfalls.
  * Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

> **Good to know:** It's still possible to fetch data client-side. We
> recommend using a third-party library such as SWR or React Query with Client
> Components. In the future, it'll also be possible to fetch data in Client
> Components using React's `use()` hook.

In the App Router, you can fetch data inside layouts, pages, and components.
Data fetching is also compatible with Streaming and Suspense.

> **Good to know:** For layouts, it's not possible to pass data between a
> parent layout and its `children` components. We recommend **fetching data
> directly inside the layout that needs it** , even if you're requesting the
> same data multiple times in a route. Behind the scenes, React and Next.js
> will cache and dedupe requests to avoid the same data being fetched more
> than once.

When fetching data inside components, you need to be aware of two data
fetching patterns: Parallel and Sequential.

![Sequential and Parallel Data
Fetching](/_next/image?url=%2Fdocs%2Flight%2Fsequential-parallel-data-
fetching.png&w=3840&q=75)![Sequential and Parallel Data
Fetching](/_next/image?url=%2Fdocs%2Fdark%2Fsequential-parallel-data-
fetching.png&w=3840&q=75)

  * With **parallel data fetching** , requests in a route are eagerly initiated and will load data at the same time. This reduces client-server waterfalls and the total time it takes to load data.
  * With **sequential data fetching** , requests in a route are dependent on each other and create waterfalls. There may be cases where you want this pattern because one fetch depends on the result of the other, or you want a condition to be satisfied before the next fetch to save resources. However, this behavior can also be unintentional and lead to longer loading times.

Learn how to implement parallel and sequential data fetching.

If you need to fetch the same data (e.g. current user) in multiple components
in a tree, Next.js will automatically cache `fetch` requests (`GET`) that have
the same input in a temporary cache. This optimization prevents the same data
from being fetched more than once during a rendering pass.

![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Flight%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)![Fetch Request
Deduplication](/_next/image?url=%2Fdocs%2Fdark%2Fdeduplicated-fetch-
requests.png&w=3840&q=75)

  * On the server, the cache lasts the lifetime of a server request until the rendering process completes. 
    * This optimization applies to `fetch` requests made in Layouts, Pages, Server Components, `generateMetadata` and `generateStaticParams`.
    * This optimization also applies during static generation.
  * On the client, the cache lasts the duration of a session (which could include multiple client-side re-renders) before a full page reload.

> **Good to know:**
>
>   * `POST` requests are not automatically deduplicated. Learn more about
> caching.
>   * If you're unable to use `fetch`, React provides a `cache` function to
> allow you to manually cache data for the duration of the request.
>

There are two types of data: **Static** and **Dynamic**.

  * **Static Data** is data that doesn't change often. For example, a blog post.
  * **Dynamic Data** is data that changes often or can be specific to users. For example, a shopping cart list.

![Dynamic and Static Data
Fetching](/_next/image?url=%2Fdocs%2Flight%2Fdynamic-and-static-data-
fetching.png&w=3840&q=75)![Dynamic and Static Data
Fetching](/_next/image?url=%2Fdocs%2Fdark%2Fdynamic-and-static-data-
fetching.png&w=3840&q=75)

By default, Next.js automatically does static fetches. This means that the
data will be fetched at build time, cached, and reused on each request. As a
developer, you have control over how the static data is cached and
revalidated.

There are two benefits to using static data:

  1. It reduces the load on your database by minimizing the number of requests made.
  2. The data is automatically cached for improved loading performance.

However, if your data is personalized to the user or you want to always fetch
the latest data, you can mark requests as _dynamic_ and fetch data on each
request without caching.

Learn how to do Static and Dynamic data fetching.

Caching is the process of storing data in a location (e.g. Content Delivery
Network) so it doesn't need to be re-fetched from the original source on each
request.

![Static Site Generation](/_next/image?url=%2Fdocs%2Flight%2Fstatic-site-
generation.png&w=3840&q=75)![Static Site
Generation](/_next/image?url=%2Fdocs%2Fdark%2Fstatic-site-
generation.png&w=3840&q=75)

The **Next.js Cache** is a persistent HTTP cache that can be globally
distributed. This means the cache can scale automatically and be shared across
multiple regions depending on your platform (e.g. Vercel).

Next.js extends the options object of the `fetch()` function to allow each
request on the server to set its own persistent caching behavior. Together
with component-level data fetching, this allows you to configure caching
within your application code directly where the data is being used.

During server rendering, when Next.js comes across a fetch, it will check the
cache to see if the data is already available. If it is, it will return the
cached data. If not, it will fetch and store data for future requests.

> **Good to know:** If you're unable to use `fetch`, React provides a `cache`
> function to allow you to manually cache data for the duration of the
> request.

Learn more about caching in Next.js.

Revalidation is the process of purging the cache and re-fetching the latest
data. This is useful when your data changes and you want to ensure your
application shows the latest version without having to rebuild your entire
application.

Next.js provides two types of revalidation:

  * **Background**: Revalidates the data at a specific time interval.
  * **On-demand**: Revalidates the data whenever there is an update.

Learn how to revalidate data.

Streaming and Suspense are new React features that allow you to progressively
render and incrementally stream rendered units of the UI to the client.

With Server Components and nested layouts, you're able to instantly render
parts of the page that do not specifically require data, and show a loading
state for parts of the page that are fetching data. This means the user does
not have to wait for the entire page to load before they can start interacting
with it.

![Server Rendering with Streaming](/_next/image?url=%2Fdocs%2Flight%2Fserver-
rendering-with-streaming.png&w=3840&q=75)![Server Rendering with
Streaming](/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-
streaming.png&w=3840&q=75)

To learn more about Streaming and Suspense, see the Loading UI and Streaming
and Suspense pages.

Previous Next.js data fetching methods such as `getServerSideProps`,
`getStaticProps`, and `getInitialProps` are **not** supported in the new App
Router. However, you can still use them in the Pages Router.

Now that you understand the fundamentals of data fetching in Next.js, you can
learn more about managing data in your application:





Using App Router

Features available in /app





# Optimizations

Next.js comes with a variety of built-in optimizations designed to improve
your application's speed and Core Web Vitals. This guide will cover the
optimizations you can leverage to enhance your user experience.

Built-in components abstract away the complexity of implementing common UI
optimizations. These components are:

  * **Images** : Built on the native `<img>` element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.
  * **Link** : Built on the native `<a>` tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.
  * **Scripts** : Built on the native `<script>` tags. The Script Component gives you control over loading and execution of third-party scripts.

Metadata helps search engines understand your content better (which can result
in better SEO), and allows you to customize how your content is presented on
social media, helping you create a more engaging and consistent user
experience across various platforms.

The Metadata API in Next.js allows you to modify the `<head>` element of a
page. You can configure metadata in two ways:

  * **Config-based Metadata** : Export a static metadata object or a dynamic generateMetadata function in a `layout.js` or `page.js` file.
  * **File-based Metadata** : Add static or dynamically generated special files to route segments.

Additionally, you can create dynamic Open Graph Images using JSX and CSS with
imageResponse constructor.

Next.js `/public` folder can be used to serve static assets like images,
fonts, and other files. Files inside `/public` can also be cached by CDN
providers so that they are delivered efficiently.

For large applications, Next.js integrates with popular analytics and
monitoring tools to help you understand how your application is performing.
Learn more in the , OpenTelemetry, and Instrumentation guides.





# TypeScript

Next.js provides a TypeScript-first development experience for building your
React application.

It comes with built-in TypeScript support for automatically installing the
necessary packages and configuring the proper settings.

As well as a TypeScript Plugin for your editor.

> **🎥 Watch:** Learn about the built-in TypeScript plugin → YouTube (3
> minutes)

`create-next-app` now ships with TypeScript by default.

    
    
    npx create-next-app@latest

Add TypeScript to your project by renaming a file to `.ts` / `.tsx`. Run `next
dev` and `next build` to automatically install the necessary dependencies and
add a `tsconfig.json` file with the recommended config options.

Next.js includes a custom TypeScript plugin and type checker, which VSCode and
other code editors can use for advanced type-checking and auto-completion.

The first time you run `next dev` with a TypeScript file open, you will
receive a prompt to enable the plugin.

![TypeScript Prompt](/_next/image?url=%2Fdocs%2Flight%2Ftypescript-
prompt.png&w=3840&q=75)![TypeScript
Prompt](/_next/image?url=%2Fdocs%2Fdark%2Ftypescript-prompt.png&w=3840&q=75)

If you miss the prompt, you can enable the plugin manually by:

  1. Opening the command palette (`Ctrl/⌘` \+ `Shift` \+ `P`)
  2. Searching for "TypeScript: Select TypeScript Version"
  3. Selecting "Use Workspace Version"

![TypeScript Command Palette](/_next/image?url=%2Fdocs%2Flight%2Ftypescript-
command-palette.png&w=3840&q=75)![TypeScript Command
Palette](/_next/image?url=%2Fdocs%2Fdark%2Ftypescript-command-
palette.png&w=3840&q=75)

Now, when editing files, the custom plugin will be enabled. When running `next
build`, the custom type checker will be used. Further, we automatically create
a VSCode settings file for you to automate this process.

The TypeScript plugin can help with:

  * Warning if the invalid values for segment config options are passed.
  * Showing available options and in-context documentation.
  * Ensuring the `use client` directive is used correctly.
  * Ensuring client hooks (like `useState`) are only used in Client Components.

> **Note:** More features will be added in the future.

It is highly recommended to be on at least `v4.5.2` of TypeScript to get
syntax features such as type modifiers on import names and performance
improvements.

Next.js can statically type links to prevent typos and other errors when using
`next/link`, improving type safety when navigating between pages.

To opt-into this feature, `experimental.typedRoutes` need to be enabled and
the project needs to be using TypeScript.

    
    
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        typedRoutes: true,
      },
    };
     
    module.exports = nextConfig;

Next.js will generate a link definition in `.next/types` that contains
information about all existing routes in your application, which TypeScript
can then use to provide feedback in your editor about invalid links.

Currently, experimental support includes any string literal, including dynamic
segments. For non-literal strings, you currently need to manually cast the
`href` with `as Route`:

    
    
    import type { Route } from 'next';
    import Link from 'next/link'
     
    // No TypeScript errors if href is a valid route
    <Link href="/about" />
    <Link href="/blog/nextjs" />
    <Link href={`/blog/${slug}`} />
    <Link href={('/blog' + slug) as Route} />
     
    // TypeScript errors if href is not a valid route
    <Link href="/aboot" />

To accept `href` in a custom component wrapping `next/link`, use a generic:

    
    
    import type { Route } from 'next';
    import Link from 'next/link';
     
    function Card<T extends string>({ href }: { href: Route<T> | URL })
      return (
        <Link href={href}>
          <div>My Card</div>
        </Link>
      );
    }

> **How does it work?**
>
> When running `next dev` or `next build`, Next.js generates a hidden `.d.ts`
> file inside `.next` that contains information about all existing routes in
> your application (all valid routes as the `href` type of `Link`). This
> `.d.ts` file is included in `tsconfig.json` and the TypeScript compiler will
> check that `.d.ts` and provide feedback in your editor about invalid links.

Next.js 13 has **enhanced type safety**. This includes:

  1. **No serialization of data between fetching function and page** : You can `fetch` directly in components, layouts, and pages on the server. This data _does not_ need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since `app` uses Server Components by default, we can use values like `Date`, `Map`, `Set`, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.
  2. **Streamlined data flow between components** : With the removal of `_app` in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previous, data flowing between individual `pages` and `_app` were difficult to type and could introduce confusing bugs. With colocated data fetching in Next.js 13, this is no longer an issue.

Data Fetching in Next.js now provides as close to end-to-end type safety as
possible without being prescriptive about your database or content provider
selection.

We're able to type the response data as you would expect with normal
TypeScript. For example:

    
    
    async function getData() {
      const res = await fetch('https://api.example.com/...');
      // The return value is *not* serialized
      // You can return Date, Map, Set, etc.
      return res.json();
    }
     
    export default async function Page() {
      const name = await getData();
     
      return '...';
    }

For _complete_ end-to-end type safety, this also requires your database or
content provider to support TypeScript. This could be through using an ORM or
type-safe query builder.

  * An `async` Server Components will cause a `'Promise<Element>' is not a valid JSX element` type error where it is used.
  * This is a known issue with TypeScript and is being worked on upstream.
  * As a temporary workaround, you can add `{/* @ts-expect-error Async Server Component */}` above the component to disable type checking for it.

    
    
    import { ExampleAsyncComponent } from './ExampleAsyncComponent';
    export default function Page() {
      return (
        <>
          {/* @ts-expect-error Async Server Component */}
          <ExampleAsyncComponent />
        </>
      );
    }

  * This does not apply to Layout and Page components.
  * We are tracking this issue here. This will likely be fixed in TypeScript 5.1 (Stable).

When passing data between a Server and Client Component through props, the
data is still serialized (converted to a string) for use in the browser.
However, it does not need a special type. It’s typed the same as passing any
other props between components.

Further, there is less code to be serialized, as un-rendered data does not
cross between the server and client (it remains on the server). This is only
now possible through support for Server Components.

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"`
options.

You can learn more about this feature on the Module Path aliases
documentation.

The `next.config.js` file must be a JavaScript file as it does not get parsed
by Babel or TypeScript, however you can add some type checking in your IDE
using JSDoc as below:

    
    
    // @ts-check
     
    /**
     * @type {import('next').NextConfig}
     **/
    const nextConfig = {
      /* config options here */
    };
     
    module.exports = nextConfig;

Since `v10.2.1` Next.js supports incremental type checking when enabled in
your `tsconfig.json`, this can help speed up type checking in larger
applications.

Next.js fails your **production build** (`next build`) when TypeScript errors
are present in your project.

If you'd like Next.js to dangerously produce production code even when your
application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or
deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the
`typescript` config:

    
    
    module.exports = {
      typescript: {
        // !! WARN !!
        // Dangerously allow production builds to successfully complete even if
        // your project has type errors.
        // !! WARN !!
        ignoreBuildErrors: true,
      },
    };

Version| Changes  
---|---  
`v13.2.0`| Statically typed links are available in beta  
`v12.0.0`| SWC is now used by default to compile TypeScript and TSX for faster
builds.  
`v10.2.1`| Incremental type checking support added when enabled in your
`tsconfig.json`.





Using App Router

Features available in /app





# Installation

System Requirements:

  * Node.js 16.8 or later.
  * macOS, Windows (including WSL), and Linux are supported.

We recommend creating a new Next.js app using `create-next-app`, which sets up
everything automatically for you. To create a project, run:

    
    
    npx create-next-app@latest

On installation, you'll see the following prompts:

    
    
    What is your project named? my-app
    Would you like to use TypeScript with this project? No / Yes
    Would you like to use ESLint with this project? No / Yes
    Would you like to use Tailwind CSS with this project? No / Yes
    Would you like to use `src/` directory with this project? No / Yes
    Use App Router (recommended)? No / Yes
    Would you like to customize the default import alias? No / Yes

Next.js now ships with TypeScript, ESLint, and Tailwind CSS configuration by
default. You can also choose to use the `src` directory for your application
code.

After the prompts, `create-next-app` will create a folder with your project
name and install the required dependencies.

> **Note:** While you can use the Pages Router in your new project. We
> recommend starting new applications with the App Router to leverage React's
> latest features.

To manually create a new Next.js app, install the required packages:

    
    
    npm install next@latest react@latest react-dom@latest

Open `package.json` and add the following `scripts`:

    
    
    {
      "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "next lint"
      }
    }

These scripts refer to the different stages of developing an application:

  * `dev`: runs `next dev` to start Next.js in development mode.
  * `build`: runs `next build` to build the application for production usage.
  * `start`: runs `next start` to start a Next.js production server.
  * `lint`: runs `next lint` to set up Next.js' built-in ESLint configuration.

Next, create an `app` folder and add a `layout.tsx` and `page.tsx` file. These
will be rendered when the user visits the root of your application.

![App Folder Structure](/_next/image?url=%2Fdocs%2Flight%2Fapp-getting-
started.png&w=3840&q=75)![App Folder
Structure](/_next/image?url=%2Fdocs%2Fdark%2Fapp-getting-
started.png&w=3840&q=75)

Create a root layout inside `app/layout.tsx` with the required `<html>` and
`<body>` tags:

    
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>{children}</body>
        </html>
      );
    }

Finally, create a home page `app/page.tsx` with some initial content:

    
    
    export default function Page() {
      return <h1>Hello, Next.js!</h1>;
    }

> **Good to know** : If you forget to create `layout.tsx`, Next.js will
> automatically create this file for you when running the development server
> with `next dev`.

You can optionally create a `public` folder to store static assets such as
images, fonts, etc. Files inside `public` directory can then be referenced by
your code starting from the base URL (`/`).

  1. Run `npm run dev` to start the development server.
  2. Visit `http://localhost:3000` to view your application.
  3. Edit `app/layout.tsx` or `app/page.tsx` and save to see the updated result in your browser.





# React Essentials

To build applications with Next.js, it helps to be familiar with React's newer
features such as Server Components. This page will go through the differences
between Server and Client Components, when to use them, and recommended
patterns.

If you're new to React, we also recommend referring to the React Docs. Here
are some great resources for learning:

Server and Client Components allow developers to build applications that span
the server and client, combining the rich interactivity of client-side apps
with the improved performance of traditional server rendering.

Similar to how React changed the way we think about building UIs, React Server
Components introduce a new mental model for building hybrid applications that
leverage the server and the client.

Instead of React rendering your whole application client-side (such as in the
case of Single-Page Applications), React now gives you the flexibility to
choose where to render your components based on their purpose.

For example, consider a page in your application:

![Thinking in Server Components](/_next/image?url=%2Fdocs%2Flight%2Fthinking-
in-server-components.png&w=3840&q=75)![Thinking in Server
Components](/_next/image?url=%2Fdocs%2Fdark%2Fthinking-in-server-
components.png&w=3840&q=75)

If we were to split the page into smaller components, you'll notice that the
majority of components are non-interactive and can be rendered on the server
as Server Components. For smaller pieces of interactive UI, we can _sprinkle
in_ Client Components. This aligns with Next.js server-first approach.

So, you may be thinking, why Server Components? What are the advantages of
using them over Client Components?

Server Components allow developers to better leverage server infrastructure.
For example, you can move data fetching to the server, closer to your
database, and keep large dependencies that previously would impact the client
JavaScript bundle size on the server, leading to improved performance. Server
Components make writing a React application feel similar to PHP or Ruby on
Rails, but with the power and flexibility of React and the components model
for templating UI.

With Server Components, the initial page load is faster, and the client-side
JavaScript bundle size is reduced. The base client-side runtime is
**cacheable** and **predictable** in size, and does _not_ increase as your
application grows. Additional JavaScript is _only added_ as client-side
interactivity is used in your application through Client Components.

When a route is loaded with Next.js, the initial HTML is rendered on the
server. This HTML is then **progressively enhanced** in the browser, allowing
the client to take over the application and add interactivity, by
asynchronously loading the Next.js and React client-side runtime.

To make the transition to Server Components easier, all components inside the
App Router are Server Components by default, including special files and
colocated components. This allows you to automatically adopt them with no
extra work, and achieve great performance out of the box. You can also
optionally opt-in to Client Components using the 'use client' directive.

Client Components enable you to add client-side interactivity to your
application. In Next.js, they are pre-rendered on the server and hydrated on
the client. You can think of Client Components as how components in the Pages
Router have always worked.

The `"use client"` directive is a convention to declare a boundary between a
Server and Client Component module graph.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function Counter() {
      const [count, setCount] = useState(0);
     
      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>Click me</button>
        </div>
      );
    }

![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Flight%2Fuse-client-
directive.png&w=3840&q=75)![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Fdark%2Fuse-client-
directive.png&w=3840&q=75)

`"use client"` _sits_ between server-only and client code. It's placed at the
top of a file, above imports, to define the _cut-off_ point where it crosses
the boundary from the server-only to the client part. Once `"use client"` is
defined in a file, all other modules imported into it, including child
components, are considered part of the client bundle.

Since Server Components are the default, all components are part of the Server
Component module graph unless defined or imported in a module that starts with
the `"use client"` directive.

> **Good to know:**
>
>   * Components in the Server Component module graph are guaranteed to be
> only rendered on the server.
>   * Components in the Client Component module graph are primarily rendered
> on the client, but with Next.js, they can also be pre-rendered on the server
> and hydrated on the client.
>   * The `"use client"` directive must be defined at the **top of a file**
> before any imports.
>   * `"use client"` does **not** need to be defined in every file. The Client
> module boundary only needs to be defined once, at the "entry point", for all
> modules imported into it to be considered a Client Component.
>

To simplify the decision between Server and Client Components, we recommend
using Server Components (default in the `app` directory) until you have a use
case for a Client Component.

This table summarizes the different use cases for Server and Client
Components:

What do you need to do?| Server Component| Client Component  
---|---|---  
Fetch data.| |  
Access backend resources (directly)| |  
Keep sensitive information on the server (access tokens, API keys, etc)| |  
Keep large dependencies on the server / Reduce client-side JavaScript| |  
Add interactivity and event listeners (`onClick()`, `onChange()`, etc)| |  
Use State and Lifecycle Effects (`useState()`, `useReducer()`, `useEffect()`,
etc)| |  
Use browser-only APIs| |  
Use custom hooks that depend on state, effects, or browser-only APIs| |  
Use React Class components| |  
  
To improve the performance of your application, we recommend moving Client
Components to the leaves of your component tree where possible.

For example, you may have a Layout that has static elements (e.g. logo, links,
etc) and an interactive search bar that uses state.

Instead of making the whole layout a Client Component, move the interactive
logic to a Client Component (e.g. `<SearchBar />`) and keep your layout as a
Server Component. This means you don't have to send all the component
Javascript of the layout to the client.

    
    
    // SearchBar is a Client Component
    import SearchBar from './searchbar';
    // Logo is a Server Component
    import Logo from './logo';
     
    // Layout is a Server Component by default
    export default function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <>
          <nav>
            <Logo />
            <SearchBar />
          </nav>
          <main>{children}</main>
        </>
      );
    }

Server and Client Components can be combined in the same component tree.

Behind the scenes, React handles rendering as follows:

  * On the server, React renders **all** Server Components **before** sending the result to the client. 
    * This includes Server Components nested inside Client Components.
    * Client Components encountered during this stage are skipped.
  * On the client, React renders Client Components and _slots in_ the rendered result of Server Components, merging the work done on the server and client. 
    * If any Server Components are nested inside a Client Component, their rendered content will be placed correctly within the Client Component.

> **Good to know:** In Next.js, during the initial page load, both the
> rendered result of Server Components from the above step and Client
> Components are pre-rendered on the server as HTML to produce a faster
> initial page load.

Given the rendering flow outlined above, there is a restriction around
importing a Server Component into a Client Component, as this approach would
require an additional server round trip.

The following pattern is not supported. You cannot import a Server Component
into a Client Component:

    
    
    'use client';
     
    // This pattern will **not** work!
    // You cannot import a Server Component into a Client Component.
    import ExampleServerComponent from './example-server-component';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          <ExampleServerComponent />
        </>
      );
    }

Instead, when designing Client Components you can use React props to mark
_"holes"_ for Server Components.

The Server Component will be rendered on the server, and when the Client
Component is rendered on the client, the _"hole"_ will be filled in with the
rendered result of the Server Component.

A common pattern is to use the React `children` prop to create the _"hole"_.
We can refactor `<ExampleClientComponent>` to accept a generic `children` prop
and move the import and explicit nesting of `<ExampleClientComponent>` up to a
parent component.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          {children}
        </>
      );
    }

Now, `<ExampleClientComponent>` has no knowledge of what `children` is.
Infact, from its perspective it doesn't even know that `children` will
eventually be filled in by the result of a Server Component.

The only responsibility `ExampleClientComponent` has is to decide where
whatever `children` will eventually be should be placed.

In a parent Server Component, you can import both the
`<ExampleClientComponent>` and `<ExampleServerComponent>` and pass
`<ExampleServerComponent>` as a child of `<ExampleClientComponent>`:

    
    
    // This pattern works:
    // You can pass a Server Component as a child or prop of a
    // Client Component.
    import ExampleClientComponent from './example-client-component';
    import ExampleServerComponent from './example-server-component';
     
    // Pages in Next.js are Server Components by default
    export default function Page() {
      return (
        <ExampleClientComponent>
          <ExampleServerComponent />
        </ExampleClientComponent>
      );
    }

With this approach, the rendering of `<ExampleClientComponent>` and
`<ExampleServerComponent>` are decoupled and can be rendered independently -
aligning with Server Components, which are rendered on the server before
Client Components.

> **Good to know**
>
>   * This pattern is **already applied** in layouts and pages with the
> `children` prop so you don't have to create an additional wrapper component.
>   * Passing React components (JSX) to other components is not a new concept
> and has always been part of the React composition model.
>   * This composition strategy works across Server and Client Components
> because the component that receives the prop has no knowledge of **what**
> the prop is. It is only responsible for where the thing that it is passed
> should be placed.
>     * This allows the passed prop to be rendered independently, in this
> case, on the server, well before the Client Component is rendered on the
> client.
>     * The very same strategy of "lifting content up" has been used to avoid
> state changes in a parent component re-rendering an imported nested child
> component.
>   * You're not limited to the `children` prop. You can use any prop to pass
> JSX.
>

Props passed from the Server to Client Components need to be serializable.
This means that values such as functions, Dates, etc, cannot be passed
directly to Client Components.

> **Where is the Network Boundary?**
>
> In the App Router, the network boundary is between Server Components and
> Client Components. This is different from the Pages where the boundary is
> between `getStaticProps`/`getServerSideProps` and Page Components. Data
> fetched inside Server Components do not need to be serialized as it doesn't
> cross the network boundary unless it is passed to a Client Component. Learn
> more about data fetching with Server Components.

Since JavaScript modules can be shared between both Server and Client
Components, it's possible for code that was only ever intended to be run on
the server to sneak its way into the client.

For example, take the following data-fetching function:

    
    
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

At first glance, it appears that `getData` works on both the server and the
client. But because the environment variable `API_KEY` is not prefixed with
`NEXT_PUBLIC`, it's a private variable that can only be accessed on the
server. Next.js replaces private environment variables with the empty string
in client code to prevent leaking secure information.

As a result, even though `getData()` can be imported and executed on the
client, it won't work as expected. And while making the variable public would
make the function work on the client, it would leak sensitive information.

So, this function was written with the intention that it would only ever be
executed on the server.

To prevent this sort of unintended client usage of server code, we can use the
`server-only` package to give other developers a build-time error if they ever
accidentally import one of these modules into a Client Component.

To use `server-only`, first install the package:

Then import the package into any module that contains server-only code:

    
    
    import 'server-only';
     
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

Now, any Client Component that imports `getData()` will receive a build-time
error explaining that this module can only be used on the server.

The corresponding package `client-only` can be used to mark modules that
contain client-only code – for example, code that accesses the `window`
object.

Although it's possible to fetch data in Client Components, we recommend
fetching data in Server Components unless you have a specific reason for
fetching data on the client. Moving data fetching to the server leads to
better performance and user experience.

Learn more about data fetching.

Since Server Components are new, third-party packages in the ecosystem are
just beginning to add the `"use client"` directive to components that use
client-only features like `useState`, `useEffect`, and `createContext`.

Today, many components from `npm` packages that use client-only features do
not yet have the directive. These third-party components will work as expected
within your own Client Components since they have the `"use client"`
directive, but they won't work within Server Components.

For example, let's say you've installed the hypothetical `acme-carousel`
package which has an `<Carousel />` component. This component uses `useState`,
but it doesn't yet have the `"use client"` directive.

If you use `<Carousel />` within a Client Component, it will work as expected:

    
    
    'use client';
     
    import { useState } from 'react';
    import { Carousel } from 'acme-carousel';
     
    export default function Gallery() {
      let [isOpen, setIsOpen] = useState(false);
     
      return (
        <div>
          <button onClick={() => setIsOpen(true)}>View pictures</button>
     
          {/* Works, since Carousel is used within a Client Component */}
          {isOpen && <Carousel />}
        </div>
      );
    }

However, if you try to use it directly within a Server Component, you'll see
an error:

    
    
    import { Carousel } from 'acme-carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/* Error: `useState` can not be used within Server Components */}
          <Carousel />
        </div>
      );
    }

This is because Next.js doesn't know `<Carousel />` is using client-only
features.

To fix this, you can wrap third-party components that rely on client-only
features in your own Client Components:

    
    
    'use client';
     
    import { Carousel } from 'acme-carousel';
     
    export default Carousel;

Now, you can use `<Carousel />` directly within a Server Component:

    
    
    import Carousel from './carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/*  Works, since Carousel is a Client Component */}
          <Carousel />
        </div>
      );
    }

We don't expect you to need to wrap most third-party components since it's
likely you'll be using them within Client Components. However, one exception
is provider components, since they rely on React state and context, and are
typically needed at the root of an application. Learn more about third-party
context providers below.

  * In a similar fashion, library authors creating packages to be consumed by other developers can use the `"use client"` directive to mark client entry points of their package. This allows users of the package to import package components directly into their Server Components without having to create a wrapping boundary.
  * You can optimize your package by using 'use client' deeper in the tree, allowing the imported modules to be part of the Server Component module graph.
  * It's worth noting some bundlers might strip out `"use client"` directives. You can find an example of how to configure esbuild to include the `"use client"` directive in the React Wrap Balancer and Vercel Analytics repositories.

Most React applications rely on context to share data between components,
either directly via `createContext`, or indirectly via provider components
imported from third-party libraries.

In Next.js 13, context is fully supported within Client Components, but it
**cannot** be created or consumed directly within Server Components. This is
because Server Components have no React state (since they're not interactive),
and context is primarily used for rerendering interactive components deep in
the tree after some React state has been updated.

We'll discuss alternatives for sharing data between Server Components, but
first, let's take a look at how to use context within Client Components.

All of the context APIs are fully supported within Client Components:

    
    
    'use client';
     
    import { createContext, useContext, useState } from 'react';
     
    const SidebarContext = createContext();
     
    export function Sidebar() {
      const [isOpen, setIsOpen] = useState();
     
      return (
        <SidebarContext.Provider value={{ isOpen }}>
          <SidebarNav />
        </SidebarContext.Provider>
      );
    }
     
    function SidebarNav() {
      let { isOpen } = useContext(SidebarContext);
     
      return (
        <div>
          <p>Home</p>
     
          {isOpen && <Subnav />}
        </div>
      );
    }

However, context providers are typically rendered near the root of an
application to share global concerns, like the current theme. Because context
is not supported in Server Components, trying to create a context at the root
of your application will cause an error:

    
    
    import { createContext } from 'react';
     
    //  createContext is not supported in Server Components
    export const ThemeContext = createContext({});
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
          </body>
        </html>
      );
    }

To fix this, create your context and render its provider inside of a Client
Component:

    
    
    'use client';
     
    import { createContext } from 'react';
     
    export const ThemeContext = createContext({});
     
    export default function ThemeProvider({ children }) {
      return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>;
    }

Your Server Component will now be able to directly render your provider since
it's been marked as a Client Component:

    
    
    import ThemeProvider from './theme-provider';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html>
          <body>
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

With the provider rendered at the root, all other Client Components throughout
your app will be able to consume this context.

> Note: You should render providers as deep as possible in the tree – notice
> how `ThemeProvider` only wraps `{children}` instead of the entire `<html>`
> document. This makes it easier for Next.js to optimize the static parts of
> your Server Components.

Third-party npm packages often include Providers that need to be rendered near
the root of your application. If these providers include the `"use client"`
directive, they can be rendered directly inside of your Server Components.
However, since Server Components are so new, many third-party providers won't
have added the directive yet.

If you try to render a third-party provider that doesn't have `"use client"`,
it will cause an error:

    
    
    import { ThemeProvider } from 'acme-theme';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            {/*  Error: `createContext` can't be used in Server Components */}
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

To fix this, wrap third-party providers in your own Client Component:

    
    
    'use client';
     
    import { ThemeProvider } from 'acme-theme';
    import { AuthProvider } from 'acme-auth';
     
    export function Providers({ children }) {
      return (
        <ThemeProvider>
          <AuthProvider>{children}</AuthProvider>
        </ThemeProvider>
      );
    }

Now, you can import and render `<Providers />` directly within your root
layout.

    
    
    import { Providers } from './providers';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }

With the providers rendered at the root, all the components and hooks from
these libraries will work as expected within your own Client Components.

Once a third-party library has added `"use client"` to its client code, you'll
be able to remove the wrapper Client Component.

Since Server Components are not interactive and therefore do not read from
React state, you don't need React context to share data. Instead, you can use
native JavaScript patterns for common data that multiple Server Components
need to access. For example, a module can be used to share a database
connection across multiple components:

    
    
    export const db = new DatabaseConnection();
    
    
    import { db } from '@utils/database';
     
    export async function UsersLayout() {
      let users = await db.query();
      // ...
    }
    
    
    import { db } from '@utils/database';
     
    export async function DashboardPage() {
      let user = await db.query();
      // ...
    }

In the above example, both the layout and page need to make database queries.
Each of these components shares access to the database by importing the
`@utils/database` module. This JavaScript pattern is called global singletons.

When fetching data, you may want to share the result of a `fetch` between a
`page` or `layout` and some of its children components. This is an unnecessary
coupling between the components and can lead to passing `props` back and forth
between components.

Instead, we recommend colocating data fetching alongside the component that
consumes the data. `fetch` requests are automatically deduped in Server
Components, so each route segment can request exactly the data it needs
without worrying about duplicate requests. Next.js will read the same value
from the `fetch` cache.





# React Essentials

To build applications with Next.js, it helps to be familiar with React's newer
features such as Server Components. This page will go through the differences
between Server and Client Components, when to use them, and recommended
patterns.

If you're new to React, we also recommend referring to the React Docs. Here
are some great resources for learning:

Server and Client Components allow developers to build applications that span
the server and client, combining the rich interactivity of client-side apps
with the improved performance of traditional server rendering.

Similar to how React changed the way we think about building UIs, React Server
Components introduce a new mental model for building hybrid applications that
leverage the server and the client.

Instead of React rendering your whole application client-side (such as in the
case of Single-Page Applications), React now gives you the flexibility to
choose where to render your components based on their purpose.

For example, consider a page in your application:

![Thinking in Server Components](/_next/image?url=%2Fdocs%2Flight%2Fthinking-
in-server-components.png&w=3840&q=75)![Thinking in Server
Components](/_next/image?url=%2Fdocs%2Fdark%2Fthinking-in-server-
components.png&w=3840&q=75)

If we were to split the page into smaller components, you'll notice that the
majority of components are non-interactive and can be rendered on the server
as Server Components. For smaller pieces of interactive UI, we can _sprinkle
in_ Client Components. This aligns with Next.js server-first approach.

So, you may be thinking, why Server Components? What are the advantages of
using them over Client Components?

Server Components allow developers to better leverage server infrastructure.
For example, you can move data fetching to the server, closer to your
database, and keep large dependencies that previously would impact the client
JavaScript bundle size on the server, leading to improved performance. Server
Components make writing a React application feel similar to PHP or Ruby on
Rails, but with the power and flexibility of React and the components model
for templating UI.

With Server Components, the initial page load is faster, and the client-side
JavaScript bundle size is reduced. The base client-side runtime is
**cacheable** and **predictable** in size, and does _not_ increase as your
application grows. Additional JavaScript is _only added_ as client-side
interactivity is used in your application through Client Components.

When a route is loaded with Next.js, the initial HTML is rendered on the
server. This HTML is then **progressively enhanced** in the browser, allowing
the client to take over the application and add interactivity, by
asynchronously loading the Next.js and React client-side runtime.

To make the transition to Server Components easier, all components inside the
App Router are Server Components by default, including special files and
colocated components. This allows you to automatically adopt them with no
extra work, and achieve great performance out of the box. You can also
optionally opt-in to Client Components using the 'use client' directive.

Client Components enable you to add client-side interactivity to your
application. In Next.js, they are pre-rendered on the server and hydrated on
the client. You can think of Client Components as how components in the Pages
Router have always worked.

The `"use client"` directive is a convention to declare a boundary between a
Server and Client Component module graph.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function Counter() {
      const [count, setCount] = useState(0);
     
      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>Click me</button>
        </div>
      );
    }

![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Flight%2Fuse-client-
directive.png&w=3840&q=75)![Use Client Directive and Network
Boundary](/_next/image?url=%2Fdocs%2Fdark%2Fuse-client-
directive.png&w=3840&q=75)

`"use client"` _sits_ between server-only and client code. It's placed at the
top of a file, above imports, to define the _cut-off_ point where it crosses
the boundary from the server-only to the client part. Once `"use client"` is
defined in a file, all other modules imported into it, including child
components, are considered part of the client bundle.

Since Server Components are the default, all components are part of the Server
Component module graph unless defined or imported in a module that starts with
the `"use client"` directive.

> **Good to know:**
>
>   * Components in the Server Component module graph are guaranteed to be
> only rendered on the server.
>   * Components in the Client Component module graph are primarily rendered
> on the client, but with Next.js, they can also be pre-rendered on the server
> and hydrated on the client.
>   * The `"use client"` directive must be defined at the **top of a file**
> before any imports.
>   * `"use client"` does **not** need to be defined in every file. The Client
> module boundary only needs to be defined once, at the "entry point", for all
> modules imported into it to be considered a Client Component.
>

To simplify the decision between Server and Client Components, we recommend
using Server Components (default in the `app` directory) until you have a use
case for a Client Component.

This table summarizes the different use cases for Server and Client
Components:

What do you need to do?| Server Component| Client Component  
---|---|---  
Fetch data.| |  
Access backend resources (directly)| |  
Keep sensitive information on the server (access tokens, API keys, etc)| |  
Keep large dependencies on the server / Reduce client-side JavaScript| |  
Add interactivity and event listeners (`onClick()`, `onChange()`, etc)| |  
Use State and Lifecycle Effects (`useState()`, `useReducer()`, `useEffect()`,
etc)| |  
Use browser-only APIs| |  
Use custom hooks that depend on state, effects, or browser-only APIs| |  
Use React Class components| |  
  
To improve the performance of your application, we recommend moving Client
Components to the leaves of your component tree where possible.

For example, you may have a Layout that has static elements (e.g. logo, links,
etc) and an interactive search bar that uses state.

Instead of making the whole layout a Client Component, move the interactive
logic to a Client Component (e.g. `<SearchBar />`) and keep your layout as a
Server Component. This means you don't have to send all the component
Javascript of the layout to the client.

    
    
    // SearchBar is a Client Component
    import SearchBar from './searchbar';
    // Logo is a Server Component
    import Logo from './logo';
     
    // Layout is a Server Component by default
    export default function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <>
          <nav>
            <Logo />
            <SearchBar />
          </nav>
          <main>{children}</main>
        </>
      );
    }

Server and Client Components can be combined in the same component tree.

Behind the scenes, React handles rendering as follows:

  * On the server, React renders **all** Server Components **before** sending the result to the client. 
    * This includes Server Components nested inside Client Components.
    * Client Components encountered during this stage are skipped.
  * On the client, React renders Client Components and _slots in_ the rendered result of Server Components, merging the work done on the server and client. 
    * If any Server Components are nested inside a Client Component, their rendered content will be placed correctly within the Client Component.

> **Good to know:** In Next.js, during the initial page load, both the
> rendered result of Server Components from the above step and Client
> Components are pre-rendered on the server as HTML to produce a faster
> initial page load.

Given the rendering flow outlined above, there is a restriction around
importing a Server Component into a Client Component, as this approach would
require an additional server round trip.

The following pattern is not supported. You cannot import a Server Component
into a Client Component:

    
    
    'use client';
     
    // This pattern will **not** work!
    // You cannot import a Server Component into a Client Component.
    import ExampleServerComponent from './example-server-component';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          <ExampleServerComponent />
        </>
      );
    }

Instead, when designing Client Components you can use React props to mark
_"holes"_ for Server Components.

The Server Component will be rendered on the server, and when the Client
Component is rendered on the client, the _"hole"_ will be filled in with the
rendered result of the Server Component.

A common pattern is to use the React `children` prop to create the _"hole"_.
We can refactor `<ExampleClientComponent>` to accept a generic `children` prop
and move the import and explicit nesting of `<ExampleClientComponent>` up to a
parent component.

    
    
    'use client';
     
    import { useState } from 'react';
     
    export default function ExampleClientComponent({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const [count, setCount] = useState(0);
     
      return (
        <>
          <button onClick={() => setCount(count + 1)}>{count}</button>
     
          {children}
        </>
      );
    }

Now, `<ExampleClientComponent>` has no knowledge of what `children` is.
Infact, from its perspective it doesn't even know that `children` will
eventually be filled in by the result of a Server Component.

The only responsibility `ExampleClientComponent` has is to decide where
whatever `children` will eventually be should be placed.

In a parent Server Component, you can import both the
`<ExampleClientComponent>` and `<ExampleServerComponent>` and pass
`<ExampleServerComponent>` as a child of `<ExampleClientComponent>`:

    
    
    // This pattern works:
    // You can pass a Server Component as a child or prop of a
    // Client Component.
    import ExampleClientComponent from './example-client-component';
    import ExampleServerComponent from './example-server-component';
     
    // Pages in Next.js are Server Components by default
    export default function Page() {
      return (
        <ExampleClientComponent>
          <ExampleServerComponent />
        </ExampleClientComponent>
      );
    }

With this approach, the rendering of `<ExampleClientComponent>` and
`<ExampleServerComponent>` are decoupled and can be rendered independently -
aligning with Server Components, which are rendered on the server before
Client Components.

> **Good to know**
>
>   * This pattern is **already applied** in layouts and pages with the
> `children` prop so you don't have to create an additional wrapper component.
>   * Passing React components (JSX) to other components is not a new concept
> and has always been part of the React composition model.
>   * This composition strategy works across Server and Client Components
> because the component that receives the prop has no knowledge of **what**
> the prop is. It is only responsible for where the thing that it is passed
> should be placed.
>     * This allows the passed prop to be rendered independently, in this
> case, on the server, well before the Client Component is rendered on the
> client.
>     * The very same strategy of "lifting content up" has been used to avoid
> state changes in a parent component re-rendering an imported nested child
> component.
>   * You're not limited to the `children` prop. You can use any prop to pass
> JSX.
>

Props passed from the Server to Client Components need to be serializable.
This means that values such as functions, Dates, etc, cannot be passed
directly to Client Components.

> **Where is the Network Boundary?**
>
> In the App Router, the network boundary is between Server Components and
> Client Components. This is different from the Pages where the boundary is
> between `getStaticProps`/`getServerSideProps` and Page Components. Data
> fetched inside Server Components do not need to be serialized as it doesn't
> cross the network boundary unless it is passed to a Client Component. Learn
> more about data fetching with Server Components.

Since JavaScript modules can be shared between both Server and Client
Components, it's possible for code that was only ever intended to be run on
the server to sneak its way into the client.

For example, take the following data-fetching function:

    
    
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

At first glance, it appears that `getData` works on both the server and the
client. But because the environment variable `API_KEY` is not prefixed with
`NEXT_PUBLIC`, it's a private variable that can only be accessed on the
server. Next.js replaces private environment variables with the empty string
in client code to prevent leaking secure information.

As a result, even though `getData()` can be imported and executed on the
client, it won't work as expected. And while making the variable public would
make the function work on the client, it would leak sensitive information.

So, this function was written with the intention that it would only ever be
executed on the server.

To prevent this sort of unintended client usage of server code, we can use the
`server-only` package to give other developers a build-time error if they ever
accidentally import one of these modules into a Client Component.

To use `server-only`, first install the package:

Then import the package into any module that contains server-only code:

    
    
    import 'server-only';
     
    export async function getData() {
      const res = await fetch('https://external-service.com/data', {
        headers: {
          authorization: process.env.API_KEY,
        },
      });
     
      return res.json();
    }

Now, any Client Component that imports `getData()` will receive a build-time
error explaining that this module can only be used on the server.

The corresponding package `client-only` can be used to mark modules that
contain client-only code – for example, code that accesses the `window`
object.

Although it's possible to fetch data in Client Components, we recommend
fetching data in Server Components unless you have a specific reason for
fetching data on the client. Moving data fetching to the server leads to
better performance and user experience.

Learn more about data fetching.

Since Server Components are new, third-party packages in the ecosystem are
just beginning to add the `"use client"` directive to components that use
client-only features like `useState`, `useEffect`, and `createContext`.

Today, many components from `npm` packages that use client-only features do
not yet have the directive. These third-party components will work as expected
within your own Client Components since they have the `"use client"`
directive, but they won't work within Server Components.

For example, let's say you've installed the hypothetical `acme-carousel`
package which has an `<Carousel />` component. This component uses `useState`,
but it doesn't yet have the `"use client"` directive.

If you use `<Carousel />` within a Client Component, it will work as expected:

    
    
    'use client';
     
    import { useState } from 'react';
    import { Carousel } from 'acme-carousel';
     
    export default function Gallery() {
      let [isOpen, setIsOpen] = useState(false);
     
      return (
        <div>
          <button onClick={() => setIsOpen(true)}>View pictures</button>
     
          {/* Works, since Carousel is used within a Client Component */}
          {isOpen && <Carousel />}
        </div>
      );
    }

However, if you try to use it directly within a Server Component, you'll see
an error:

    
    
    import { Carousel } from 'acme-carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/* Error: `useState` can not be used within Server Components */}
          <Carousel />
        </div>
      );
    }

This is because Next.js doesn't know `<Carousel />` is using client-only
features.

To fix this, you can wrap third-party components that rely on client-only
features in your own Client Components:

    
    
    'use client';
     
    import { Carousel } from 'acme-carousel';
     
    export default Carousel;

Now, you can use `<Carousel />` directly within a Server Component:

    
    
    import Carousel from './carousel';
     
    export default function Page() {
      return (
        <div>
          <p>View pictures</p>
     
          {/*  Works, since Carousel is a Client Component */}
          <Carousel />
        </div>
      );
    }

We don't expect you to need to wrap most third-party components since it's
likely you'll be using them within Client Components. However, one exception
is provider components, since they rely on React state and context, and are
typically needed at the root of an application. Learn more about third-party
context providers below.

  * In a similar fashion, library authors creating packages to be consumed by other developers can use the `"use client"` directive to mark client entry points of their package. This allows users of the package to import package components directly into their Server Components without having to create a wrapping boundary.
  * You can optimize your package by using 'use client' deeper in the tree, allowing the imported modules to be part of the Server Component module graph.
  * It's worth noting some bundlers might strip out `"use client"` directives. You can find an example of how to configure esbuild to include the `"use client"` directive in the React Wrap Balancer and Vercel Analytics repositories.

Most React applications rely on context to share data between components,
either directly via `createContext`, or indirectly via provider components
imported from third-party libraries.

In Next.js 13, context is fully supported within Client Components, but it
**cannot** be created or consumed directly within Server Components. This is
because Server Components have no React state (since they're not interactive),
and context is primarily used for rerendering interactive components deep in
the tree after some React state has been updated.

We'll discuss alternatives for sharing data between Server Components, but
first, let's take a look at how to use context within Client Components.

All of the context APIs are fully supported within Client Components:

    
    
    'use client';
     
    import { createContext, useContext, useState } from 'react';
     
    const SidebarContext = createContext();
     
    export function Sidebar() {
      const [isOpen, setIsOpen] = useState();
     
      return (
        <SidebarContext.Provider value={{ isOpen }}>
          <SidebarNav />
        </SidebarContext.Provider>
      );
    }
     
    function SidebarNav() {
      let { isOpen } = useContext(SidebarContext);
     
      return (
        <div>
          <p>Home</p>
     
          {isOpen && <Subnav />}
        </div>
      );
    }

However, context providers are typically rendered near the root of an
application to share global concerns, like the current theme. Because context
is not supported in Server Components, trying to create a context at the root
of your application will cause an error:

    
    
    import { createContext } from 'react';
     
    //  createContext is not supported in Server Components
    export const ThemeContext = createContext({});
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
          </body>
        </html>
      );
    }

To fix this, create your context and render its provider inside of a Client
Component:

    
    
    'use client';
     
    import { createContext } from 'react';
     
    export const ThemeContext = createContext({});
     
    export default function ThemeProvider({ children }) {
      return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>;
    }

Your Server Component will now be able to directly render your provider since
it's been marked as a Client Component:

    
    
    import ThemeProvider from './theme-provider';
     
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html>
          <body>
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

With the provider rendered at the root, all other Client Components throughout
your app will be able to consume this context.

> Note: You should render providers as deep as possible in the tree – notice
> how `ThemeProvider` only wraps `{children}` instead of the entire `<html>`
> document. This makes it easier for Next.js to optimize the static parts of
> your Server Components.

Third-party npm packages often include Providers that need to be rendered near
the root of your application. If these providers include the `"use client"`
directive, they can be rendered directly inside of your Server Components.
However, since Server Components are so new, many third-party providers won't
have added the directive yet.

If you try to render a third-party provider that doesn't have `"use client"`,
it will cause an error:

    
    
    import { ThemeProvider } from 'acme-theme';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            {/*  Error: `createContext` can't be used in Server Components */}
            <ThemeProvider>{children}</ThemeProvider>
          </body>
        </html>
      );
    }

To fix this, wrap third-party providers in your own Client Component:

    
    
    'use client';
     
    import { ThemeProvider } from 'acme-theme';
    import { AuthProvider } from 'acme-auth';
     
    export function Providers({ children }) {
      return (
        <ThemeProvider>
          <AuthProvider>{children}</AuthProvider>
        </ThemeProvider>
      );
    }

Now, you can import and render `<Providers />` directly within your root
layout.

    
    
    import { Providers } from './providers';
     
    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }

With the providers rendered at the root, all the components and hooks from
these libraries will work as expected within your own Client Components.

Once a third-party library has added `"use client"` to its client code, you'll
be able to remove the wrapper Client Component.

Since Server Components are not interactive and therefore do not read from
React state, you don't need React context to share data. Instead, you can use
native JavaScript patterns for common data that multiple Server Components
need to access. For example, a module can be used to share a database
connection across multiple components:

    
    
    export const db = new DatabaseConnection();
    
    
    import { db } from '@utils/database';
     
    export async function UsersLayout() {
      let users = await db.query();
      // ...
    }
    
    
    import { db } from '@utils/database';
     
    export async function DashboardPage() {
      let user = await db.query();
      // ...
    }

In the above example, both the layout and page need to make database queries.
Each of these components shares access to the database by importing the
`@utils/database` module. This JavaScript pattern is called global singletons.

When fetching data, you may want to share the result of a `fetch` between a
`page` or `layout` and some of its children components. This is an unnecessary
coupling between the components and can lead to passing `props` back and forth
between components.

Instead, we recommend colocating data fetching alongside the component that
consumes the data. `fetch` requests are automatically deduped in Server
Components, so each route segment can request exactly the data it needs
without worrying about duplicate requests. Next.js will read the same value
from the `fetch` cache.



  
  
# Introduction

Welcome to the Next.js documentation!

Next.js is a framework for building web applications.

With Next.js, you can build user interfaces using React components. Then,
Next.js provides additional structure, features, and optimizations for your
application.

Under the hood, Next.js also abstracts and automatically configures tooling
for you, like bundling, compiling, and more. This allows you to focus on
building your application instead of spending time setting up tooling.

Whether you're an individual developer or part of a larger team, Next.js can
help you build interactive, dynamic, and fast web applications.

Some of the main Next.js features include:

Feature| Description  
---|---  
Routing| A file-system based router built on top of Server Components that
supports layouts, nested routing, loading states, error handling, and more.  
Rendering| Client-side and Server-side Rendering with Client and Server
Components. Further optimized with Static and Dynamic Rendering on the server
with Next.js. Streaming on Edge and Node.js runtimes.  
Data Fetching| Simplified data fetching with async/await support in React
Components and the `fetch()`s API that aligns with React and the Web Platform.  
Styling| Support for your preferred styling methods, including CSS Modules,
Tailwind CSS, and CSS-in-JS  
Optimizations| Image, Fonts, and Script Optimizations to improve your
application's Core Web Vitals and User Experience.  
Typescript| Improved support for TypeScript, with better type checking and
more efficient compilation, as well as custom TypeScript Plugin and type
checker.  
API Reference| Updates to the API design throughout Next.js. Please refer to
the API Reference Section for new APIs.  
  
The sections and pages of the docs are organized sequentially, from basic to
advanced, so you can follow them step-by-step when building your Next.js
application. However, you can read them in any order or skip to the pages that
apply to your use case.

At the top of the sidebar, you'll notice a dropdown menu that allows you to
switch between the **App Router** the **Pages Router** features. Since there
are features that are unique to each directory, it's important to keep track
of which tab is selected.

On the right side of the page, you'll see a table of contents that makes it
easier to navigate between sections of a page. The breadcrumbs at the top of
the page will also indicate whether you're viewing App Router docs or Pages
Router docs.

To get started, checkout the Installation. If you're new to React or Server
Components, we recommend reading the React Essentials page.

Although our docs are designed to be beginner-friendly, we need to establish a
baseline so that the docs can stay focused on Next.js functionality. We'll
make sure to provide links to relevant documentation whenever we introduce a
new concept.

To get the most out of our docs, it's recommended that you have a basic
understanding of HTML, CSS, and React. If you need to brush up on your React
skills, check out these resources:

For optimal accessibility when using a screen reader while reading the docs,
we recommend using Firefox and NVDA, or Safari and VoiceOver.

If you have questions about anything related to Next.js, you're always welcome
to ask our community on GitHub Discussions, Discord, Twitter, and Reddit.





Using App Router

Features available in /app





Using Pages Router

Features available in /pages





Using App Router

Features available in /app





# Introduction

Welcome to the Next.js documentation!

Next.js is a framework for building web applications.

With Next.js, you can build user interfaces using React components. Then,
Next.js provides additional structure, features, and optimizations for your
application.

Under the hood, Next.js also abstracts and automatically configures tooling
for you, like bundling, compiling, and more. This allows you to focus on
building your application instead of spending time setting up tooling.

Whether you're an individual developer or part of a larger team, Next.js can
help you build interactive, dynamic, and fast web applications.

Some of the main Next.js features include:

Feature| Description  
---|---  
Routing| A file-system based router built on top of Server Components that
supports layouts, nested routing, loading states, error handling, and more.  
Rendering| Client-side and Server-side Rendering with Client and Server
Components. Further optimized with Static and Dynamic Rendering on the server
with Next.js. Streaming on Edge and Node.js runtimes.  
Data Fetching| Simplified data fetching with async/await support in React
Components and the `fetch()`s API that aligns with React and the Web Platform.  
Styling| Support for your preferred styling methods, including CSS Modules,
Tailwind CSS, and CSS-in-JS  
Optimizations| Image, Fonts, and Script Optimizations to improve your
application's Core Web Vitals and User Experience.  
Typescript| Improved support for TypeScript, with better type checking and
more efficient compilation, as well as custom TypeScript Plugin and type
checker.  
API Reference| Updates to the API design throughout Next.js. Please refer to
the API Reference Section for new APIs.  
  
The sections and pages of the docs are organized sequentially, from basic to
advanced, so you can follow them step-by-step when building your Next.js
application. However, you can read them in any order or skip to the pages that
apply to your use case.

At the top of the sidebar, you'll notice a dropdown menu that allows you to
switch between the **App Router** the **Pages Router** features. Since there
are features that are unique to each directory, it's important to keep track
of which tab is selected.

On the right side of the page, you'll see a table of contents that makes it
easier to navigate between sections of a page. The breadcrumbs at the top of
the page will also indicate whether you're viewing App Router docs or Pages
Router docs.

To get started, checkout the Installation. If you're new to React or Server
Components, we recommend reading the React Essentials page.

Although our docs are designed to be beginner-friendly, we need to establish a
baseline so that the docs can stay focused on Next.js functionality. We'll
make sure to provide links to relevant documentation whenever we introduce a
new concept.

To get the most out of our docs, it's recommended that you have a basic
understanding of HTML, CSS, and React. If you need to brush up on your React
skills, check out these resources:

For optimal accessibility when using a screen reader while reading the docs,
we recommend using Firefox and NVDA, or Safari and VoiceOver.

If you have questions about anything related to Next.js, you're always welcome
to ask our community on GitHub Discussions, Discord, Twitter, and Reddit.

